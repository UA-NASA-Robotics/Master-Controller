Disassembly Listing for NaviController
Generated From:
C:/microchip/harmony/v2_05_01/apps/Master-Controller/NaviController/firmware/NaviController.X/dist/default/debug/NaviController.X.debug.elf
Jan 20, 2020 12:53:37 PM

---  c:/program files (x86)/microchip/xc32/v2.20/pic32mx/lib/crt0.S  ------------------------------------
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     *
                                                  32:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  33:     * derived from this software without specific prior written permission.
                                                  34:     *
                                                  35:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  36:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  37:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  38:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  39:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  40:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  41:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  42:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  43:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  44:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  45:     *
                                                  46:     ********************************************************************/
                                                  47:    
                                                  48:    #include "xc.h"
                                                  49:    #include <cp0defs.h>
                                                  50:    
                                                  51:    #ifdef __LIBBUILD__
                                                  52:       # Replace the standard debugging information with a simple filename. This
                                                  53:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  54:       # also effectively disables source-line debugging.
                                                  55:       .file 1 "libpic32/startup/crt0.S"
                                                  56:       .loc 1 0
                                                  57:    #endif
                                                  58:    
                                                  59:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  60:    #define CPP_INIT
                                                  61:    #endif
                                                  62:    
                                                  63:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  64:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  65:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  66:    #  else
                                                  67:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  68:    #    define PIC32_SRS_SET_COUNT 2
                                                  69:    #  endif
                                                  70:    #endif
                                                  71:    
                                                  72:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  73:    #define INIT_DATA 1
                                                  74:    #endif
                                                  75:    
                                                  76:    /* This file contains 32-bit assembly code */
                                                  77:           .set nomips16
                                                  78:    
                                                  79:            ##################################################################
                                                  80:            # Entry point of the entire application
                                                  81:            ##################################################################
                                                  82:            .section .reset,code,keep
                                                  83:            .align 2
                                                  84:            .set noreorder
                                                  85:            .ent _reset
                                                  86:    
                                                  87:    ############################
                                                  88:    # Begin ISA switching code #
                                                  89:    ############################
                                                  90:    
                                                  91:    #if defined (__mips_micromips)
                                                  92:            .set micromips
                                                  93:    #endif
                                                  94:    
                                                  95:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  96:    _reset:
                                                  97:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  98:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  99:                                 /* DO NOT change the relative branch               */
                                                  100:   
                                                  101:           .word 0x00000000     /* NOP */
                                                  102:   __reset_micromips_isa:
                                                  103:           .set    micromips
BFC00008  0006F3F0   TGE ZERO, A2                 104:           jal     _startup
BFC0000C  00000000   NOP                          105:           nop
                                                  106:   
                                                  107:           .align 2
                                                  108:           /* Device not in proper ISA mode */
                                                  109:           .set nomicromips
                                                  110:   __reset_switch_isa:
BFC00010  0FF00006   JAL 0xBFC00018               111:           jal _startup
BFC00014  00000000   NOP                          112:           nop
                                                  113:   
                                                  114:   #else
                                                  115:   
                                                  116:   _reset:
                                                  117:           jal _startup
                                                  118:           nop
                                                  119:   
                                                  120:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  121:   
                                                  122:           .align 2
                                                  123:           .end _reset
                                                  124:           .globl _reset
                                                  125:           .size _reset, .-_reset
                                                  126:   
                                                  127:           .section .reset.startup,code,keep
                                                  128:           .align 2
                                                  129:           .set noreorder
                                                  130:   
                                                  131:   #if defined (__mips_micromips)
                                                  132:           .set micromips
                                                  133:   #else
                                                  134:           .set nomicromips
                                                  135:   #endif
                                                  136:   
                                                  137:   ############################
                                                  138:   # End ISA switching code   #
                                                  139:   ############################
                                                  140:   
                                                  141:           ##################################################################
                                                  142:           # Startup code
                                                  143:           ##################################################################
                                                  144:           .align 2
                                                  145:           .globl _startup
                                                  146:           .set noreorder
                                                  147:           .ent _startup
                                                  148:   _startup:
                                                  149:           ##################################################################
                                                  150:           # If entered because of an NMI, jump to the NMI handler.
                                                  151:           ##################################################################
BFC00018  401A6000   MFC0 K0, Status              152:           mfc0    k0,_CP0_STATUS
BFC0001C  7F5A04C0   EXT K0, K0, 19, 1            153:           ext     k0,k0,19,1              # Extract NMI bit
BFC00020  13400005   BEQ K0, ZERO, 0xBFC00038     154:           beqz    k0,_no_nmi
BFC00024  00000000   NOP                          155:           nop
BFC00028  3C1A9D01   LUI K0, -25343               156:           la      k0,_nmi_handler
BFC00030  03400008   JR K0                        157:           jr      k0
BFC00034  00000000   NOP                          158:           nop
                                                  159:   _no_nmi:
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Stack Pointer
                                                  163:           #   _stack is initialized by the linker script to point to the
                                                  164:           #    starting location of the stack in DRM
                                                  165:           ##################################################################
BFC00038  3C1D8008   LUI SP, -32760               166:           la      sp,_stack
                                                  167:   
                                                  168:           ##################################################################
                                                  169:           # Initialize Global Pointer
                                                  170:           #   _gp is initialized by the linker script to point to "middle"
                                                  171:           #   of the small variables region
                                                  172:           ##################################################################
BFC00040  3C1C8001   LUI GP, -32767               173:           la      gp,_gp
                                                  174:   
                                                  175:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  176:           ##################################################################
                                                  177:           # Initialize Global Pointer in Shadow Set
                                                  178:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  179:           #   to initialize the global pointer.  Since we have only a
                                                  180:           #   single shadow set (besides the normal), we will initialize
                                                  181:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  182:           #   to the previous shadow set to ensure that on interrupt, the
                                                  183:           #   global pointer has been initialized.
                                                  184:           ##################################################################
                                                  185:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  186:           add     t3,t1,zero              # Save off current SRSCtl
                                                  187:           ext     t2,t1,26,4              # to obtain HSS field
                                                  188:           ins     t1,t2,6,4               # Put HSS field
                                                  189:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  190:           ehb                             # Clear hazard before using new SRSCTL
                                                  191:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  192:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  193:           ehb
                                                  194:   
                                                  195:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  196:           ##################################################################
                                                  197:           # Initialize Global Pointer in Shadow Set(s)
                                                  198:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  199:           #   to initialize the global pointer.  We will initialize
                                                  200:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  201:           #   We write the global pointer to the previous shadow set to
                                                  202:           #   ensure that on interrupt, the global pointer has been
                                                  203:           #   initialized.
                                                  204:           ##################################################################
BFC00048  40096002   MFC0 T1, SRSCtl              205:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
BFC0004C  01205820   ADD T3, T1, ZERO             206:           add     t3,t1,zero              # Save off current SRSCtl
                                                  207:   
BFC00050  240A0007   ADDIU T2, ZERO, 7            208:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  209:   
BFC00054  7D494984   INS T1, T2, 6, 4             210:   1:      ins     t1,t2,6,4               # Put next shadow set field
BFC00058  40896002   MTC0 T1, SRSCtl              211:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
BFC0005C  000000C0   EHB                          212:           ehb                             # Clear hazard before using new SRSCTL
BFC00060  41DCE000   WRPGPR GP, GP                213:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  214:   
BFC00064  254AFFFF   ADDIU T2, T2, -1             215:           addiu   t2,t2,-1                # Next lower shadow set
                                                  216:                                           # Loop for all sets
BFC00068  1540FFFA   BNE T2, ZERO, 0xBFC00054     217:           bne     t2,$0,1b                # Down to zero (normal GPR set)
BFC0006C  00000000   NOP                          218:           nop
                                                  219:   
BFC00070  408B6002   MTC0 T3, SRSCtl              220:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
BFC00074  000000C0   EHB                          221:           ehb
                                                  222:   
                                                  223:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  224:   
                                                  225:           ##################################################################
                                                  226:           # Call the "on reset" procedure
                                                  227:           ##################################################################
BFC00078  3C089D01   LUI T0, -25343               228:           la      t0,_on_reset
BFC00080  0100F809   JALR T0                      229:           jalr    t0
BFC00084  00000000   NOP                          230:           nop
                                                  231:   
                                                  232:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  233:           ##################################################################
                                                  234:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  235:           ##################################################################
                                                  236:           .extern __pic32_tlb_init_ebi_sqi
BFC00088  3C089D01   LUI T0, -25343               237:           la      t0,__pic32_tlb_init_ebi_sqi
BFC00090  0100F809   JALR T0                      238:           jalr    t0
BFC00094  00000000   NOP                          239:           nop
                                                  240:   #endif
                                                  241:   
                                                  242:           ##################################################################
                                                  243:           # Clear uninitialized data sections
                                                  244:           ##################################################################
                                                  245:   _start_bss_init:
BFC00098  3C088000   LUI T0, -32768               246:           la      t0,_bss_begin
BFC000A0  3C098000   LUI T1, -32768               247:           la      t1,_bss_end
BFC000A8  10000003   BEQ ZERO, ZERO, 0xBFC000B8   248:           b       _bss_check
BFC000AC  00000000   NOP                          249:           nop
                                                  250:   
                                                  251:   _bss_init:
BFC000B0  AD000000   SW ZERO, 0(T0)               252:           sw      zero,0x0(t0)
BFC000B4  25080004   ADDIU T0, T0, 4              253:           addu    t0,4
                                                  254:   _bss_check:
BFC000B8  0109082B   SLTU AT, T0, T1              255:           bltu    t0,t1,_bss_init
BFC000C0  00000000   NOP                          256:           nop
                                                  257:   
                                                  258:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  259:           ##################################################################
                                                  260:           # Initialize L1 cache. This must be done after bss clearing
                                                  261:           # since the _bss_end symbol may not be cache-line aligned.
                                                  262:           ##################################################################
                                                  263:           .extern   __pic32_init_cache
BFC000C4  3C08BFC0   LUI T0, -16448               264:           la      t0,__pic32_init_cache
BFC000CC  0100F809   JALR T0                      265:           jalr    t0
BFC000D0  00000000   NOP                          266:           nop
                                                  267:   #endif
                                                  268:   
                                                  269:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  270:   
                                                  271:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  272:   
                                                  273:           ##################################################################
                                                  274:           # Initialize data using the linker-generated .dinit table
                                                  275:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  276:           ##################################################################
                                                  277:           .equiv FMT_CLEAR,0
                                                  278:           .equiv FMT_COPY,1
                                                  279:   _dinit_init:
                                                  280:           la      t0,_dinit_addr
                                                  281:   
                                                  282:   #define SRC t0
                                                  283:   #define DST t1
                                                  284:   #define LEN t2
                                                  285:   #define FMT t3
                                                  286:   
                                                  287:   0:      lw      DST,0(SRC)
                                                  288:           beqz    DST,9f
                                                  289:           addu    SRC,4
                                                  290:           lw      LEN,0(SRC)
                                                  291:           addu    SRC,4
                                                  292:           lw      FMT,0(SRC)
                                                  293:           beq     FMT,$0,_dinit_clear
                                                  294:           addu    SRC,4
                                                  295:   
                                                  296:   _dinit_copy:
                                                  297:           lbu     t4,0(SRC)
                                                  298:           subu    LEN,1
                                                  299:           addu    SRC,1
                                                  300:           sb      t4,0(DST)
                                                  301:           bne     LEN,$0,_dinit_copy
                                                  302:           addu    DST,1
                                                  303:   
                                                  304:           b       _dinit_end
                                                  305:           nop
                                                  306:   
                                                  307:   _dinit_clear:
                                                  308:           sb      $0,(DST)
                                                  309:           subu    LEN,1
                                                  310:           bne     LEN,$0,_dinit_clear
                                                  311:           addu    DST,1
                                                  312:   
                                                  313:   _dinit_end:
                                                  314:           addu    SRC,3
                                                  315:           addiu   LEN,$0,0xFFFFFFFC
                                                  316:           and     SRC,LEN,SRC
                                                  317:           lw      DST,0(SRC)
                                                  318:           bne     DST,$0,0b
                                                  319:           nop
                                                  320:   9:
                                                  321:   
                                                  322:   #else
                                                  323:           #####################################################################
                                                  324:           # Initialize data using the linker-generated .dinit table
                                                  325:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  326:           # packaged with the compiler rather than the DFP. Use that init
                                                  327:           # code instead.
                                                  328:           #####################################################################
                                                  329:           .extern   __pic32_data_init
BFC000D4  3C089D01   LUI T0, -25343               330:           la      t0, __pic32_data_init
BFC000DC  0100F809   JALR T0                      331:           jalr    t0
BFC000E0  00000000   NOP                          332:           nop
                                                  333:   #endif /* __LIBBUILD__ */
                                                  334:   
                                                  335:   #endif /* INIT_DATA */
                                                  336:   
                                                  337:           ##################################################################
                                                  338:           # If there are no RAM functions, skip the next section --
                                                  339:           # initializing bus matrix registers.
                                                  340:           ##################################################################
BFC000E4  3C090000   LUI T1, 0                    341:           la      t1,_ramfunc_begin
BFC000EC  11200001   BEQ T1, ZERO, 0xBFC000F4     342:           beqz    t1,_ramfunc_done
BFC000F0  00000000   NOP                          343:           nop
                                                  344:   
                                                  345:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  346:     /* No initialization required */
                                                  347:   #else /* Use BMX */
                                                  348:           ##################################################################
                                                  349:           # Initialize bus matrix registers if RAM functions exist in the
                                                  350:           # application
                                                  351:           ##################################################################
                                                  352:           la      t1,_bmxdkpba_address
                                                  353:           la      t2,BMXDKPBA
                                                  354:           sw      t1,0(t2)
                                                  355:           la      t1,_bmxdudba_address
                                                  356:           la      t2,BMXDUDBA
                                                  357:           sw      t1,0(t2)
                                                  358:           la      t1,_bmxdupba_address
                                                  359:           la      t2,BMXDUPBA
                                                  360:           sw      t1,0(t2)
                                                  361:   #endif /* INIT_SSX */
                                                  362:   
                                                  363:   _ramfunc_done:
                                                  364:   
                                                  365:           ##################################################################
                                                  366:           # Initialize CP0 registers
                                                  367:           ##################################################################
                                                  368:           # Initialize Count register
                                                  369:           ##################################################################
BFC000F4  40804800   MTC0 ZERO, Count             370:           mtc0    zero,_CP0_COUNT
                                                  371:   
                                                  372:           ##################################################################
                                                  373:           # Initialize Compare register
                                                  374:           ##################################################################
BFC000F8  240AFFFF   ADDIU T2, ZERO, -1           375:           li      t2,-1
BFC000FC  408A5800   MTC0 T2, Compare             376:           mtc0    t2,_CP0_COMPARE
                                                  377:   
                                                  378:           ##################################################################
                                                  379:           # Ensure BEV set and Initialize EBase register
                                                  380:           ##################################################################
BFC00100  3C080040   LUI T0, 64                   381:           li      t0, (1<<22)
BFC00104  400A6000   MFC0 T2, Status              382:           mfc0    t2,_CP0_STATUS
BFC00108  010A5025   OR T2, T0, T2                383:           or      t2,t0,t2               # Set BEV bit 22
BFC0010C  408A6000   MTC0 T2, Status              384:           mtc0    t2,_CP0_STATUS
                                                  385:   
BFC00110  3C099D00   LUI T1, -25344               386:           la      t1,_ebase_address
BFC00118  000000C0   EHB                          387:           ehb
BFC0011C  40897801   MTC0 T1, EBase               388:           mtc0    t1,_CP0_EBASE
                                                  389:           
                                                  390:           ##################################################################
                                                  391:           # Initialize PRISS register to a safer default for devices that 
                                                  392:           # have it. The application should re-initialize it to an
                                                  393:           # application-specific value.
                                                  394:           #
                                                  395:           # We do NOT do this by default.
                                                  396:           ##################################################################
                                                  397:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  398:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  399:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  400:           li	    t2, 0x76540000
                                                  401:           addiu	t2, t2, 0x3210
                                                  402:           lui	    t1, %hi(PRISS)
                                                  403:           sw	    t2, %lo(PRISS)(t1)
                                                  404:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  405:           li	    t2, 0x10000000
                                                  406:           lui	    t1, %hi(PRISS)
                                                  407:           sw	    t2, %lo(PRISS)(t1)
                                                  408:   #endif /* PIC32_SRS_SET_COUNT */
                                                  409:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  410:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  411:           
                                                  412:           ##################################################################
                                                  413:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  414:           ##################################################################
BFC00120  3C090000   LUI T1, 0                    415:           la      t1,_vector_spacing
                                                  416:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  417:           la      t0, INTCON
                                                  418:           lw      t2, 0(t0)
                                                  419:           li      t2, 0
                                                  420:           ins     t2, t1, 16, 7
                                                  421:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  422:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  423:   #endif
                                                  424:           sw      t2, 0(t0)
                                                  425:   #endif
BFC00128  240A0000   ADDIU T2, ZERO, 0            426:           li      t2,0                    # Clear t2 and
BFC0012C  7D2A4944   INS T2, T1, 5, 5             427:           ins     t2,t1,5,5               # shift value to VS field
BFC00130  408A6001   MTC0 T2, IntCtl              428:           mtc0    t2,_CP0_INTCTL
                                                  429:   
                                                  430:           ##################################################################
                                                  431:           # Initialize CAUSE registers
                                                  432:           # - Enable counting of Count register <DC = 0>
                                                  433:           # - Use special exception vector <IV = 1>
                                                  434:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  435:           ##################################################################
BFC00134  3C090080   LUI T1, 128                  436:           li      t1,0x00800000
BFC00138  40896800   MTC0 T1, Cause               437:           mtc0    t1,_CP0_CAUSE
                                                  438:   
                                                  439:           ##################################################################
                                                  440:           # Initialize STATUS register
                                                  441:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  442:           # - User mode uses configured endianness <RE = 0>
                                                  443:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  444:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  445:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  446:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  447:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  448:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  449:           # - Base mode is Kernel mode <UM = 0>
                                                  450:           # - Error level is normal <ERL = 0>
                                                  451:           # - Exception level is normal <EXL = 0>
                                                  452:           # - Interrupts are disabled <IE = 0>
                                                  453:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  454:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  455:           ##################################################################
BFC0013C  40088000   MFC0 T0, Config              456:           mfc0    t0,_CP0_CONFIG
BFC00140  7D090580   EXT T1, T0, 22, 1            457:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00144  00094C40   SLL T1, T1, 17               458:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00148  40086000   MFC0 T0, Status              459:           mfc0    t0,_CP0_STATUS
BFC0014C  3C010058   LUI AT, 88                   460:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  461:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
BFC00154  3C0A0100   LUI T2, 256                  462:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
BFC00158  01484025   OR T0, T2, T0                463:           or      t0,t2,t0
                                                  464:   #endif
                                                  465:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
BFC0015C  3C0A2400   LUI T2, 9216                 466:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
BFC00160  01484025   OR T0, T2, T0                467:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  468:   #endif
                                                  469:   
BFC00164  01284025   OR T0, T1, T0                470:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00168  40886000   MTC0 T0, Status              471:           mtc0    t0,_CP0_STATUS
                                                  472:           
                                                  473:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  474:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  475:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  476:           li      t1,0x10000              # ISAONEXEC bit
                                                  477:           mfc0    t0,_CP0_CONFIG3
                                                  478:           or      t1,t0,t1
                                                  479:           mtc0    t1,_CP0_CONFIG3
                                                  480:   
                                                  481:   #endif /* PIC32WK && __mips_micromips */
                                                  482:   
                                                  483:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  484:                                           # FPU Control and Status
BFC0016C  3C0A0100   LUI T2, 256                  485:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  486:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
BFC00170  44CAF800   CTC1 T2, F31                 487:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  488:   #endif
BFC00174  000000C0   EHB                          489:           ehb
                                                  490:   
                                                  491:           ##################################################################
                                                  492:           # Call the "on bootstrap" procedure
                                                  493:           ##################################################################
BFC00178  3C089D01   LUI T0, -25343               494:           la      t0,_on_bootstrap
BFC00180  0100F809   JALR T0                      495:           jalr    t0
BFC00184  00000000   NOP                          496:           nop
                                                  497:   
                                                  498:           ##################################################################
                                                  499:           # Initialize Status<BEV> for normal exception vectors
                                                  500:           ##################################################################
BFC00188  40086000   MFC0 T0, Status              501:           mfc0    t0,_CP0_STATUS
BFC0018C  3C01FFBF   LUI AT, -65                  502:           and     t0,t0,0xffbfffff        # Clear BEV
BFC00198  40886000   MTC0 T0, Status              503:           mtc0    t0,_CP0_STATUS
                                                  504:   
                                                  505:           ##################################################################
                                                  506:           # Call main. We do this via a thunk in the text section so that
                                                  507:           # a normal jump and link can be used, enabling the startup code
                                                  508:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  509:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  510:           # necessary
                                                  511:           ##################################################################
BFC0019C  30840000   ANDI A0, A0, 0               512:           and     a0,a0,0
BFC001A0  30A50000   ANDI A1, A1, 0               513:           and     a1,a1,0
BFC001A4  3C089D01   LUI T0, -25343               514:           la      t0,_main_entry
BFC001AC  01000008   JR T0                        515:           jr      t0
BFC001B0  00000000   NOP                          516:           nop
                                                  517:   
                                                  518:           .end _startup
                                                  519:   
                                                  520:           ##################################################################
                                                  521:           # Boot Exception Vector Handler
                                                  522:           # Jumps to _bootstrap_exception_handler
                                                  523:           ##################################################################
                                                  524:           .section .bev_handler,code,keep
                                                  525:           .align 2
                                                  526:           .set noreorder
                                                  527:           .ent _bev_exception
                                                  528:   _bev_exception:
BFC00380  3C1A9D01   LUI K0, -25343               529:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        530:           jr        k0
BFC0038C  00000000   NOP                          531:           nop
                                                  532:   
                                                  533:           .end _bev_exception
                                                  534:   
                                                  535:           ##################################################################
                                                  536:           # General Exception Vector Handler
                                                  537:           # Jumps to _general_exception_context
                                                  538:           ##################################################################
                                                  539:           .section .gen_handler,code
                                                  540:           .align 2
                                                  541:           .set noreorder
                                                  542:           .ent _gen_exception
                                                  543:   _gen_exception:
9D000180  3C1A9D01   LUI K0, -25343               544:   0:      la      k0,_general_exception_context
9D000188  03400008   JR K0                        545:           jr      k0
9D00018C  00000000   NOP                          546:           nop
                                                  547:   
                                                  548:           .end _gen_exception
                                                  549:   
                                                  550:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  551:           ##################################################################
                                                  552:           # Simple TLB-Refill Exception Vector
                                                  553:           # Jumps to _simple_tlb_refill_exception_context
                                                  554:           ##################################################################
                                                  555:           .section .simple_tlb_refill_vector,code,keep
                                                  556:           .align 2
                                                  557:           .set noreorder
                                                  558:           .ent simple_tlb_refill_vector
                                                  559:   simple_tlb_refill_vector:
9D000000  3C1A9D01   LUI K0, -25343               560:           la      k0,_simple_tlb_refill_exception_context
9D000008  03400008   JR K0                        561:           jr      k0
9D00000C  00000000   NOP                          562:           nop
                                                  563:   
                                                  564:           .end simple_tlb_refill_vector
                                                  565:   #endif
                                                  566:   
                                                  567:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  568:           ##################################################################
                                                  569:           # Cache-Error Exception Vector Handler
                                                  570:           # Jumps to _cache_err_exception_context
                                                  571:           ##################################################################
                                                  572:           .section .cache_err_vector,code,keep
                                                  573:           .align 2
                                                  574:           .set noreorder
                                                  575:           .ent _cache_err_vector
                                                  576:   _cache_err_vector:
9D000100  3C1A9D01   LUI K0, -25343               577:           la      k0,_cache_err_exception_context
9D000108  03400008   JR K0                        578:           jr      k0
9D00010C  00000000   NOP                          579:           nop
                                                  580:   
                                                  581:           .end _cache_err_vector
                                                  582:   #endif
                                                  583:   
                                                  584:           .section .text.main_entry,code,keep
                                                  585:           .align 2
                                                  586:           .ent _main_entry
                                                  587:   _main_entry:
                                                  588:   
                                                  589:   #if defined(CPP_INIT)
                                                  590:           .weak _init
                                                  591:           # call .init section to run constructors etc
9D00BFD4  3C040000   LUI A0, 0                    592:           lui	a0,%hi(_init)
9D00BFD8  27BDFFE8   ADDIU SP, SP, -24            593:           addiu	sp,sp,-24
9D00BFDC  24840000   ADDIU A0, A0, 0              594:           addiu	a0,a0,%lo(_init)
9D00BFE0  10800003   BEQ A0, ZERO, 0x9D00BFF0     595:           beq	a0,$0,2f
9D00BFE4  AFBF0014   SW RA, 20(SP)                596:           sw	$31,20(sp)	 #,
9D00BFE8  0080F809   JALR A0                      597:           jalr	a0
9D00BFEC  00000000   NOP                          598:           nop
                                                  599:   2:
                                                  600:   #endif
9D00BFF0  30840000   ANDI A0, A0, 0               601:           and     a0,a0,0
9D00BFF4  30A50000   ANDI A1, A1, 0               602:           and     a1,a1,0
                                                  603:   
                                                  604:           ##################################################################
                                                  605:   
                                                  606:           # Call main
                                                  607:           ##################################################################
9D00BFF8  3C089D01   LUI T0, -25343               608:           la    	t0,main
9D00C000  0100F809   JALR T0                      609:           jalr 	t0
9D00C004  00000000   NOP                          610:           nop
                                                  611:   
                                                  612:   #if defined(CALL_EXIT)
                                                  613:           ##################################################################
                                                  614:           # Call exit()
                                                  615:           ##################################################################
                                                  616:           jal exit
                                                  617:           nop
                                                  618:   #endif
                                                  619:   
                                                  620:           ##################################################################
                                                  621:           # Just in case, go into infinite loop
                                                  622:           # Call a software breakpoint only with -mdebugger compiler option
                                                  623:           ##################################################################
                                                  624:           .weak __exception_handler_break
                                                  625:   __crt0_exit:
                                                  626:   1:
9D00C008  3C029D00   LUI V0, -25344               627:           la      v0,__exception_handler_break
9D00C010  10400003   BEQ V0, ZERO, 0x9D00C020     628:           beq     v0,0,0f
9D00C014  00000000   NOP                          629:           nop
9D00C018  0040F809   JALR V0                      630:           jalr    v0
9D00C01C  00000000   NOP                          631:           nop
                                                  632:   
9D00C020  1000FFF9   BEQ ZERO, ZERO, 0x9D00C008   633:   0:      b       1b
9D00C024  00000000   NOP                          634:           nop
                                                  635:   
                                                  636:           .globl __crt0_exit
                                                  637:           .end _main_entry
---  c:/program files (x86)/microchip/xc32/v2.20/pic32mx/include/fdlmath.h  -----------------------------
1:                   /*-------------------------------------------------------------------------
2:                    * MPLAB XC Compiler - fdlmath.h
3:                    *
4:                    * Copyright (c) 2015, Microchip Technology Inc. and its subsidiaries ("Microchip")
5:                    * All rights reserved.
6:                    *
7:                    * This software is developed by Microchip Technology Inc. and its
8:                    * subsidiaries ("Microchip").
9:                    *
10:                   * Redistribution and use in source and binary forms, with or without
11:                   * modification, are permitted provided that the following conditions are
12:                   * met:
13:                   *
14:                   * 1.      Redistributions of source code must retain the above copyright
15:                   *         notice, this list of conditions and the following disclaimer.
16:                   * 2.      Redistributions in binary form must reproduce the above
17:                   *         copyright notice, this list of conditions and the following
18:                   *         disclaimer in the documentation and/or other materials provided
19:                   *         with the distribution.
20:                   * 3.      Microchip's name may not be used to endorse or promote products
21:                   *         derived from this software without specific prior written
22:                   *         permission.
23:                   *
24:                   * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
25:                   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
26:                   * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED. IN NO EVENT
27:                   * SHALL MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
28:                   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
29:                   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
30:                   * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
31:                   * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
32:                   * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
33:                   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
34:                   *
35:                   */
36:                  
37:                  #pragma once
38:                  
39:                  #ifndef __FDLMATH_H
40:                  #define __FDLMATH_H
41:                  
42:                  /* "f", "l", and "" (double) math.h function routing */
43:                  #if defined(__FDLMATH_SHORT_DOUBLE) || defined(SHORT_DOUBLE)
44:                  #define __FDLMATH_XDOUBLE long double
45:                  #else
46:                  #define __FDLMATH_XDOUBLE double
47:                  #endif
48:                  
49:                  extern __FDLMATH_XDOUBLE _acosx(__FDLMATH_XDOUBLE x);
50:                  extern __FDLMATH_XDOUBLE _asinx(__FDLMATH_XDOUBLE x);
51:                  extern __FDLMATH_XDOUBLE _atanx(__FDLMATH_XDOUBLE x);
52:                  extern __FDLMATH_XDOUBLE _atan2x(__FDLMATH_XDOUBLE y, __FDLMATH_XDOUBLE x);
53:                  extern __FDLMATH_XDOUBLE _ceilx(__FDLMATH_XDOUBLE x);
54:                  extern __FDLMATH_XDOUBLE _cosx(__FDLMATH_XDOUBLE x);
55:                  extern __FDLMATH_XDOUBLE _coshx(__FDLMATH_XDOUBLE x);
56:                  extern __FDLMATH_XDOUBLE _expx(__FDLMATH_XDOUBLE x);
57:                  extern __FDLMATH_XDOUBLE _fabsx(__FDLMATH_XDOUBLE x);
58:                  extern __FDLMATH_XDOUBLE _floorx(__FDLMATH_XDOUBLE x);
59:                  extern __FDLMATH_XDOUBLE _fmodx(__FDLMATH_XDOUBLE x, __FDLMATH_XDOUBLE y);
60:                  extern __FDLMATH_XDOUBLE _frexpx(__FDLMATH_XDOUBLE x, int *pexp);
61:                  extern __FDLMATH_XDOUBLE _ldexpx(__FDLMATH_XDOUBLE x, int exp);
62:                  extern __FDLMATH_XDOUBLE _logx(__FDLMATH_XDOUBLE x);
63:                  extern __FDLMATH_XDOUBLE _log10x(__FDLMATH_XDOUBLE x);
64:                  extern __FDLMATH_XDOUBLE _modfx(__FDLMATH_XDOUBLE y, __FDLMATH_XDOUBLE *pint);
65:                  extern __FDLMATH_XDOUBLE _powx(__FDLMATH_XDOUBLE x, __FDLMATH_XDOUBLE y);
66:                  extern __FDLMATH_XDOUBLE _sinx(__FDLMATH_XDOUBLE x);
67:                  extern __FDLMATH_XDOUBLE _sinhx(__FDLMATH_XDOUBLE x);
68:                  extern __FDLMATH_XDOUBLE _sqrtx(__FDLMATH_XDOUBLE x);
69:                  extern __FDLMATH_XDOUBLE _tanx(__FDLMATH_XDOUBLE x);
70:                  extern __FDLMATH_XDOUBLE _tanhx(__FDLMATH_XDOUBLE x);
71:                  
72:                  #define __FDLMATH_INLINE static inline __attribute__((always_inline))
73:                  
74:                  /* "f" SP routines are adaptors to "x" DP code */
75:                  __FDLMATH_INLINE float acosf(float x)
76:                  {
77:                      return (float)_acosx((__FDLMATH_XDOUBLE)x);
78:                  }
79:                  __FDLMATH_INLINE float asinf(float x)
80:                  {
81:                      return (float)_asinx((__FDLMATH_XDOUBLE)x);
82:                  }
83:                  __FDLMATH_INLINE float atanf(float x)
84:                  {
85:                      return (float)_atanx((__FDLMATH_XDOUBLE)x);
86:                  }
87:                  __FDLMATH_INLINE float atan2f(float y, float x)
88:                  {
89:                      return (float)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
90:                  }
91:                  __FDLMATH_INLINE float ceilf(float x)
92:                  {
93:                      return (float)_ceilx((__FDLMATH_XDOUBLE)x);
94:                  }
95:                  __FDLMATH_INLINE float cosf(float x)
96:                  {
97:                      return (float)_cosx((__FDLMATH_XDOUBLE)x);
98:                  }
99:                  __FDLMATH_INLINE float coshf(float x)
100:                 {
101:                     return (float)_coshx((__FDLMATH_XDOUBLE)x);
102:                 }
103:                 __FDLMATH_INLINE float expf(float x)
104:                 {
105:                     return (float)_expx((__FDLMATH_XDOUBLE)x);
106:                 }
107:                 __FDLMATH_INLINE float fabsf(float x)
108:                 {
109:                     return (float)_fabsx((__FDLMATH_XDOUBLE)x);
110:                 }
111:                 __FDLMATH_INLINE float floorf(float x)
112:                 {
113:                     return (float)_floorx((__FDLMATH_XDOUBLE)x);
9D000800  0F4022E4   JAL _floorx
9D000804  46006321   CVT.D.S F12, F12
9D000808  46200020   CVT.S.D F0, F0
9D0011A0  0F4022E4   JAL _floorx
9D0011A4  46006321   CVT.D.S F12, F12
9D0011A8  46200020   CVT.S.D F0, F0
114:                 }
115:                 __FDLMATH_INLINE float fmodf(float x, float y)
116:                 {
117:                     return (float)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
118:                 }
119:                 __FDLMATH_INLINE float frexpf(float x, int *pexp)
120:                 {
121:                     return (float)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
122:                 }
123:                 __FDLMATH_INLINE float ldexpf(float x, int exp)
124:                 {
125:                     return (float)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
126:                 }
127:                 __FDLMATH_INLINE float logf(float x)
128:                 {
129:                     return (float)_logx((__FDLMATH_XDOUBLE)x);
130:                 }
131:                 __FDLMATH_INLINE float log10f(float x)
132:                 {
133:                     return (float)_log10x((__FDLMATH_XDOUBLE)x);
134:                 }
135:                 __FDLMATH_INLINE float modff(float x, float *pint)
136:                 {
137:                     __FDLMATH_XDOUBLE dpint;
138:                     float r;
139:                 
140:                     r = (float)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
141:                     *pint = (float)dpint;
142:                 
143:                     return r;
144:                 }
145:                 __FDLMATH_INLINE float powf(float x, float y)
146:                 {
147:                     return (float)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
148:                 }
149:                 __FDLMATH_INLINE float sinf(float x)
150:                 {
151:                     return (float)_sinx((__FDLMATH_XDOUBLE)x);
152:                 }
153:                 __FDLMATH_INLINE float sinhf(float x)
154:                 {
155:                     return (float)_sinhx((__FDLMATH_XDOUBLE)x);
156:                 }
157:                 __FDLMATH_INLINE float sqrtf(float x)
158:                 {
159:                     return (float)_sqrtx((__FDLMATH_XDOUBLE)x);
160:                 }
161:                 __FDLMATH_INLINE float tanf(float x)
162:                 {
163:                     return (float)_tanx((__FDLMATH_XDOUBLE)x);
164:                 }
165:                 __FDLMATH_INLINE float tanhf(float x)
166:                 {
167:                     return (float)_tanhx((__FDLMATH_XDOUBLE)x);
168:                 }
169:                 
170:                 /* "l" DP routines are adaptors to "x" DP code */
171:                 __FDLMATH_INLINE long double acosl(long double x)
172:                 {
173:                     return (long double)_acosx((__FDLMATH_XDOUBLE)x);
174:                 }
175:                 __FDLMATH_INLINE long double asinl(long double x)
176:                 {
177:                     return (long double)_asinx((__FDLMATH_XDOUBLE)x);
178:                 }
179:                 __FDLMATH_INLINE long double atanl(long double x)
180:                 {
181:                     return (long double)_atanx((__FDLMATH_XDOUBLE)x);
182:                 }
183:                 __FDLMATH_INLINE long double atan2l(long double y, long double x)
184:                 {
185:                     return (long double)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
186:                 }
187:                 __FDLMATH_INLINE long double ceill(long double x)
188:                 {
189:                     return (long double)_ceilx((__FDLMATH_XDOUBLE)x);
190:                 }
191:                 __FDLMATH_INLINE long double cosl(long double x)
192:                 {
193:                     return (long double)_cosx((__FDLMATH_XDOUBLE)x);
194:                 }
195:                 __FDLMATH_INLINE long double coshl(long double x)
196:                 {
197:                     return (long double)_coshx((__FDLMATH_XDOUBLE)x);
198:                 }
199:                 __FDLMATH_INLINE long double expl(long double x)
200:                 {
201:                     return (long double)_expx((__FDLMATH_XDOUBLE)x);
202:                 }
203:                 __FDLMATH_INLINE long double fabsl(long double x)
204:                 {
205:                     return (long double)_fabsx((__FDLMATH_XDOUBLE)x);
206:                 }
207:                 __FDLMATH_INLINE long double floorl(long double x)
208:                 {
209:                     return (long double)_floorx((__FDLMATH_XDOUBLE)x);
210:                 }
211:                 __FDLMATH_INLINE long double fmodl(long double x, long double y)
212:                 {
213:                     return (long double)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
214:                 }
215:                 __FDLMATH_INLINE long double frexpl(long double x, int *pexp)
216:                 {
217:                     return (long double)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
218:                 }
219:                 __FDLMATH_INLINE long double ldexpl(long double x, int exp)
220:                 {
221:                     return (long double)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
222:                 }
223:                 __FDLMATH_INLINE long double logl(long double x)
224:                 {
225:                     return (long double)_logx((__FDLMATH_XDOUBLE)x);
226:                 }
227:                 __FDLMATH_INLINE long double log10l(long double x)
228:                 {
229:                     return (long double)_log10x((__FDLMATH_XDOUBLE)x);
230:                 }
231:                 __FDLMATH_INLINE long double modfl(long double x, long double *pint)
232:                 {
233:                     __FDLMATH_XDOUBLE dpint;
234:                     long double r;
235:                 
236:                     r = (long double)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
237:                     *pint = (long double)dpint;
238:                 
239:                     return r;
240:                 }
241:                 __FDLMATH_INLINE long double powl(long double x, long double y)
242:                 {
243:                     return (long double)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
244:                 }
245:                 __FDLMATH_INLINE long double sinl(long double x)
246:                 {
247:                     return (long double)_sinx((__FDLMATH_XDOUBLE)x);
248:                 }
249:                 __FDLMATH_INLINE long double sinhl(long double x)
250:                 {
251:                     return (long double)_sinhx((__FDLMATH_XDOUBLE)x);
252:                 }
253:                 __FDLMATH_INLINE long double sqrtl(long double x)
254:                 {
255:                     return (long double)_sqrtx((__FDLMATH_XDOUBLE)x);
256:                 }
257:                 __FDLMATH_INLINE long double tanl(long double x)
258:                 {
259:                     return (long double)_tanx((__FDLMATH_XDOUBLE)x);
260:                 }
261:                 __FDLMATH_INLINE long double tanhl(long double x)
262:                 {
263:                     return (long double)_tanhx((__FDLMATH_XDOUBLE)x);
264:                 }
265:                 
266:                 /* "" double routines are adaptors to x DP code */
267:                 __FDLMATH_INLINE double acos(double x)
268:                 {
269:                     return (double)_acosx((__FDLMATH_XDOUBLE)x);
270:                 }
271:                 __FDLMATH_INLINE double asin(double x)
272:                 {
273:                     return (double)_asinx((__FDLMATH_XDOUBLE)x);
274:                 }
275:                 __FDLMATH_INLINE double atan(double x)
276:                 {
277:                     return (double)_atanx((__FDLMATH_XDOUBLE)x);
9D006A9C  0F40139A   JAL _atanx
9D006AC0  0F40139A   JAL _atanx
278:                 }
279:                 __FDLMATH_INLINE double atan2(double y, double x)
280:                 {
281:                     return (double)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
00000040  00000000   NOP
282:                 }
283:                 __FDLMATH_INLINE double ceil(double x)
284:                 {
285:                     return (double)_ceilx((__FDLMATH_XDOUBLE)x);
286:                 }
287:                 __FDLMATH_INLINE double cos(double x)
288:                 {
289:                     return (double)_cosx((__FDLMATH_XDOUBLE)x);
290:                 }
291:                 __FDLMATH_INLINE double cosh(double x)
292:                 {
293:                     return (double)_coshx((__FDLMATH_XDOUBLE)x);
294:                 }
295:                 __FDLMATH_INLINE double exp(double x)
296:                 {
297:                     return (double)_expx((__FDLMATH_XDOUBLE)x);
298:                 }
299:                 __FDLMATH_INLINE double fabs(double x)
300:                 {
301:                     return (double)_fabsx((__FDLMATH_XDOUBLE)x);
302:                 }
303:                 __FDLMATH_INLINE double floor(double x)
304:                 {
305:                     return (double)_floorx((__FDLMATH_XDOUBLE)x);
306:                 }
307:                 __FDLMATH_INLINE double fmod(double x, double y)
308:                 {
309:                     return (double)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
310:                 }
311:                 __FDLMATH_INLINE double frexp(double x, int *pexp)
312:                 {
313:                     return (double)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
314:                 }
315:                 __FDLMATH_INLINE double ldexp(double x, int exp)
316:                 {
317:                     return (double)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
318:                 }
319:                 __FDLMATH_INLINE double log(double x)
320:                 {
321:                     return (double)_logx((__FDLMATH_XDOUBLE)x);
322:                 }
323:                 __FDLMATH_INLINE double log10(double x)
324:                 {
325:                     return (double)_log10x((__FDLMATH_XDOUBLE)x);
326:                 }
327:                 __FDLMATH_INLINE double modf(double x, double *pint)
328:                 {
329:                     __FDLMATH_XDOUBLE dpint;
330:                     double r;
331:                 
332:                     r = (double)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
333:                     *pint = (double)dpint;
334:                 
335:                     return r;
336:                 }
337:                 __FDLMATH_INLINE double pow(double x, double y)
338:                 {
339:                     return (double)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
9D0069E4  3C029D01   LUI V0, -25343
9D0069E8  D456BDC8   LDC1 F22, -16952(V0)
9D006AE0  4600A321   CVT.D.S F12, F20
9D006AE4  0F40143B   JAL _powx
9D006AE8  4620B386   MOV.D F14, F22
9D006AEC  46200506   MOV.D F20, F0
9D006AF0  4600C321   CVT.D.S F12, F24
9D006AF4  0F40143B   JAL _powx
9D006AF8  4620B386   MOV.D F14, F22
9D006AFC  4620A520   CVT.S.D F20, F20
9D006B00  46200020   CVT.S.D F0, F0
340:                 }
341:                 __FDLMATH_INLINE double sin(double x)
342:                 {
343:                     return (double)_sinx((__FDLMATH_XDOUBLE)x);
344:                 }
345:                 __FDLMATH_INLINE double sinh(double x)
346:                 {
347:                     return (double)_sinhx((__FDLMATH_XDOUBLE)x);
348:                 }
349:                 __FDLMATH_INLINE double sqrt(double x)
350:                 {
351:                     return (double)_sqrtx((__FDLMATH_XDOUBLE)x);
9D006B08  0F4032E3   JAL _sqrtx
9D00BF68  0F4032E3   JAL _sqrtx
00000034  00000000   NOP
352:                 }
353:                 __FDLMATH_INLINE double tan(double x)
354:                 {
355:                     return (double)_tanx((__FDLMATH_XDOUBLE)x);
356:                 }
357:                 __FDLMATH_INLINE double tanh(double x)
358:                 {
359:                     return (double)_tanhx((__FDLMATH_XDOUBLE)x);
360:                 }
361:                 
362:                 #undef __FDLMATH_XDOUBLE
363:                 #undef __FDLMATH_INLINE
364:                 
365:                 #endif /* __FDLMATH_H */
---  c:/microchip/harmony/v2_05_01/framework/system/int/src/sys_int_pic32.c  ----------------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
9D00CB54  27BDFFF8   ADDIU SP, SP, -8
9D00CB58  AFBF0004   SW RA, 4(SP)
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D00CB5C  41626000   DI V0
9D00CB60  000000C0   EHB
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
9D00CB64  8FBF0004   LW RA, 4(SP)
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
9D00CB70  27BDFFF8   ADDIU SP, SP, -8
9D00CB74  AFBF0004   SW RA, 4(SP)
137:                     __builtin_mtc0(12, 0, processorStatus);
9D00CB78  40846000   MTC0 A0, Status
9D00CB7C  000000C0   EHB
138:                 }
9D00CB80  8FBF0004   LW RA, 4(SP)
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
00000000  00000000   NOP
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
00000008  00000000   NOP
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
00000010  00000000   NOP
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
9D00BF80  27BDFFF8   ADDIU SP, SP, -8
9D00BF84  AFBF0004   SW RA, 4(SP)
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D00BF88  41656000   DI A1
9D00BF8C  000000C0   EHB
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     __builtin_mtc0(12, 0, processorStatus);
9D00BFB8  40856000   MTC0 A1, Status
9D00BFBC  000000C0   EHB
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
9D00BFC4  30420001   ANDI V0, V0, 1
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
00000000  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_wakeonstart_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_WakeOnStart_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WakeOnStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsWakeOnStart
16:                          PLIB_USART_WakeOnStartEnable
17:                          PLIB_USART_WakeOnStartDisable
18:                          PLIB_USART_WakeOnStartIsEnabled
19:                          PLIB_USART_InitializeModeGeneral
20:                          PLIB_USART_ErrorsGet
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _USART_WAKEONSTART_DEFAULT_H
51:                  #define _USART_WAKEONSTART_DEFAULT_H
52:                  
53:                  #include "usart_registers.h"
54:                  
55:                  //******************************************************************************
56:                  /* Function :  USART_ExistsWakeOnStart_Default
57:                  
58:                    Summary:
59:                      Implements Default variant of PLIB_USART_ExistsWakeOnStart
60:                  
61:                    Description:
62:                      This template implements the Default variant of the PLIB_USART_ExistsWakeOnStart function.
63:                  */
64:                  
65:                  #define PLIB_USART_ExistsWakeOnStart PLIB_USART_ExistsWakeOnStart
66:                  PLIB_TEMPLATE bool USART_ExistsWakeOnStart_Default( USART_MODULE_ID index )
67:                  {
68:                      return true;
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USART_WakeOnStartEnable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_USART_WakeOnStartEnable
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_USART_WakeOnStartEnable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USART_WakeOnStartEnable_Default( USART_MODULE_ID index )
83:                  {
84:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
85:                      usart->UxMODESET = UxMODE_WAKE_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_WakeOnStartDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USART_WakeOnStartDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USART_WakeOnStartDisable function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void USART_WakeOnStartDisable_Default( USART_MODULE_ID index )
100:                 {
101:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
102:                     usart->UxMODECLR = UxMODE_WAKE_MASK;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  USART_WakeOnStartIsEnabled_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_USART_WakeOnStartIsEnabled
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_USART_WakeOnStartIsEnabled function.
114:                 */
115:                 
116:                 PLIB_TEMPLATE bool USART_WakeOnStartIsEnabled_Default( USART_MODULE_ID index )
117:                 {
118:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
119:                     return (bool)usart->UxMODE.WAKE;
120:                 }
121:                 
122:                 
123:                 //******************************************************************************
124:                 /* Function :  USART_InitializeModeGeneral_Default
125:                 
126:                   Summary:
127:                     Implements Default variant of PLIB_USART_InitializeModeGeneral
128:                 
129:                   Description:
130:                     This template implements the Default variant of the PLIB_USART_InitializeModeGeneral function.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void USART_InitializeModeGeneral_Default( USART_MODULE_ID index, bool autobaud, bool loopBackMode, bool wakeFromSleep, bool irdaMode, bool stopInIdle )
134:                 {
135:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
136:                     usart->UxMODE.ABAUD = autobaud;
9D008750  94830000   LHU V1, 0(A0)
9D008754  7D232944   INS V1, T1, 5, 1
9D008758  A4830000   SH V1, 0(A0)
137:                     usart->UxMODE.LPBACK = loopBackMode;
9D00875C  94830000   LHU V1, 0(A0)
9D008760  7D033184   INS V1, T0, 6, 1
9D008764  A4830000   SH V1, 0(A0)
138:                     usart->UxMODE.WAKE = wakeFromSleep;
9D008768  94830000   LHU V1, 0(A0)
9D00876C  7C4339C4   INS V1, V0, 7, 1
9D008770  A4830000   SH V1, 0(A0)
139:                     usart->UxMODE.SIDL = stopInIdle;
9D008774  94820000   LHU V0, 0(A0)
9D008778  7CC26B44   INS V0, A2, 13, 1
9D00877C  A4820000   SH V0, 0(A0)
140:                     usart->UxMODE.IREN = irdaMode;
9D008780  94820000   LHU V0, 0(A0)
9D008784  7CE26304   INS V0, A3, 12, 1
9D008788  A4820000   SH V0, 0(A0)
141:                 }
142:                 
143:                 //******************************************************************************
144:                 /* Function :  USART_ErrorsGet_Default
145:                 
146:                   Summary:
147:                     Implements Default variant of PLIB_USART_ErrorsGet
148:                 
149:                   Description:
150:                     This template implements the Default variant of the PLIB_USART_ErrorsGet function.
151:                 */
152:                 
153:                 PLIB_TEMPLATE USART_ERROR USART_ErrorsGet_Default( USART_MODULE_ID index)
154:                 {
155:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D00AFB0  8C820000   LW V0, 0(A0)
9D00AFCC  0B402BFC   J .LVL261, .LBB484, .LBB485, .LBB486
9D00AFD0  8C830000   LW V1, 0(A0)
9D00AFF0  24020009   ADDIU V0, ZERO, 9
0000003C  00000000   NOP
156:                     return (USART_ERROR)((usart->UxSTA.w & 0xE) >> 1u);
9D00AFB4  8C430010   LW V1, 16(V0)
9D00AFF4  8C650010   LW A1, 16(V1)
9D00AFF8  7CA51040   EXT A1, A1, 1, 3
00000040  00000000   NOP
157:                 }
158:                 
159:                 #endif /*_USART_WAKEONSTART_DEFAULT_H*/
160:                 
161:                 /******************************************************************************
162:                  End of File
163:                 */
164:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_transmitterempty_default.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterEmpty_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterEmpty
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_TransmitterIsEmpty
16:                          PLIB_USART_ExistsTransmitterEmptyStatus
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTEREMPTY_DEFAULT_H
47:                  #define _USART_TRANSMITTEREMPTY_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_TransmitterIsEmpty_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_TransmitterIsEmpty 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_TransmitterIsEmpty function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool USART_TransmitterIsEmpty_Default( USART_MODULE_ID index )
62:                  {
63:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
64:                      return (bool)usart->UxSTA.TRMT;
9D00B980  8C620010   LW V0, 16(V1)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsTransmitterEmptyStatus_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsTransmitterEmptyStatus
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterEmptyStatus function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsTransmitterEmptyStatus PLIB_USART_ExistsTransmitterEmptyStatus
79:                  PLIB_TEMPLATE bool USART_ExistsTransmitterEmptyStatus_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_TRANSMITTEREMPTY_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_transmitterbufferfull_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterBufferFull_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterBufferFull
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitterBufferFullStatus
16:                          PLIB_USART_TransmitterBufferIsFull
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
47:                  #define _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitterBufferFullStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsTransmitterBufferFullStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterBufferFullStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitterBufferFullStatus PLIB_USART_ExistsTransmitterBufferFullStatus
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitterBufferFullStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_TransmitterBufferIsFull_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_TransmitterBufferIsFull 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_TransmitterBufferIsFull function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_TransmitterBufferIsFull_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
0000001C  00000000   NOP
81:                      return (bool)usart->UxSTA.UTXBF;
9D00B994  8C630010   LW V1, 16(V1)
00000020  00000000   NOP
00000108  00000000   NOP
0000017C  00000000   NOP
000001C0  00000000   NOP
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_TRANSMITTERBUFFERFULL_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_transmitter_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter
16:                          PLIB_USART_TransmitterByteSend
17:                          PLIB_USART_TransmitterAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_TRANSMITTER_DEFAULT_H
48:                  #define _USART_TRANSMITTER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsTransmitter_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsTransmitter
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitter function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsTransmitter PLIB_USART_ExistsTransmitter
63:                  PLIB_TEMPLATE bool USART_ExistsTransmitter_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_TransmitterByteSend_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_TransmitterByteSend
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_TransmitterByteSend function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_TransmitterByteSend_Default( USART_MODULE_ID index , int8_t data )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D0001BC  8C430000   LW V1, 0(V0)
82:                      usart->UxTXREG = data;
9D0001C0  7C108420   SEB S0, S0
000001AC  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_TransmitterAddressGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_TransmitterAddressGet
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_TransmitterAddressGet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void* USART_TransmitterAddressGet_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
99:                      return (uint32_t*)(&usart->UxTXREG);
100:                 }
101:                 
102:                 #endif /*_USART_TRANSMITTER_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_transmitter9bits_indataonly.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter9Bits_InDataOnly.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter9Bits
13:                      and its Variant : InDataOnly
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter9BitsSend
16:                          PLIB_USART_Transmitter9BitsSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTER9BITS_INDATAONLY_H
47:                  #define _USART_TRANSMITTER9BITS_INDATAONLY_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitter9BitsSend_InDataOnly
53:                  
54:                    Summary:
55:                      Implements InDataOnly variant of PLIB_USART_ExistsTransmitter9BitsSend
56:                  
57:                    Description:
58:                      This template implements the InDataOnly variant of the PLIB_USART_ExistsTransmitter9BitsSend function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitter9BitsSend PLIB_USART_ExistsTransmitter9BitsSend
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitter9BitsSend_InDataOnly( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_Transmitter9BitsSend_InDataOnly
70:                  
71:                    Summary:
72:                      Implements InDataOnly variant of PLIB_USART_Transmitter9BitsSend
73:                  
74:                    Description:
75:                      This template implements the InDataOnly variant of the PLIB_USART_Transmitter9BitsSend function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_Transmitter9BitsSend_InDataOnly( USART_MODULE_ID index , int8_t data , bool bit9th )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                      uint32_t temp;
82:                  
83:                      temp = (uint32_t)data;
00000154  00000000   NOP
84:                      
85:                      if (false == bit9th)
86:                      {
87:                          /* Clear 9th and higher bits */
88:                          temp = ( temp & 0x00FF );
00000168  00000000   NOP
89:                      }
90:                      else
91:                      {
92:                          /* Set 9th bit. */
93:                          temp = ( temp | 0x0100 );
00000158  00000000   NOP
94:                      }
95:                      
96:                      usart->UxTXREG = temp;
0000015C  00000000   NOP
0000016C  00000000   NOP
97:                  }
98:                  
99:                  
100:                 #endif /*_USART_TRANSMITTER9BITS_INDATAONLY_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiveroverrunerror_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverOverrunError_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverrunError
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverOverrunStatus
16:                          PLIB_USART_ReceiverOverrunErrorClear
17:                          PLIB_USART_ReceiverOverrunHasOccurred
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVEROVERRUNERROR_DEFAULT_H
48:                  #define _USART_RECEIVEROVERRUNERROR_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverOverrunStatus_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverOverrunStatus
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverOverrunStatus function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverOverrunStatus PLIB_USART_ExistsReceiverOverrunStatus
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverOverrunStatus_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverOverrunErrorClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverOverrunErrorClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunErrorClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverOverrunErrorClear_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      usart->UxSTACLR = UxSTA_OERR_MASK;
9D00AFC4  24030002   ADDIU V1, ZERO, 2
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_ReceiverOverrunHasOccurred_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_ReceiverOverrunHasOccurred 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunHasOccurred function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USART_ReceiverOverrunHasOccurred_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
99:                      return (bool)usart->UxSTA.OERR;
100:                 }
101:                 
102:                 
103:                 #endif /*_USART_RECEIVEROVERRUNERROR_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiverinterruptmode_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverInterruptMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverInterruptMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverInterruptMode
16:                          PLIB_USART_ReceiverInterruptModeSelect
17:                          PLIB_USART_InitializeOperation
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
48:                  #define _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverInterruptMode_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverInterruptMode
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverInterruptMode function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverInterruptMode PLIB_USART_ExistsReceiverInterruptMode
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverInterruptMode_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverInterruptModeSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverInterruptModeSelect 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverInterruptModeSelect function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverInterruptModeSelect_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE interruptMode )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_URXISEL_MASK;
87:                      usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)interruptMode << UxSTA_URXISEL_POSITION) );
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_InitializeOperation_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_InitializeOperation 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_InitializeOperation function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_InitializeOperation_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE receiveInterruptMode ,
102:                         USART_TRANSMIT_INTR_MODE transmitInterruptMode, USART_OPERATION_MODE operationMode)
103:                 {
104:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
105:                 
106:                     /* Clear and Set, as UxSTA contains status bits and 
107:                        hence need to be accessed atomically.
108:                        Using bit field access may erroneously cause status bits to get cleared */
109:                     usart->UxSTACLR = UxSTA_URXISEL_MASK;
9D0087C0  240200C0   ADDIU V0, ZERO, 192
9D0087C4  AC820014   SW V0, 20(A0)
110:                     usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)receiveInterruptMode << UxSTA_URXISEL_POSITION) );
9D0087C8  AC800018   SW ZERO, 24(A0)
111:                 
112:                     /* Clear and Set, as UxSTA contains status bits and 
113:                        hence need to be accessed atomically.
114:                        Using bit field access may erroneously cause status bits to get cleared */
115:                     usart->UxSTACLR = UxSTA_UTXISEL_MASK;
9D0087CC  3402C000   ORI V0, ZERO, -16384
9D0087D0  AC820014   SW V0, 20(A0)
116:                     usart->UxSTASET = ( UxSTA_UTXISEL_MASK & ((uint32_t)transmitInterruptMode << UxSTA_UTXISEL_POSITION) );
9D0087D4  24024000   ADDIU V0, ZERO, 16384
9D0087D8  AC820018   SW V0, 24(A0)
117:                 
118:                     /* Select the operation mode */
119:                     usart->UxMODE.UEN = operationMode;
9D0087DC  94820000   LHU V0, 0(A0)
9D0087E0  7C624A04   INS V0, V1, 8, 2
9D0087E4  A4820000   SH V0, 0(A0)
120:                 
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_RECEIVERINTERRUPTMODE_DEFAULT_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiverdataavailable_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverDataAvailable_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverDataAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverDataAvailableStatus
16:                          PLIB_USART_ReceiverDataIsAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
47:                  #define _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsReceiverDataAvailableStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsReceiverDataAvailableStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverDataAvailableStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsReceiverDataAvailableStatus PLIB_USART_ExistsReceiverDataAvailableStatus
62:                  PLIB_TEMPLATE bool USART_ExistsReceiverDataAvailableStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ReceiverDataIsAvailable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ReceiverDataIsAvailable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ReceiverDataIsAvailable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_ReceiverDataIsAvailable_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D00B964  8C430000   LW V1, 0(V0)
0000001C  00000000   NOP
00000038  00000000   NOP
81:                     return (usart->UxSTA.URXDA);
9D00B968  8C640010   LW A0, 16(V1)
00000020  00000000   NOP
0000003C  00000000   NOP
0000007C  00000000   NOP
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_RECEIVERDATAAVAILABLE_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiveraddressdetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressDetect
16:                          PLIB_USART_ReceiverAddressDetectEnable
17:                          PLIB_USART_ReceiverAddressDetectDisable
18:                          PLIB_USART_ReceiverAddressIsReceived
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_RECEIVERADDRESSDETECT_DEFAULT_H
49:                  #define _USART_RECEIVERADDRESSDETECT_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsReceiverAddressDetect_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressDetect
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressDetect function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsReceiverAddressDetect PLIB_USART_ExistsReceiverAddressDetect
64:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressDetect_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_ReceiverAddressDetectEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectEnable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
83:                      usart->UxSTASET = UxSTA_ADDEN_MASK;
9D0086D4  24020020   ADDIU V0, ZERO, 32
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_ReceiverAddressDetectDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectDisable
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectDisable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
100:                     usart->UxSTACLR = UxSTA_ADDEN_MASK;
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_ReceiverAddressIsReceived_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_ReceiverAddressIsReceived
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressIsReceived function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE bool USART_ReceiverAddressIsReceived_Default( USART_MODULE_ID index )
115:                 {
116:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
117:                     return (bool)usart->UxSTA.ADDEN;
118:                 }
119:                 
120:                 
121:                 #endif /*_USART_RECEIVERADDRESSDETECT_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiveraddressautodetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressAutoDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressAutoDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressAutoDetect
16:                          PLIB_USART_ReceiverAddressAutoDetectEnable
17:                          PLIB_USART_ReceiverAddressAutoDetectDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddressAutoDetect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressAutoDetect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressAutoDetect function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddressAutoDetect PLIB_USART_ExistsReceiverAddressAutoDetect
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressAutoDetect_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverAddressAutoDetectEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectEnable_Default( USART_MODULE_ID index , int8_t mask )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D0086F8  AC820014   SW V0, 20(A0)
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)mask) << UxSTA_ADDR_POSITION) ) | (UxSTA_ADM_EN_MASK);
9D0086FC  7C031C20   SEB V1, V1
9D008700  00031C00   SLL V1, V1, 16
9D008704  00621024   AND V0, V1, V0
9D008708  3C030100   LUI V1, 256
9D00870C  00431025   OR V0, V0, V1
9D008710  AC820018   SW V0, 24(A0)
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_ReceiverAddressAutoDetectDisable_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectDisable 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectDisable function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectDisable_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     usart->UxSTACLR = UxSTA_ADM_EN_MASK;
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiveraddress_default.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddress_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddress
16:                          PLIB_USART_AddressSet
17:                          PLIB_USART_AddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESS_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESS_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddress_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddress
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddress function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddress PLIB_USART_ExistsReceiverAddress
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddress_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_AddressSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_AddressSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_AddressSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_AddressSet_Default( USART_MODULE_ID index , uint8_t address )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D0086E0  3C0200FF   LUI V0, 255
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)address) << UxSTA_ADDR_POSITION) );
9D0086E8  00031C00   SLL V1, V1, 16
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_AddressGet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_AddressGet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_AddressGet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE uint8_t USART_AddressGet_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     return (uint8_t)usart->UxSTA.ADDR;
9D0086F4  90830012   LBU V1, 18(A0)
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESS_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_receiver_default.h  -------
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Receiver_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Receiver
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiver
16:                          PLIB_USART_ReceiverByteReceive
17:                          PLIB_USART_ReceiverAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVER_DEFAULT_H
48:                  #define _USART_RECEIVER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiver_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiver
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiver function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiver PLIB_USART_ExistsReceiver
63:                  PLIB_TEMPLATE bool USART_ExistsReceiver_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverByteReceive_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverByteReceive
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverByteReceive function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE int8_t USART_ReceiverByteReceive_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D00C054  8C620000   LW V0, 0(V1)
82:                      return (int8_t)usart->UxRXREG;
9D00AFD4  8C650030   LW A1, 48(V1)
9D00C058  8C420030   LW V0, 48(V0)
00000060  00000000   NOP
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverAddressGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverAddressGet
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void* USART_ReceiverAddressGet_Default( USART_MODULE_ID index )
96:                  {
97:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
98:                      return (uint32_t*)(&usart->UxRXREG);
99:                  }
100:                 
101:                 #endif /*_USART_RECEIVER_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_linecontrolmode_rxandtxcombined.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_LineControlMode_RXandTXCombined.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LineControlMode
13:                      and its Variant : RXandTXCombined
14:                      For following APIs :
15:                          PLIB_USART_ExistsLineControlMode
16:                          PLIB_USART_LineControlModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
47:                  #define _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsLineControlMode_RXandTXCombined
53:                  
54:                    Summary:
55:                      Implements RXandTXCombined variant of PLIB_USART_ExistsLineControlMode
56:                  
57:                    Description:
58:                      This template implements the RXandTXCombined variant of the PLIB_USART_ExistsLineControlMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsLineControlMode PLIB_USART_ExistsLineControlMode
62:                  PLIB_TEMPLATE bool USART_ExistsLineControlMode_RXandTXCombined( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_LineControlModeSelect_RXandTXCombined
70:                  
71:                    Summary:
72:                      Implements RXandTXCombined variant of PLIB_USART_LineControlModeSelect 
73:                  
74:                    Description:
75:                      This template implements the RXandTXCombined variant of the PLIB_USART_LineControlModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_LineControlModeSelect_RXandTXCombined( USART_MODULE_ID index , USART_LINECONTROL_MODE dataFlowConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      if (dataFlowConfig > USART_9N1)
9D008790  2C430004   SLTIU V1, V0, 4
9D008794  14600004   BNE V1, ZERO, .LVL62, .LBB358
9D008798  24030001   ADDIU V1, ZERO, 1
00000030  00000000   NOP
83:                      {
84:                          usart->UxMODESET = UxMODE_STSEL_MASK;
9D00879C  AC830008   SW V1, 8(A0)
0000003C  00000000   NOP
85:                          dataFlowConfig = (USART_LINECONTROL_MODE)(dataFlowConfig - USART_8N2);
9D0087A0  0B4021EC   J .LVL63
9D0087A4  2443FFFC   ADDIU V1, V0, -4
00000044  00000000   NOP
86:                      }
87:                      else
88:                      {
89:                          usart->UxMODECLR = UxMODE_STSEL_MASK;
9D0087A8  AC830004   SW V1, 4(A0)
9D0087AC  00401821   ADDU V1, V0, ZERO
0000004C  00000000   NOP
90:                      }
91:                      usart->UxMODE.PDSEL = dataFlowConfig;
9D0087B0  94820000   LHU V0, 0(A0)
9D0087B4  7C621044   INS V0, V1, 1, 2
9D0087B8  A4820000   SH V0, 0(A0)
00000054  00000000   NOP
92:                  }
93:                  
94:                  
95:                  #endif /*_USART_LINECONTROLMODE_RXANDTXCOMBINED_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_handshakemode_default.h  --
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_HandShakeMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HandShakeMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsHandshakeMode
16:                          PLIB_USART_HandshakeModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_HANDSHAKEMODE_DEFAULT_H
47:                  #define _USART_HANDSHAKEMODE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsHandshakeMode_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsHandshakeMode
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsHandshakeMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsHandshakeMode PLIB_USART_ExistsHandshakeMode
62:                  PLIB_TEMPLATE bool USART_ExistsHandshakeMode_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_HandshakeModeSelect_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_HandshakeModeSelect 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_HandshakeModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_HandshakeModeSelect_Default( USART_MODULE_ID index , USART_HANDSHAKE_MODE handshakeConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      usart->UxMODE.RTSMD = handshakeConfig;
9D008738  94860000   LHU A2, 0(A0)
9D00873C  7C665AC4   INS A2, V1, 11, 1
9D008740  A4860000   SH A2, 0(A0)
83:                  }
84:                  
85:                  
86:                  #endif /*_USART_HANDSHAKEMODE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_enablecontrol_default.h  --
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsEnable
16:                          PLIB_USART_Disable
17:                          PLIB_USART_Enable
18:                          PLIB_USART_BaudSetAndEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_ENABLECONTROL_DEFAULT_H
49:                  #define _USART_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsEnable
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsEnable function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsEnable PLIB_USART_ExistsEnable
64:                  PLIB_TEMPLATE bool USART_ExistsEnable_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_Disable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_Disable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_Disable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D008534  8CA20004   LW V0, 4(A1)
0000005C  00000000   NOP
83:                      usart->UxMODECLR = UxMODE_ON_MASK;
9D008538  34038000   ORI V1, ZERO, -32768
00000060  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_Enable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_Enable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_Enable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_Enable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D008680  8E220004   LW V0, 4(S1)
100:                     usart->UxMODESET = UxMODE_ON_MASK;
9D008684  34038000   ORI V1, ZERO, -32768
9D008688  AC430008   SW V1, 8(V0)
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USART_BaudSetAndEnable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USART_BaudSetAndEnable 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USART_BaudSetAndEnable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USART_BaudSetAndEnable_Default( USART_MODULE_ID index, uint32_t systemClock, uint32_t baud  )
114:                 {
115:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
116:                     uint32_t brgValueLow = 0;
117:                     uint32_t brgValueHigh = 0;
118:                 
119:                     /* Enable transmit and receive */
120:                     usart->UxSTASET = (UxSTA_UTXEN_MASK | UxSTA_URXEN_MASK);
9D0087F0  24031400   ADDIU V1, ZERO, 5120
9D0087F4  AC830018   SW V1, 24(A0)
121:                 
122:                     /* Find the BRG Value */
123:                     brgValueLow  = ( ((systemClock >> 4u) + (baud >> 1u)) / baud ) - 1u;
9D0087F8  00022842   SRL A1, V0, 1
9D00883C  00063102   SRL A2, A2, 4
9D008840  00A62821   ADDU A1, A1, A2
9D008844  00A2001B   DIVU A1, V0
9D008848  004001F4   TEQ V0, ZERO
9D00884C  00002812   MFLO A1
9D008850  24A5FFFF   ADDIU A1, A1, -1
124:                     brgValueHigh = ( ((systemClock >> 2u) + (baud >> 1u)) / baud ) - 1u;
9D0087FC  00061882   SRL V1, A2, 2
9D008800  00651821   ADDU V1, V1, A1
9D008804  0062001B   DIVU V1, V0
9D008808  004001F4   TEQ V0, ZERO
9D00880C  00001812   MFLO V1
9D008810  2463FFFF   ADDIU V1, V1, -1
125:                 
126:                     /* Check if the baud value can be set with high baud settings */
127:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
9D008814  3C070001   LUI A3, 1
9D008818  0067382B   SLTU A3, V1, A3
9D00881C  50E00006   BEQL A3, ZERO, .LVL73, .LBB367
9D008820  24030008   ADDIU V1, ZERO, 8
128:                     {
129:                         /* Set BRGH */
130:                         usart->UxMODESET = UxMODE_BRGH_MASK;
9D008824  24020008   ADDIU V0, ZERO, 8
9D008828  AC820008   SW V0, 8(A0)
131:                         usart->UxBRG = brgValueHigh;
9D00882C  AC830040   SW V1, 64(A0)
132:                     }
133:                     else
134:                     {
135:                         /* Clear BRGH */
136:                         usart->UxMODECLR = UxMODE_BRGH_MASK;
9D008838  AC830004   SW V1, 4(A0)
137:                         usart->UxBRG = brgValueLow;
9D008854  AC850040   SW A1, 64(A0)
138:                     }
139:                 
140:                     /* Enable the UART */
141:                     usart->UxMODESET = UxMODE_ON_MASK;
9D008830  0B402217   J 0x9D00885C
9D008834  34028000   ORI V0, ZERO, -32768
9D008858  34028000   ORI V0, ZERO, -32768
142:                 }
143:                 
144:                 #endif /*_USART_ENABLECONTROL_DEFAULT_H*/
145:                 
146:                 /******************************************************************************
147:                  End of File
148:                 */
149:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_baudratehigh_in16bitregister.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRateHigh_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRateHigh
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRateHigh
16:                          PLIB_USART_BaudRateHighSet
17:                          PLIB_USART_BaudRateHighDisable
18:                          PLIB_USART_BaudRateHighEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_BAUDRATEHIGH_IN16BITREGISTER_H
49:                  #define _USART_BAUDRATEHIGH_IN16BITREGISTER_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsBaudRateHigh_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRateHigh
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRateHigh function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsBaudRateHigh PLIB_USART_ExistsBaudRateHigh
64:                  PLIB_TEMPLATE bool USART_ExistsBaudRateHigh_In16BitRegister( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_BaudRateHighSet_In16BitRegister
72:                  
73:                    Summary:
74:                      Implements In16BitRegister variant of PLIB_USART_BaudRateHighSet 
75:                  
76:                    Description:
77:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_BaudRateHighSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
83:                      uint32_t brg = 0;
84:                      
85:                      brg = ( ((clockFrequency >> 2) + (baudRate >> 1)) / baudRate ) - 1; 
00000064  00000000   NOP
86:                      usart->UxBRG = brg;
00000084  00000000   NOP
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USART_BaudRateHighDisable_In16BitRegister
92:                  
93:                    Summary:
94:                      Implements In16BitRegister variant of PLIB_USART_BaudRateHighDisable 
95:                  
96:                    Description:
97:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighDisable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void USART_BaudRateHighDisable_In16BitRegister( USART_MODULE_ID index )
101:                 {
102:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
103:                     usart->UxMODECLR = UxMODE_BRGH_MASK;
000000A4  00000000   NOP
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  USART_BaudRateHighEnable_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_USART_BaudRateHighEnable 
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighEnable function.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void USART_BaudRateHighEnable_In16BitRegister( USART_MODULE_ID index )
118:                 {
119:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
120:                     usart->UxMODESET = UxMODE_BRGH_MASK;
0000005C  00000000   NOP
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_BAUDRATEHIGH_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/usart/templates/usart_baudrate_in16bitregister.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRate_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRate
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRate
16:                          PLIB_USART_BaudRateSet
17:                          PLIB_USART_BaudRateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_BAUDRATE_IN16BITREGISTER_H
48:                  #define _USART_BAUDRATE_IN16BITREGISTER_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsBaudRate_In16BitRegister
54:                  
55:                    Summary:
56:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRate
57:                  
58:                    Description:
59:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRate function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsBaudRate PLIB_USART_ExistsBaudRate
63:                  PLIB_TEMPLATE bool USART_ExistsBaudRate_In16BitRegister( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_BaudRateSet_In16BitRegister
71:                  
72:                    Summary:
73:                      Implements In16BitRegister variant of PLIB_USART_BaudRateSet 
74:                  
75:                    Description:
76:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_BaudRateSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      uint32_t brg;
83:                  
84:                      brg = ( ((clockFrequency >> 4) + (baudRate >> 1)) / baudRate ) - 1;
000000AC  00000000   NOP
85:                      usart->UxBRG = brg;
000000CC  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_BaudRateGet_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_USART_BaudRateGet 
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateGet function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint32_t USART_BaudRateGet_In16BitRegister( USART_MODULE_ID index , int32_t clockFrequency )
100:                 {
101:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
102:                     int32_t baudReg;
103:                     bool highEnableStatus;
104:                     uint32_t returnValue;
105:                     
106:                     baudReg = (int32_t)usart->UxBRG;
107:                     highEnableStatus = (bool)usart->UxMODE.BRGH ;
108:                     
109:                     if(highEnableStatus)
110:                     {
111:                         /* This is the formula for high baud rate selection */
112:                         returnValue = (clockFrequency/(4 *(baudReg + 1)));
113:                     }
114:                     else
115:                     {
116:                         /* This is the formula for normal baud rate selection */
117:                         returnValue = (clockFrequency/(16 *(baudReg + 1)));
118:                     }
119:                 
120:                     return returnValue;
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_BAUDRATE_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_stopinidle_default.h  ---------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_StopInIdleEnable
16:                          PLIB_TMR_StopInIdleDisable
17:                          PLIB_TMR_ExistsStopInIdleControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_STOPINIDLE_DEFAULT_H
48:                  #define _TMR_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_StopInIdleEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_StopInIdleEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_StopInIdleEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_StopInIdleEnable_Default( TMR_MODULE_ID index )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                  
67:                      tmr->TxCONSET = TxCON_SIDL_MASK;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_StopInIdleDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_TMR_StopInIdleDisable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_TMR_StopInIdleDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void TMR_StopInIdleDisable_Default( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      tmr->TxCONCLR = TxCON_SIDL_MASK;
00000000  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_ExistsStopInIdleControl_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_TMR_ExistsStopInIdleControl
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_TMR_ExistsStopInIdleControl function.
97:                  */
98:                  
99:                  #define PLIB_TMR_ExistsStopInIdleControl PLIB_TMR_ExistsStopInIdleControl
100:                 PLIB_TEMPLATE bool TMR_ExistsStopInIdleControl_Default( TMR_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_TMR_STOPINIDLE_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_prescale_default.h  -----------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Prescale_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Prescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_PrescaleSelect
16:                          PLIB_TMR_PrescaleGet
17:                          PLIB_TMR_ExistsPrescale
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PRESCALE_DEFAULT_H
48:                  #define _TMR_PRESCALE_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_PrescaleSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_PrescaleSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_PrescaleSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_PrescaleSelect_Default( TMR_MODULE_ID index , TMR_PRESCALE prescale )
63:                  {
64:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
67:                      {
68:                          switch(prescale)
00000044  00000000   NOP
00000068  00000000   NOP
00000084  00000000   NOP
69:                          {
70:                              case TMR_PRESCALE_VALUE_1:  tmr->TxCON.TCKPS = 0;
000000C0  00000000   NOP
71:                                                          break;
72:                              case TMR_PRESCALE_VALUE_8:  tmr->TxCON.TCKPS = 1;
000000D4  00000000   NOP
73:                                                          break;
74:                              case TMR_PRESCALE_VALUE_64: tmr->TxCON.TCKPS = 2;
9D00B878  94430000   LHU V1, 0(V0)
000000F0  00000000   NOP
75:                                                          break;
76:                              case TMR_PRESCALE_VALUE_256: tmr->TxCON.TCKPS = 3;
0000010C  00000000   NOP
77:                                                          break;
78:                              default: PLIB_ASSERT(false, " Given Prescale value is not supported for Timer1");
79:                          }
80:                      }
81:                      else
82:                      {
83:                          tmr->TxCON.TCKPS = prescale;
84:                      }
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  TMR_PrescaleGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_TMR_PrescaleGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_TMR_PrescaleGet function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE uint16_t TMR_PrescaleGet_Default( TMR_MODULE_ID index )
99:                  {
100:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
101:                     uint8_t temp_prescaler;
102:                     uint16_t preScaler;
103:                 
104:                     temp_prescaler = tmr->TxCON.TCKPS;
00000000  00000000   NOP
00000010  00000000   NOP
105:                                           
106:                     if(TMR_ID_1 == index)
107:                     {
108:                         /* 1, 8, 64, 256 */
109:                         switch(temp_prescaler)
0000000C  00000000   NOP
0000001C  00000000   NOP
110:                         {
111:                             case 0x00u: preScaler = 1u;
00000048  00000000   NOP
112:                                         break;
113:                             case 0x01u: preScaler = 8u;
114:                                         break;
115:                             case 0x02u: preScaler = 64u;
116:                                         break;
117:                             case 0x03u: preScaler = 256u;
118:                                         break;
119:                             default:    preScaler = 0u;
00000038  00000000   NOP
120:                         }
121:                     }
122:                     else
123:                     {
124:                         /* 1, 2, 4, 8, 16, 32, 64, 256 */
125:                         if ( temp_prescaler == 7u )
126:                         {
127:                             temp_prescaler++;
128:                         }
129:                         preScaler = (uint16_t)(0x01u << temp_prescaler);
130:                     }
131:                     return preScaler;
132:                 
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  TMR_ExistsPrescale_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_TMR_ExistsPrescale
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_TMR_ExistsPrescale function.
144:                 */
145:                 
146:                 #define PLIB_TMR_ExistsPrescale PLIB_TMR_ExistsPrescale
147:                 PLIB_TEMPLATE bool TMR_ExistsPrescale_Default( TMR_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_TMR_PRESCALE_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_period16bit_default.h  --------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Period16BitSet
16:                          PLIB_TMR_Period16BitGet
17:                          PLIB_TMR_ExistsPeriod16Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD16BIT_Default_H
48:                  #define _TMR_PERIOD16BIT_Default_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Period16BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Period16BitSet
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Period16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Period16BitSet_Default( TMR_MODULE_ID index , uint16_t period )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      tmr->PRx = period;
9D00B88C  240304E2   ADDIU V1, ZERO, 1250
9D00B890  AC430020   SW V1, 32(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  TMR_Period16BitGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_TMR_Period16BitGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_TMR_Period16BitGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t TMR_Period16BitGet_Default( TMR_MODULE_ID index )
81:                  {
82:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
83:                      return (uint16_t)tmr->PRx;
00000000  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  TMR_ExistsPeriod16Bit_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_TMR_ExistsPeriod16Bit
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_TMR_ExistsPeriod16Bit function.
95:                  */
96:                  
97:                  #define PLIB_TMR_ExistsPeriod16Bit PLIB_TMR_ExistsPeriod16Bit
98:                  PLIB_TEMPLATE bool TMR_ExistsPeriod16Bit_Default( TMR_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_TMR_PERIOD16BIT_Default_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_enablecontrol_default.h  ------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Start
16:                          PLIB_TMR_Stop
17:                          PLIB_TMR_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_ENABLECONTROL_DEFAULT_H
48:                  #define _TMR_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Start_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Start 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Start function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Start_Default( TMR_MODULE_ID index )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                  
67:                      tmr->TxCONSET = TxCON_ON_MASK;
9D00C644  34038000   ORI V1, ZERO, -32768
0000013C  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Stop_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_TMR_Stop 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_TMR_Stop function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void TMR_Stop_Default( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      tmr->TxCONCLR = TxCON_ON_MASK;
9D00B860  3C02BF84   LUI V0, -16508
9D00B864  34038000   ORI V1, ZERO, -32768
9D00B868  AC430004   SW V1, 4(V0)
00000018  00000000   NOP
0000001C  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_ExistsEnableControl_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_TMR_ExistsEnableControl
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_TMR_ExistsEnableControl function.
97:                  */
98:                  
99:                  #define PLIB_TMR_ExistsEnableControl PLIB_TMR_ExistsEnableControl
100:                 PLIB_TEMPLATE bool TMR_ExistsEnableControl_Default( TMR_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_TMR_ENABLECONTROL_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_counter16bit_in16bitregister.h  
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter16Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter16Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter16BitSet
16:                          PLIB_TMR_Counter16BitGet
17:                          PLIB_TMR_Counter16BitClear
18:                          PLIB_TMR_ExistsCounter16Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER16BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER16BIT_IN16BITREGISTER_H
50:                  
51:                  #include "tmr_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Counter16BitSet_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitSet
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Counter16BitSet_In16BitRegister( TMR_MODULE_ID index , uint16_t value )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      
67:                      tmr->TMRx = value;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Counter16BitGet_In16BitRegister
73:                  
74:                    Summary:
75:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitGet
76:                  
77:                    Description:
78:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitGet function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE uint16_t TMR_Counter16BitGet_In16BitRegister( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      return (uint16_t)tmr->TMRx;
00000000  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_Counter16BitClear_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitClear
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitClear function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void TMR_Counter16BitClear_In16BitRegister( TMR_MODULE_ID index )
100:                 {
101:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
102:                     
103:                     tmr->TMRx = 0u;
9D00B888  AC400010   SW ZERO, 16(V0)
00000000  00000000   NOP
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  TMR_ExistsCounter16Bit_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter16Bit
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter16Bit function.
115:                 */
116:                 
117:                 #define PLIB_TMR_ExistsCounter16Bit PLIB_TMR_ExistsCounter16Bit
118:                 PLIB_TEMPLATE bool TMR_ExistsCounter16Bit_In16BitRegister( TMR_MODULE_ID index )
119:                 {
120:                     return true;
121:                 }
122:                 
123:                 
124:                 #endif /*_TMR_COUNTER16BIT_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_clocksourcesync_inverted.h  ---
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSourceSync_Inverted.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSourceSync
13:                      and its Variant : Inverted
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceExternalSyncEnable
16:                          PLIB_TMR_ClockSourceExternalSyncDisable
17:                          PLIB_TMR_ExistsClockSourceSync
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_CLOCKSOURCESYNC_INVERTED_H
48:                  #define _TMR_CLOCKSOURCESYNC_INVERTED_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_ClockSourceExternalSyncEnable_Inverted
54:                  
55:                    Summary:
56:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncEnable 
57:                  
58:                    Description:
59:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncEnable_Inverted( TMR_MODULE_ID index )
63:                  {
64:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
65:                  
66:                      /* This feature is present in Timer 1 only */
67:                      if(TMR_ID_1 == index)
68:                      {
69:                          tmr->TxCONSET = TxCON_TSYNC_MASK; 
00000060  00000000   NOP
70:                      }
71:                      else
72:                      {
73:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
74:                      }
75:                  }
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  TMR_ClockSourceExternalSyncDisable_Inverted
80:                  
81:                    Summary:
82:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncDisable 
83:                  
84:                    Description:
85:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncDisable function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncDisable_Inverted( TMR_MODULE_ID index )
89:                  {
90:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
91:                  
92:                      /* This feature is present in Timer 1 only */
93:                      if(TMR_ID_1 == index)
94:                      {
95:                          tmr->TxCONCLR = TxCON_TSYNC_MASK; 
0000007C  00000000   NOP
96:                      }
97:                      else
98:                      {
99:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
100:                     }
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  TMR_ExistsClockSourceSync_Inverted
106:                 
107:                   Summary:
108:                     Implements Inverted variant of PLIB_TMR_ExistsClockSourceSync
109:                 
110:                   Description:
111:                     This template implements the Inverted variant of the PLIB_TMR_ExistsClockSourceSync function.
112:                 */
113:                 
114:                 #define PLIB_TMR_ExistsClockSourceSync PLIB_TMR_ExistsClockSourceSync
115:                 PLIB_TEMPLATE bool TMR_ExistsClockSourceSync_Inverted( TMR_MODULE_ID index )
116:                 {
117:                     if(TMR_ID_1 == index)
118:                     {
119:                         return true; 
120:                     }
121:                     else
122:                     {
123:                         return false;
124:                     } 
125:                 }
126:                 
127:                 
128:                 #endif /*_TMR_CLOCKSOURCESYNC_INVERTED_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/tmr/templates/tmr_clocksource_default.h  --------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSource_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceSelect
16:                          PLIB_TMR_ExistsClockSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_CLOCKSOURCE_DEFAULT_H
47:                  #define _TMR_CLOCKSOURCE_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_ClockSourceSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_ClockSourceSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_ClockSourceSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_ClockSourceSelect_Default( TMR_MODULE_ID index , TMR_CLOCK_SOURCE source )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                  
65:                      tmr->TxCON.TCS = source;
9D00B86C  94430000   LHU V1, 0(V0)
00000034  00000000   NOP
00000054  00000000   NOP
00000070  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_ExistsClockSource_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_TMR_ExistsClockSource
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_TMR_ExistsClockSource function.
77:                  */
78:                  
79:                  #define PLIB_TMR_ExistsClockSource PLIB_TMR_ExistsClockSource
80:                  PLIB_TEMPLATE bool TMR_ExistsClockSource_Default( TMR_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_TMR_CLOCKSOURCE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_remapoutput_pic32_1.h  ----
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapOutput_PIC32_1.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapOutput
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_PORTS_RemapOutput
16:                          PLIB_PORTS_ExistsRemapOutput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPOUTPUT_PIC32_1_H
47:                  #define _PORTS_REMAPOUTPUT_PIC32_1_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapOutput_PIC32_1
52:                  
53:                    Summary:
54:                      Implements PIC32_1 variant of PLIB_PORTS_RemapOutput 
55:                  
56:                    Description:
57:                      This template implements the PIC32_1 variant of the PLIB_PORTS_RemapOutput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapOutput_PIC32_1( PORTS_MODULE_ID      index , PORTS_REMAP_OUTPUT_FUNCTION outputFunction , PORTS_REMAP_OUTPUT_PIN      remapOutputPin )
61:                  {
62:                      *(&RPB0R - 2 + remapOutputPin) = ( ( *((SFR_TYPE *)(&RPB0R - 2 + remapOutputPin)) ) & ~(_RPB0R_RPB0R_MASK) ) | ( (_RPB0R_RPB0R_MASK) & ((outputFunction)<<(_RPB0R_RPB0R_POSITION)) );
9D005D00  3C02BF80   LUI V0, -16512
00000030  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapOutput_PIC32_1
68:                  
69:                    Summary:
70:                      Implements PIC32_1 variant of PLIB_PORTS_ExistsRemapOutput
71:                  
72:                    Description:
73:                      This template implements the PIC32_1 variant of the PLIB_PORTS_ExistsRemapOutput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapOutput PLIB_PORTS_ExistsRemapOutput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapOutput_PIC32_1( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPOUTPUT_PIC32_1_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_remapinput_default.h  -----
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapInput_default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapInput
13:                      and its Variant : default
14:                      For following APIs :
15:                          PLIB_PORTS_RemapInput
16:                          PLIB_PORTS_ExistsRemapInput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPINPUT_DEFAULT_H
47:                  #define _PORTS_REMAPINPUT_DEFAULT_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapInput_default
52:                  
53:                    Summary:
54:                      Implements default variant of PLIB_PORTS_RemapInput 
55:                  
56:                    Description:
57:                      This template implements the default variant of the PLIB_PORTS_RemapInput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapInput_default( PORTS_MODULE_ID      index , PORTS_REMAP_INPUT_FUNCTION inputFunction , PORTS_REMAP_INPUT_PIN      remapInputPin )
61:                  {
62:                      *(&INT1R + inputFunction) = ( ( *((SFR_TYPE *)(&INT1R + inputFunction)) ) & ~(_INT1R_INT1R_MASK) ) | ( (_INT1R_INT1R_MASK) & ((remapInputPin)<<(_INT1R_INT1R_POSITION)) );
9D005CB8  3C02BF80   LUI V0, -16512
9D005CBC  24421404   ADDIU V0, V0, 5124
9D005CC0  8C43006C   LW V1, 108(V0)
9D005CC4  7C031804   INS V1, ZERO, 0, 4
9D005CC8  34630004   ORI V1, V1, 4
9D005CCC  AC43006C   SW V1, 108(V0)
9D005CD0  8C4300DC   LW V1, 220(V0)
9D005CD4  7C031804   INS V1, ZERO, 0, 4
9D005CD8  34630002   ORI V1, V1, 2
9D005CDC  AC4300DC   SW V1, 220(V0)
9D005CE0  8C43007C   LW V1, 124(V0)
9D005CE4  7C031804   INS V1, ZERO, 0, 4
9D005CE8  34630005   ORI V1, V1, 5
9D005CEC  AC43007C   SW V1, 124(V0)
9D005CF0  8C430074   LW V1, 116(V0)
9D005CF4  7C031804   INS V1, ZERO, 0, 4
9D005CF8  34630003   ORI V1, V1, 3
9D005CFC  AC430074   SW V1, 116(V0)
00000030  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapInput_default
68:                  
69:                    Summary:
70:                      Implements default variant of PLIB_PORTS_ExistsRemapInput
71:                  
72:                    Description:
73:                      This template implements the default variant of the PLIB_PORTS_ExistsRemapInput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapInput PLIB_PORTS_ExistsRemapInput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapInput_default( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPINPUT_DEFAULT_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_portswrite_mcu32_pps.h  ---
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_PPS_H
54:                  #define _PORTS_PORTSWRITE_MCU32_PPS_H
55:                  
56:                  
57:                  //******************************************************************************
58:                  /* Function :  PORTS_PinWrite_MCU32_PPS
59:                  
60:                    Summary:
61:                      Implements MCU32_PPS variant of PLIB_PORTS_PinWrite 
62:                  
63:                    Description:
64:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinWrite function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
68:                  {
69:                      /* Atomic Implementation */
70:                      if(value == true)
00000000  00000000   NOP
71:                      {
72:                          *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000008  00000000   NOP
73:                      }
74:                      else
75:                      {
76:                          *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000034  00000000   NOP
77:                      }
78:                  }
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  PORTS_PinSet_MCU32_PPS
83:                  
84:                    Summary:
85:                      Implements MCU32_PPS variant of PLIB_PORTS_PinSet 
86:                  
87:                    Description:
88:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinSet function.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void PORTS_PinSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
92:                  {
93:                  
94:                      *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
95:                      
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  PORTS_PinClear_MCU32_PPS
101:                 
102:                   Summary:
103:                     Implements MCU32_PPS variant of PLIB_PORTS_PinClear 
104:                 
105:                   Description:
106:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
110:                 {
111:                 	
112:                     *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;	
113:                 						   
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_PinToggle_MCU32_PPS
119:                 
120:                   Summary:
121:                     Implements MCU32_PPS variant of PLIB_PORTS_PinToggle 
122:                 
123:                   Description:
124:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinToggle function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
128:                 {
129:                 
130:                     *(&LATBINV + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
131:                 						   
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_Write_MCU32_PPS
137:                 
138:                   Summary:
139:                     Implements MCU32_PPS variant of PLIB_PORTS_Write 
140:                 
141:                   Description:
142:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Write function.
143:                 */
144:                 
145:                 PLIB_TEMPLATE void PORTS_Write_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
146:                 {
147:                     *(&LATB + (channel - 1) * 0x40) = value;
9D005AE0  3C0ABF86   LUI T2, -16506
9D005B94  254A0130   ADDIU T2, T2, 304
9D005B98  AD400100   SW ZERO, 256(T2)
9D005BDC  AD400200   SW ZERO, 512(T2)
9D005C48  AD400300   SW ZERO, 768(T2)
9D005C74  AD400400   SW ZERO, 1024(T2)
9D005C98  AD400500   SW ZERO, 1280(T2)
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  PORTS_Set_MCU32_PPS
153:                 
154:                   Summary:
155:                     Implements MCU32_PPS variant of PLIB_PORTS_Set 
156:                 
157:                   Description:
158:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Set function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void PORTS_Set_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
162:                 {
163:                     
164:                     *(&LATBSET + (channel - 1) * 0x40) = (value & mask);
165:                 	
166:                 }
167:                 
168:                 
169:                 //******************************************************************************
170:                 /* Function :  PORTS_Toggle_MCU32_PPS
171:                 
172:                   Summary:
173:                     Implements MCU32_PPS variant of PLIB_PORTS_Toggle 
174:                 
175:                   Description:
176:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Toggle function.
177:                 */
178:                 
179:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
180:                 {
181:                     *(&LATBINV + (channel - 1) * 0x40) = toggleMask;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  PORTS_Clear_MCU32_PPS
187:                 
188:                   Summary:
189:                     Implements MCU32_PPS variant of PLIB_PORTS_Clear 
190:                 
191:                   Description:
192:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Clear function.
193:                 */
194:                 
195:                 PLIB_TEMPLATE void PORTS_Clear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
196:                 {
197:                     
198:                     *(&LATBCLR + (channel - 1) * 0x40) = clearMask;	
00000000  00000000   NOP
199:                 						 
200:                 }
201:                 
202:                 
203:                 //******************************************************************************
204:                 /* Function :  PORTS_ExistsPortsWrite_MCU32_PPS
205:                 
206:                   Summary:
207:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsWrite
208:                 
209:                   Description:
210:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsWrite function.
211:                 */
212:                 
213:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
214:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32_PPS( PORTS_MODULE_ID index )
215:                 {
216:                     return true;
217:                 }
218:                 
219:                 
220:                 #endif /*_PORTS_PORTSWRITE_MCU32_PPS_H*/
221:                 
222:                 /******************************************************************************
223:                  End of File
224:                 */
225:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_PPS_H
48:                  #define _PORTS_PORTSREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGet_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGet 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&PORTB + ((channel - 1) * 0x40)) >> bitPos) & 1);
00000000  00000000   NOP
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_Read_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_Read 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_Read function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&PORTB + ((channel - 1) * 0x40)));
9D005B30  3C0DBF86   LUI T5, -16506
9D005B34  8DA20120   LW V0, 288(T5)
9D005C04  25AD0120   ADDIU T5, T5, 288
9D005C08  8DAD0200   LW T5, 512(T5)
00000000  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsPortsRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_PORTSREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
51:                  
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32_PPS
57:                  
58:                    Summary:
59:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainEnable 
60:                  
61:                    Description:
62:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
66:                  {
67:                      *(&ODCBSET + (channel - 1) * 0x40) = 1<<bitPos;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32_PPS
73:                  
74:                    Summary:
75:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainDisable 
76:                  
77:                    Description:
78:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
82:                  {
83:                      *(&ODCBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_OpenDrainEnable_MCU32_PPS
89:                  
90:                    Summary:
91:                      Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainEnable 
92:                  
93:                    Description:
94:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainEnable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
98:                  {
99:                      *(&ODCBSET + (channel - 1) * 0x40) = mask;
9D005AD8  3C0BBF86   LUI T3, -16506
9D005ADC  AD600148   SW ZERO, 328(T3)
9D005B8C  256B0148   ADDIU T3, T3, 328
9D005B90  AD600100   SW ZERO, 256(T3)
9D005BD8  AD600200   SW ZERO, 512(T3)
9D005C44  AD600300   SW ZERO, 768(T3)
9D005C70  AD600400   SW ZERO, 1024(T3)
9D005C94  AD600500   SW ZERO, 1280(T3)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_OpenDrainDisable_MCU32_PPS
105:                 
106:                   Summary:
107:                     Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainDisable 
108:                 
109:                   Description:
110:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
114:                 {
115:                     *(&ODCBCLR + (channel - 1) * 0x40) = mask;
00000000  00000000   NOP
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32_PPS
121:                 
122:                   Summary:
123:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsOpenDrain
124:                 
125:                   Description:
126:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
127:                 */
128:                 
129:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
130:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32_PPS( PORTS_MODULE_ID index )
131:                 {
132:                     return true;
133:                 }
134:                 
135:                 
136:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_PPS_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_portsdirection_mcu32_pps.h  
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_PPS_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_PPS_H
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinDirectionInputSet_MCU32_PPS
56:                  
57:                    Summary:
58:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionInputSet 
59:                  
60:                    Description:
61:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionInputSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
65:                  {
66:                      *(&TRISBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000034  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32_PPS
72:                  
73:                    Summary:
74:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionOutputSet 
75:                  
76:                    Description:
77:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionOutputSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
81:                  {
82:                      *(&TRISBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000008  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_DirectionInputSet_MCU32_PPS
88:                  
89:                    Summary:
90:                      Implements MCU32_PPS variant of PLIB_PORTS_DirectionInputSet 
91:                  
92:                    Description:
93:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionInputSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
97:                  {
98:                      *(&TRISBSET + (channel - 1) * 0x40) = mask;
0000000C  00000000   NOP
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_DirectionOutputSet_MCU32_PPS
104:                 
105:                   Summary:
106:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionOutputSet 
107:                 
108:                   Description:
109:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionOutputSet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
113:                 {
114:                     *(&TRISBCLR + (channel - 1) * 0x40) = mask;
9D005AEC  3C09BF86   LUI T1, -16506
9D005B9C  25290114   ADDIU T1, T1, 276
9D005BA0  240F4000   ADDIU T7, ZERO, 16384
9D005BA4  AD2F0100   SW T7, 256(T1)
9D005BE0  240F0002   ADDIU T7, ZERO, 2
9D005BE4  AD2F0200   SW T7, 512(T1)
9D005C4C  240200F2   ADDIU V0, ZERO, 242
9D005C50  AD220300   SW V0, 768(T1)
9D005C78  AD200400   SW ZERO, 1024(T1)
9D005C9C  AD200500   SW ZERO, 1280(T1)
00000030  00000000   NOP
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_DirectionGet_MCU32_PPS
120:                 
121:                   Summary:
122:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionGet 
123:                 
124:                   Description:
125:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
129:                 {
130:                     return ( *(&TRISB + (channel - 1) * 0x40) );
00000000  00000000   NOP
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  PORTS_ExistsPortsDirection_MCU32_PPS
136:                 
137:                   Summary:
138:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsDirection
139:                 
140:                   Description:
141:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsDirection function.
142:                 */
143:                 
144:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
145:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32_PPS( PORTS_MODULE_ID index )
146:                 {
147:                     return true;
148:                 }
149:                 
150:                 
151:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_PPS_H*/
152:                 
153:                 /******************************************************************************
154:                  End of File
155:                 */
156:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_pinmodeperport_default.h  -
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinModePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinModePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinModePerPortSelect
16:                          PLIB_PORTS_ChannelModeSelect
17:                          PLIB_PORTS_ExistsPinModePerPort
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PINMODEPERPORT_DEFAULT_H
48:                  #define _PORTS_PINMODEPERPORT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModePerPortSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_PinModePerPortSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_PinModePerPortSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModePerPortSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos , PORTS_PIN_MODE   mode )
62:                  {
63:                      if ( mode == PORTS_PIN_MODE_ANALOG )
64:                  	{
65:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;	
66:                  	}
67:                  	else
68:                  	{
69:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
70:                  	}
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_ChannelModeSelect_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_PORTS_ChannelModeSelect 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_PORTS_ChannelModeSelect function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_ChannelModeSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   modeMask , PORTS_PIN_MODE mode )
85:                  {
86:                      if ( mode == PORTS_PIN_MODE_ANALOG )
87:                  	{
88:                          *(&ANSELBSET + (channel - 1) * 0x40) = modeMask;	
89:                  	}
90:                  	else
91:                  	{
92:                          *(&ANSELBCLR + (channel - 1) * 0x40) = modeMask;
9D005B04  3C07BF86   LUI A3, -16506
9D005B08  3402FFC0   ORI V0, ZERO, -64
9D005B0C  ACE20104   SW V0, 260(A3)
9D005BB0  24E70104   ADDIU A3, A3, 260
9D005BB4  240F6000   ADDIU T7, ZERO, 24576
9D005BB8  ACEF0100   SW T7, 256(A3)
9D005BEC  240F0E3F   ADDIU T7, ZERO, 3647
9D005BF0  ACEF0200   SW T7, 512(A3)
9D005C58  240200FF   ADDIU V0, ZERO, 255
9D005C5C  ACE20300   SW V0, 768(A3)
9D005C80  2402003B   ADDIU V0, ZERO, 59
9D005C84  ACE20400   SW V0, 1024(A3)
9D005CA4  24020180   ADDIU V0, ZERO, 384
9D005CA8  ACE20500   SW V0, 1280(A3)
93:                  	}
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PORTS_ExistsPinModePerPort_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_PORTS_ExistsPinModePerPort
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinModePerPort function.
105:                 */
106:                 
107:                 #define PLIB_PORTS_ExistsPinModePerPort PLIB_PORTS_ExistsPinModePerPort
108:                 PLIB_TEMPLATE bool PORTS_ExistsPinModePerPort_Default( PORTS_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_PORTS_PINMODEPERPORT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_pinmode_pps.h  ------------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinMode_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinMode
13:                      and its Variant : PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinModeSelect
16:                          PLIB_PORTS_ExistsPinMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_PINMODE_PPS_H
47:                  #define _PORTS_PINMODE_PPS_H
48:                  
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModeSelect_PPS
53:                  
54:                    Summary:
55:                      Implements PPS variant of PLIB_PORTS_PinModeSelect 
56:                  
57:                    Description:
58:                      This template implements the PPS variant of the PLIB_PORTS_PinModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModeSelect_PPS( PORTS_MODULE_ID  index , PORTS_ANALOG_PIN pin , PORTS_PIN_MODE   mode )
62:                  {
63:                  
64:                  uint8_t channel, bitPos;
65:                  
66:                      channel = pin/16;
00000000  00000000   NOP
67:                      bitPos = pin % 16;
68:                  
69:                      if ( mode == PORTS_PIN_MODE_ANALOG )
00000004  00000000   NOP
70:                  	{
71:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000010  00000000   NOP
72:                  	}
73:                  	else
74:                  	{
75:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
0000003C  00000000   NOP
76:                  	}
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  PORTS_ExistsPinMode_PPS
81:                  
82:                    Summary:
83:                      Implements PPS variant of PLIB_PORTS_ExistsPinMode
84:                  
85:                    Description:
86:                      This template implements the PPS variant of the PLIB_PORTS_ExistsPinMode function.
87:                  */
88:                  
89:                  #define PLIB_PORTS_ExistsPinMode PLIB_PORTS_ExistsPinMode
90:                  PLIB_TEMPLATE bool PORTS_ExistsPinMode_PPS( PORTS_MODULE_ID index )
91:                  {
92:                      return true;
93:                  }
94:                  
95:                  
96:                  #endif /*_PORTS_PINMODE_PPS_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_pinchangenoticeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNoticePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNoticePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticePerPortEnable
16:                          PLIB_PORTS_PinChangeNoticePerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticeEnable
18:                          PLIB_PORTS_ChannelChangeNoticeDisable
19:                          PLIB_PORTS_ExistsPinChangeNoticePerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinChangeNoticePerPortEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
65:                  {
66:                      *(&CNENBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticePerPortDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
81:                  {
82:                      *(&CNENBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_ChannelChangeNoticeEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticeEnable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticeEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
97:                  {
98:                      *(&CNENBSET + (channel - 1) * 0x40) = mask;
9D005B10  3C06BF86   LUI A2, -16506
9D005B14  24023300   ADDIU V0, ZERO, 13056
9D005B18  ACC20188   SW V0, 392(A2)
9D005BBC  24C60188   ADDIU A2, A2, 392
9D005BC0  ACC00100   SW ZERO, 256(A2)
9D005BF4  240F0800   ADDIU T7, ZERO, 2048
9D005BF8  ACCF0200   SW T7, 512(A2)
9D005C60  ACC00300   SW ZERO, 768(A2)
9D005C88  ACC00400   SW ZERO, 1024(A2)
9D005CAC  ACC00500   SW ZERO, 1280(A2)
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ChannelChangeNoticeDisable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticeDisable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeDisable function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticeDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
113:                 {
114:                     *(&CNENBCLR + (channel - 1) * 0x40) = mask;
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_ExistsPinChangeNoticePerPort_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNoticePerPort
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNoticePerPort function.
126:                 */
127:                 
128:                 #define PLIB_PORTS_ExistsPinChangeNoticePerPort PLIB_PORTS_ExistsPinChangeNoticePerPort
129:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNoticePerPort_Default( PORTS_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_changenoticepullupperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullUpPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullUpPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullUpPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullUpEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUpPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullUpPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPUBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullUpPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPUBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  PORTS_ChannelChangeNoticePullUpEnable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpEnable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpEnable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
95:                  {
96:                      *(&CNPUBSET + (channel - 1) * 0x40) = mask;
9D005B1C  3C05BF86   LUI A1, -16506
9D005B20  ACA00158   SW ZERO, 344(A1)
9D005BC4  24A50158   ADDIU A1, A1, 344
9D005BC8  ACA00100   SW ZERO, 256(A1)
9D005BFC  ACA00200   SW ZERO, 512(A1)
9D005C64  24020001   ADDIU V0, ZERO, 1
9D005C68  ACA20300   SW V0, 768(A1)
9D005C8C  ACA00400   SW ZERO, 1024(A1)
9D005CB0  ACA20500   SW V0, 1280(A1)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  PORTS_ChannelChangeNoticePullUpDisable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpDisable 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpDisable function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
111:                 {
112:                     *(&CNPUBCLR + (channel - 1) * 0x40) = mask;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  PORTS_ExistsChangeNoticePullUpPerPort_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUpPerPort
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUpPerPort function.
124:                 */
125:                 
126:                 #define PLIB_PORTS_ExistsChangeNoticePullUpPerPort PLIB_PORTS_ExistsChangeNoticePullUpPerPort
127:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUpPerPort_Default( PORTS_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_changenoticepulldownperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullDownPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullDownPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullDownPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullDownPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullDownEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullDownDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullDownPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullDownPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPDBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullDownPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPDBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChannelChangeNoticePullDownEnable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownEnable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownEnable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
96:                  {
97:                      *(&CNPDBSET + (channel - 1) * 0x40) = mask;
9D005B24  3C04BF86   LUI A0, -16506
9D005B28  24020F00   ADDIU V0, ZERO, 3840
9D005B2C  AC820168   SW V0, 360(A0)
9D005BCC  24840168   ADDIU A0, A0, 360
9D005BD0  240F2000   ADDIU T7, ZERO, 8192
9D005BD4  AC8F0100   SW T7, 256(A0)
9D005C00  AC8F0200   SW T7, 512(A0)
9D005C6C  AC800300   SW ZERO, 768(A0)
9D005C90  AC800400   SW ZERO, 1024(A0)
9D005CB4  AC800500   SW ZERO, 1280(A0)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  PORTS_ChannelChangeNoticePullDownDisable_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownDisable 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownDisable function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
112:                 {
113:                     *(&CNPDBCLR + (channel - 1) * 0x40) = mask;
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_ExistsChangeNoticePullDownPerPort_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullDownPerPort
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullDownPerPort function.
125:                 */
126:                 
127:                 #define PLIB_PORTS_ExistsChangeNoticePullDownPerPort PLIB_PORTS_ExistsChangeNoticePullDownPerPort
128:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullDownPerPort_Default( PORTS_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/ports/templates/ports_changenoticeperportturnon_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePerPortTurnOn_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePerPortTurnOn
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePerPortTurnOn
16:                          PLIB_PORTS_ChangeNoticePerPortTurnOff
17:                          PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChangeNoticePerPortTurnOn_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOn 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOn function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
62:                  {
63:                      *(&CNCONBSET + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
9D005AF8  3C08BF86   LUI T0, -16506
9D005AFC  34038000   ORI V1, ZERO, -32768
9D005B00  AD030178   SW V1, 376(T0)
9D005BA8  25080178   ADDIU T0, T0, 376
9D005BAC  AD030100   SW V1, 256(T0)
9D005BE8  AD030200   SW V1, 512(T0)
9D005C54  AD030300   SW V1, 768(T0)
9D005C7C  AD030400   SW V1, 1024(T0)
9D005CA0  AD030500   SW V1, 1280(T0)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ChangeNoticePerPortTurnOff_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOff 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOff function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOff_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
78:                  {
79:                      *(&CNCONBCLR + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsChangeNoticePerPortTurnOn_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePerPortTurnOn function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsChangeNoticePerPortTurnOn PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
94:                  PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/peripheral_common_32bit.h  ----------------------
1:                   /*******************************************************************************
2:                     Peripheral Library specific for 32 bit parts
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       peripheral_common_32bit.h
9:                   
10:                    Summary:
11:                      This file defines the 32-bit specific macros and definitions used by the peripheral
12:                      library implementation headers.
13:                  
14:                    Description:
15:                      This file defines the 32-bit specific macros and definitions used by the peripheral
16:                      library implementation headers.  All the definitions in this file are
17:                      private to the peripheral library implementation.
18:                  
19:                    Remarks:
20:                      None
21:                   *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012-2014 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _PLIB_COMMON_32BIT_H
49:                  #define _PLIB_COMMON_32BIT_H
50:                  
51:                  #include <assert.h>
52:                  #include <stdint.h>
53:                  
54:                  // DOM-IGNORE-BEGIN
55:                  #ifdef __cplusplus  // Provide C++ Compatibility
56:                  
57:                      extern "C" {
58:                  
59:                  #endif
60:                  // DOM-IGNORE-END 
61:                  
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  // Section: Data Types
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  /* These macros are used to access bits in registers in the peripheral libraries
68:                  */
69:                  
70:                  // *****************************************************************************
71:                  /* SFR_TYPE datatype
72:                  
73:                    Summary:
74:                      Defines the type for SFR on the 32 bit parts
75:                  
76:                    Description:
77:                      This type is specific to the SFR type in the 32 bit parts.
78:                  
79:                  */
80:                  
81:                  typedef volatile uint32_t SFR_TYPE;
82:                  
83:                  
84:                  // *****************************************************************************
85:                  /* SFR_DATA datatype
86:                  
87:                    Summary:
88:                      Defines the type for SFR data on the 32 bit parts
89:                  
90:                    Description:
91:                      This type is specific to the SFR data in the 32 bit parts.
92:                  
93:                  */
94:                  
95:                  typedef uint32_t SFR_DATA;
96:                  
97:                  
98:                  // *****************************************************************************
99:                  /* PIC32MZ kseg2/3 to physical address conversion macros
100:                 
101:                   Summary:
102:                     Macros to convert between kseg2/3 virtual and physical addresses
103:                 
104:                   Description:
105:                     Macros to convert between kseg2/3 virtual and physical addresses. Needed for
106:                     DMA transfer to/from external memory on EBI or SQI with PIC32MZ.
107:                 
108:                 */
109:                 
110:                 #define KVA2_TO_PA(v) (((v) & 0x3FFFFFFF) | 0x20000000)
111:                 #define KVA3_TO_PA(v) ((v) & 0x3FFFFFFF)
112:                 #define PA_TO_KVA2(v) (((v) & 0xDFFFFFFF) | 0xC0000000) 
113:                 #define PA_TO_KVA3(v) ((v) | 0xC0000000) 
114:                 
115:                 
116:                 // *****************************************************************************
117:                 /* Function:
118:                     unsigned uintptr_t _PLIB_VirtToPhys ( const void* p )
119:                 
120:                   Summary:
121:                     Translates a virtual pointer to a physical address
122:                 
123:                   Description:
124:                     This function translates a virtual pointer to a physical address suitable
125:                     for use with DMA and other hardware operations that require a physical
126:                     address.
127:                 
128:                   Precondition:
129:                     None.
130:                 
131:                   Parameters:
132:                     p       - Pointer to be converted
133:                 
134:                   Returns:
135:                     The physical address corresponding to the virtual input pointer.
136:                 
137:                   Example:
138:                     <code>
139:                     int         myData;
140:                     uintptr_t   physAddr;
141:                     physAddr = _PLIB_VirtToPhys(&myData);  // Safe to write to DMA register
142:                     </code>
143:                 
144:                   Remarks:
145:                     On parts that do not require this translation, this function returns
146:                     the given address unchanged (other than by the data type to which
147:                     it is cast).
148:                 */
149:                 
150:                 extern __inline__ uintptr_t __attribute__ ( ( always_inline ) ) _PLIB_VirtToPhys ( const void* p )
151:                 {
152:                      return ( (((uintptr_t)(p))&0x80000000L) ? (((uintptr_t)(p))&0x1fffffffL) : (((uintptr_t)(p))|0x40000000L) );
9D0049D0  3C02A000   LUI V0, -24576
9D0049D4  24425B80   ADDIU V0, V0, 23424
9D0049D8  04400005   BLTZ V0, .LBE295
9D0049DC  7C43E000   EXT V1, V0, 0, 29
9D0049E0  3C024000   LUI V0, 16384
9D0049E4  3C03A000   LUI V1, -24576
9D0049E8  24635B80   ADDIU V1, V1, 23424
9D0049EC  00621825   OR V1, V1, V0
153:                 }
154:                 
155:                 
156:                 // *****************************************************************************
157:                 /* Function:
158:                    void* _PLIB_PhysToVirtK0 ( uintptr_t a )
159:                 
160:                   Summary:
161:                     Translates a PIC32 K0 segment physical address to a virtual pointer
162:                 
163:                   Description:
164:                     This function translates a PIC32 K0 segment physical address to a virtual
165:                     pointer.
166:                 
167:                   Precondition:
168:                     None.
169:                 
170:                   Parameters:
171:                     a       - Physical address to be converted
172:                 
173:                   Returns:
174:                     A virtual pointer corresponding to the given physical address.
175:                 
176:                   Example:
177:                     <code>
178:                     char *      pMyData;    // Virtual pointer to DMA data
179:                     pMyData = _PLIB_PhysToVirtK0(PHY_ADDR_MY_DMA_BUFFER);
180:                     </code>
181:                 
182:                   Remarks:
183:                     On parts that do not require this translation, this function returns
184:                     the given address unchanged (other than by the data type to which
185:                     it is cast).
186:                 */
187:                 
188:                 extern __inline__ void* __attribute__ ( ( always_inline ) ) _PLIB_PhysToVirtK0 ( uintptr_t a )
189:                 {
190:                 	return ( ( a<0x40000000L )?( void* )( a|0x80000000L ):( void* )( a-0x40000000L ) );
191:                 }
192:                 
193:                 
194:                 // *****************************************************************************
195:                 /* Function:
196:                    void* _PLIB_PhysToVirtK1 ( uintptr_t a )
197:                 
198:                   Summary:
199:                     Translates a K1 segment physical address to a virtual pointer
200:                 
201:                   Description:
202:                     This function translates a K1 segment physical address to a virtual
203:                     pointer.
204:                 
205:                   Precondition:
206:                     None.
207:                 
208:                   Parameters:
209:                     a       - Physical address to be converted
210:                 
211:                   Returns:
212:                     A virtual pointer corresponding to the given physical address.
213:                 
214:                   Example:
215:                     <code>
216:                     char *      pMyData;    // Virtual pointer to DMA data
217:                     pMyData = _PLIB_PhysToVirtK1(PHY_ADDR_MY_DMA_BUFFER);
218:                     </code>
219:                 
220:                   Remarks:
221:                     On parts that do not require this translation, this function returns
222:                     the given address unchanged (other than by the data type to which
223:                     it is cast).
224:                 */
225:                 
226:                 extern __inline__ void* __attribute__((always_inline)) _PLIB_PhysToVirtK1( uintptr_t a )
227:                 {
228:                 	return (a<0x40000000L?(void*)(a|0xa0000000L):(void*)(a-0x40000000L));
9D00399C  3C034000   LUI V1, 16384
9D0039A0  0043182B   SLTU V1, V0, V1
9D0039A4  50600004   BEQL V1, ZERO, .LBB62, .LBB58, .LBB55
9D0039A8  3C05C000   LUI A1, -16384
9D0039AC  3C05A000   LUI A1, -24576
9D0039B0  0B400E6F   J .LVL59, .LBE55, .LBE58
9D0039B4  00452825   OR A1, V0, A1
9D0039B8  00452821   ADDU A1, V0, A1
9D003A78  3C034000   LUI V1, 16384
9D003A7C  0043182B   SLTU V1, V0, V1
9D003A80  50600004   BEQL V1, ZERO, .LBB84, .LBB77, .LBB74
9D003A84  3C11C000   LUI S1, -16384
9D003A88  3C11A000   LUI S1, -24576
9D003A8C  0B400EA6   J .LVL69, .LBE74, .LBE77
9D003A90  00518825   OR S1, V0, S1
9D003A94  00518821   ADDU S1, V0, S1
9D009B8C  3C034000   LUI V1, 16384
9D009B90  0043182B   SLTU V1, V0, V1
9D009B94  10600004   BEQ V1, ZERO, .LVL55, .LBB402, .LBB399
9D009B98  3C03C000   LUI V1, -16384
9D009B9C  3C03A000   LUI V1, -24576
9D009BA0  0B4026EB   J .LVL56, .LBE399, .LBE402
9D009BA4  00431025   OR V0, V0, V1
9D009BA8  00431021   ADDU V0, V0, V1
0000002C  00000000   NOP
229:                 }
230:                 
231:                 // *****************************************************************************
232:                 // *****************************************************************************
233:                 // Section: 32-bit specific macros
234:                 // *****************************************************************************
235:                 // *****************************************************************************
236:                 /*  This section contains macros that utilize the CLR/SET/INV shadow registers
237:                  *  in PIC32 devices.
238:                 */
239:                 
240:                 // *****************************************************************************
241:                 /* Register Operation:  Bit Set
242:                 
243:                   Summary:
244:                     Sets the bit in the specified register.
245:                 
246:                   Description:
247:                     This macro sets the specified bit in the specified register.
248:                     The bit set is selected by the given bit position.
249:                 
250:                   Parameters:
251:                     reg - SFR register name.
252:                     pos - bit position within register.
253:                 
254:                   Returns:
255:                     New value of the SFR register.
256:                 
257:                   Example:
258:                   <code>
259:                     PLIB_TEMPLATE void PLIB_USB_OTG_VBusChargeEnable ( USB_MODULE_ID index )
260:                     {
261:                         _SFR_BIT_SET(_USB_VBUS_CHARGE_PULLUP_VREG(index),
262:                                      _USB_VBUS_CHARGE_PULLUP_POS(index) );
263:                     }
264:                   </code>
265:                 
266:                   Remarks:
267:                     The compiler should optimize the macro to a single bit-set instruction on
268:                     processors that support bit-set instructions.  The specific instruction will
269:                     be dependent on the architecture on which the macro is being used.
270:                 
271:                     This operation is not guaranteed to access the register atomically.
272:                     It may perform a read-modify-write operation.
273:                 */
274:                 
275:                 #define _SFR_BIT_SET(reg,pos)        ( *((SFR_TYPE *)((reg)+(2))) = 1<<(pos) )
276:                 
277:                 
278:                 // *****************************************************************************
279:                 /* Register Operation:  Bit Clear
280:                 
281:                   Summary:
282:                     Clears the bit in the specified register.
283:                 
284:                   Description:
285:                     This macro clear the specified bit in the specified register.
286:                     The bit cleared is selected by the given bit position.
287:                 
288:                   Parameters:
289:                     reg - SFR register name.
290:                     pos - bit position within register.
291:                 
292:                   Returns:
293:                     New value of the SFR register.
294:                 
295:                   Example:
296:                   <code>
297:                     PLIB_TEMPLATE void PLIB_USB_OTG_VBusChargeDisable ( USB_MODULE_ID index )
298:                     {
299:                         _SFR_BIT_CLEAR(_USB_VBUS_CHARGE_PULLUP_VREG(index),
300:                                        _USB_VBUS_CHARGE_PULLUP_POS(index) );
301:                     }
302:                   </code>
303:                 
304:                   Remarks:
305:                 	This operation adds an offset of '1' to access the 'CLR' register
306:                 	corresponding to the register specified.
307:                 */
308:                 
309:                 #define _SFR_BIT_CLEAR(reg,pos)      ( *((SFR_TYPE *)((reg)+(1))) = 1<<(pos) )
310:                 
311:                 
312:                 // *****************************************************************************
313:                 /* Register Operation:  Bit Invert
314:                 
315:                   Summary:
316:                     Inverts the bit in the specified register.
317:                 
318:                   Description:
319:                     This macro invert the specified bit in the specified register.
320:                     The bit inverted is selected by the given bit position.
321:                 
322:                   Parameters:
323:                     reg - SFR register name.
324:                     pos - bit position within register.
325:                 
326:                   Returns:
327:                     New value of the SFR register.
328:                 
329:                   Example:
330:                   <code>
331:                   </code>
332:                 
333:                   Remarks:
334:                 
335:                 	This operation adds an offset of '3' to access the 'INV' register
336:                 	corresponding to the register specified.
337:                 */
338:                 
339:                 #define _SFR_BIT_INVERT(reg,pos)     ( *((SFR_TYPE *)((reg)+(3))) = 1<<(pos) )
340:                 
341:                 
342:                 // *****************************************************************************
343:                 /* Register Operation:  Field Set
344:                 
345:                   Summary:
346:                     Sets bits in the field of a specified register.
347:                 
348:                   Description:
349:                     This macro sets bits in the specified field of the specified register.
350:                     The field modified is selected by the given field position and field mask.
351:                     The bits set within the field are specified by the value.
352:                 
353:                   Parameters:
354:                     reg - SFR register name.
355:                     mask - field bit mask within the register.
356:                     pos - bit position within register.
357:                     val - Each "1" bit in val field indicates the corresponding bit in
358:                           the field is set to "1", with the LSb of val justified to be at bit zero.
359:                 
360:                   Returns:
361:                     New value of the SFR register.
362:                 
363:                   Example:
364:                   <code>
365:                     PLIB_TEMPLATE void PLIB_USB_OTG_VBusChargeEnable ( USB_MODULE_ID index )
366:                     {
367:                         _SFR_FIELD_SET(_USB_VBUS_CHARGE_PULLUP_VREG(index),
368:                                        _USB_VBUS_CHARGE_PULLUP_MASK(index),
369:                                        _USB_VBUS_CHARGE_PULLUP_POS(index) ,
370:                                        0x1                                );
371:                     }
372:                   </code>
373:                 
374:                   Remarks:
375:                 
376:                 	This operation adds an offset of '2' to access the 'SET' register
377:                 	corresponding to the register specified.
378:                 
379:                     Positions are measured from the least significant bit (LSb) of the register.
380:                     Masks are position aligned.
381:                     Values are zero aligned.
382:                 */
383:                 
384:                 #define _SFR_FIELD_SET(reg,mask,pos,val)    (  *((SFR_TYPE *)((reg)+(2))) = ( (mask)&((val)<<(pos)) )  )
385:                 
386:                 
387:                 // *****************************************************************************
388:                 /* Register Operation:  Field Clear
389:                 
390:                   Summary:
391:                     Clears bits in the field of a specified register
392:                 
393:                   Description:
394:                     This macro clears bits in the specified field of the specified register.
395:                     The field modified is selected by the given field position and field mask.
396:                     The bits cleared within the field are specified by the value
397:                 
398:                   Parameters:
399:                     reg - SFR register name.
400:                     mask - field bit mask within the register.
401:                     pos - bit position within register.
402:                     val - Each "1" bit in val field indicates the corresponding bit in
403:                           the field is cleared to "0", with the LSb of val justified to be at bit zero.
404:                 
405:                   Returns:
406:                     New value of the SFR register.
407:                 
408:                   Example:
409:                   <code>
410:                     PLIB_TEMPLATE void PLIB_USB_OTG_VBusChargeDisable ( USB_MODULE_ID index )
411:                     {
412:                         _SFR_FIELD_CLEAR(_USB_VBUS_CHARGE_PULLUP_VREG(index),
413:                                          _USB_VBUS_CHARGE_PULLUP_MASK(index),
414:                                          _USB_VBUS_CHARGE_PULLUP_POS(index) ,
415:                                          0x1                                );
416:                     }
417:                   </code>
418:                 
419:                   Remarks:
420:                 	This operation adds an offset of '1' to access the 'CLR' register
421:                 	corresponding to the register specified.
422:                 
423:                     Positions are measured from the least significant bit (LSb) of the register.
424:                     Masks are position aligned.
425:                     Values are zero aligned.
426:                 */
427:                 
428:                 #define _SFR_FIELD_CLEAR(reg,mask,pos,val)  ( *((SFR_TYPE *)((reg)+(1))) = ( (mask)&((val)<<(pos)) ) )
429:                 
430:                 
431:                 // *****************************************************************************
432:                 /* Register Operation:  Field Invert
433:                 
434:                   Summary:
435:                     Inverts bits in the field of a specified register
436:                 
437:                   Description:
438:                     This macro inverts bits in the specified field of the specified register.
439:                     The field modified is selected by the given field position and field mask.
440:                     The bits inverted within the field are specified by the value
441:                 
442:                   Parameters:
443:                     reg - SFR register name.
444:                     mask - field bit mask within the register.
445:                     pos - bit position within register.
446:                     val - Each "1" bit in val field indicates the corresponding bit in
447:                           the field is inverted (0->1,1->0), with the LSb of val justified
448:                           to be at bit zero
449:                 
450:                   Returns:
451:                     New value of the SFR register.
452:                 
453:                   Example:
454:                   <code>
455:                   </code>
456:                 
457:                   Remarks:
458:                 	This operation adds an offset of '3' to access the 'INV' register
459:                 	corresponding to the register specified.
460:                 
461:                     Positions are measured from the least significant bit (LSb) of the register.
462:                     Masks are position aligned.
463:                     Values are zero aligned.
464:                 */
465:                 
466:                 #define _SFR_FIELD_INVERT(reg,mask,pos,val) (  *((SFR_TYPE *)((reg)+(3))) = ( (mask)&((val)<<(pos)) )  )
467:                 
468:                 
469:                 //******************************************************************************
470:                 /* Register Operation:  SFR Set
471:                 
472:                   Summary:
473:                     Sets the bits of the specified register using the bit map provided.
474:                 
475:                   Description:
476:                     Sets the bits of the specified register using the bit map provided.
477:                     The bits set are specified in the value provided.
478:                 
479:                   Parameters:
480:                     reg - SFR register name.
481:                     val - Each "1" bit in val indicates the corresponding bit in
482:                           the register is set to "1".
483:                 
484:                   Returns:
485:                     New value of the SFR register.
486:                 
487:                   Example:
488:                   <code>
489:                   </code>
490:                 
491:                   Remarks:
492:                 	This operation adds an offset of '2' to access the 'SET' register
493:                 	corresponding to the register specified.
494:                 
495:                     Positions are measured from the least significant bit (LSb) of the register.
496:                     Masks are position aligned.
497:                     Values are zero aligned.
498:                 */
499:                 
500:                 #define _SFR_SET(reg,val)    ( *((SFR_TYPE *)((reg)+(2))) = (val) )
501:                 
502:                 
503:                 //******************************************************************************
504:                 /* Register Operation:  SFR Clear
505:                 
506:                   Summary:
507:                     Clears the bits of the specified register using the bit map provided.
508:                 
509:                   Description:
510:                     Clears the bits of the specified register using the bit map provided.
511:                     The bits cleared are specified in the value provided.
512:                 
513:                   Parameters:
514:                     reg - SFR register name.
515:                     val - Each "1" bit in val indicates the corresponding bit in
516:                           the register is cleared to zero.
517:                 
518:                   Returns:
519:                     New value of the SFR register.
520:                 
521:                   Example:
522:                   <code>
523:                   </code>
524:                 
525:                   Remarks:
526:                 	This operation adds an offset of '1' to access the 'CLR' register
527:                 	corresponding to the register specified.
528:                 
529:                     Positions are measured from the least significant bit (LSb) of the register.
530:                     Masks are position aligned.
531:                     Values are zero aligned.
532:                 */
533:                 
534:                 #define _SFR_CLEAR(reg,val)  ( *((SFR_TYPE *)((reg)+(1))) = (val) )
535:                 
536:                 
537:                 //******************************************************************************
538:                 /* Register Operation:  SFR Invert
539:                 
540:                   Summary:
541:                     Inverts the bits of the specified register using the bit map provided.
542:                 
543:                   Description:
544:                     Inverts the bits of the specified register using the bit map provided.
545:                     The bits inverted are specified in the value provided.
546:                 
547:                   Parameters:
548:                     reg - SFR register name.
549:                     val - Each "1" bit in val indicates the corresponding bit in
550:                           the register is inverted (0->1,1->0).
551:                 
552:                   Returns:
553:                     New value of the SFR register.
554:                 
555:                   Example:
556:                   <code>
557:                   </code>
558:                 
559:                   Remarks:
560:                     This operation adds an offset of '3' to access the 'INV' register
561:                 	corresponding to the register specified.
562:                 
563:                     Positions are measured from the least significant bit (LSb) of the register.
564:                     Masks are position aligned.
565:                     Values are zero aligned.
566:                 */
567:                 
568:                 #define _SFR_INVERT(reg,val) ( *((SFR_TYPE *)((reg)+(3))) = (val) )
569:                 
570:                 //DOM-IGNORE-BEGIN
571:                 #ifdef __cplusplus
572:                 }
573:                 #endif
574:                 //DOM-IGNORE-END
575:                 
576:                 // *****************************************************************************
577:                 // *****************************************************************************
578:                 // Section: Included Files
579:                 // *****************************************************************************
580:                 // *****************************************************************************
581:                 /*  This section lists the other files that are included in this file.
582:                 */
583:                 
584:                 #include "peripheral/peripheral_common.h"
585:                 
586:                 
587:                 #endif /* End of File _PLIB_COMMON_32BIT_H */
588:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/pcache/templates/pcache_waitstate_mz.h  ---------
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_WaitState_MZ.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WaitState
13:                      and its Variant : MZ
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsWaitState
16:                          PLIB_PCACHE_WaitStateSet
17:                          PLIB_PCACHE_WaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_WAITSTATE_MZ_H
48:                  #define _PCACHE_WAITSTATE_MZ_H
49:                  
50:                  #include "pcache_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  PCACHE_ExistsWaitState_MZ
54:                  
55:                    Summary:
56:                      Implements MZ variant of PLIB_PCACHE_ExistsWaitState
57:                  
58:                    Description:
59:                      This template implements the MZ variant of the PLIB_PCACHE_ExistsWaitState function.
60:                  */
61:                  
62:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
63:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
64:                  PLIB_TEMPLATE bool PCACHE_ExistsWaitState_MZ( PCACHE_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PCACHE_WaitStateSet_MZ
72:                  
73:                    Summary:
74:                      Implements MZ variant of PLIB_PCACHE_WaitStateSet 
75:                  
76:                    Description:
77:                      This template implements the MZ variant of the PLIB_PCACHE_WaitStateSet function.
78:                      Operation is not atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PCACHE_WaitStateSet_MZ( PCACHE_MODULE_ID index , uint32_t clocks )
82:                  {
83:                      volatile pfm_register_t *regs = (pfm_register_t *)index;
84:                      regs->PRECON.PFMWS = clocks;
9D009CC8  3C02BF8E   LUI V0, -16498
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  PCACHE_WaitStateGet_MZ
90:                  
91:                    Summary:
92:                      Implements MZ variant of PLIB_PCACHE_WaitStateGet 
93:                  
94:                    Description:
95:                      This template implements the MZ variant of the PLIB_PCACHE_WaitStateGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint32_t PCACHE_WaitStateGet_MZ( PCACHE_MODULE_ID index )
100:                 {
101:                     volatile pfm_register_t *regs = (pfm_register_t *)index;
102:                     return (uint32_t)(regs->PRECON.PFMWS);
103:                 }
104:                 
105:                 
106:                 #endif /*_PCACHE_WAITSTATE_MZ_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/pcache/templates/pcache_prefetchenable_mz.h  ----
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_PrefetchEnable_MZ.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PrefetchEnable
13:                      and its Variant : MZ
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsPrefetchEnable
16:                          PLIB_PCACHE_PrefetchEnableSet
17:                          PLIB_PCACHE_PrefetchEnableGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_PREFETCHENABLE_MZ_H
48:                  #define _PCACHE_PREFETCHENABLE_MZ_H
49:                  
50:                  #include "pcache_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  PCACHE_ExistsPrefetchEnable_MZ
54:                  
55:                    Summary:
56:                      Implements MZ variant of PLIB_PCACHE_ExistsPrefetchEnable
57:                  
58:                    Description:
59:                      This template implements the MZ variant of the PLIB_PCACHE_ExistsPrefetchEnable function.
60:                  */
61:                  
62:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
63:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
64:                  PLIB_TEMPLATE bool PCACHE_ExistsPrefetchEnable_MZ( PCACHE_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PCACHE_PrefetchEnableSet_MZ
72:                  
73:                    Summary:
74:                      Implements MZ variant of PLIB_PCACHE_PrefetchEnableSet 
75:                  
76:                    Description:
77:                      This template implements the MZ variant of the PLIB_PCACHE_PrefetchEnableSet function.
78:                      Operation is not atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PCACHE_PrefetchEnableSet_MZ( PCACHE_MODULE_ID index , PLIB_PCACHE_PREFETCH_ENABLE region )
82:                  {
83:                      volatile pfm_register_t *regs = (pfm_register_t *)index;
84:                      regs->PRECON.PREFEN = region;
9D009CFC  3C02BF8E   LUI V0, -16498
9D009D00  8C430000   LW V1, 0(V0)
9D009D04  24050003   ADDIU A1, ZERO, 3
9D009D08  7CA32904   INS V1, A1, 4, 2
9D009D0C  AC430000   SW V1, 0(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  PCACHE_PrefetchEnableGet_MZ
90:                  
91:                    Summary:
92:                      Implements MZ variant of PLIB_PCACHE_PrefetchEnableGet 
93:                  
94:                    Description:
95:                      This template implements the MZ variant of the PLIB_PCACHE_PrefetchEnableGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE PLIB_PCACHE_PREFETCH_ENABLE PCACHE_PrefetchEnableGet_MZ( PCACHE_MODULE_ID index )
100:                 {
101:                     volatile pfm_register_t *regs = (pfm_register_t *)index;
102:                     return (PLIB_PCACHE_PREFETCH_ENABLE)(regs->PRECON.PREFEN);
103:                 }
104:                 
105:                 
106:                 #endif /*_PCACHE_PREFETCHENABLE_MZ_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_secondaryenable_default.h  ----
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_SecondaryEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SecondaryEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsSecondaryEnable
16:                          PLIB_OSC_SecondaryEnable
17:                          PLIB_OSC_SecondaryDisable
18:                          PLIB_OSC_SecondaryIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_SECONDARYENABLE_DEFAULT_H
49:                  #define _OSC_SECONDARYENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsSecondaryEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OSC_ExistsSecondaryEnable
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OSC_ExistsSecondaryEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsSecondaryEnable PLIB_OSC_ExistsSecondaryEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsSecondaryEnable_Default( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_SecondaryEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_OSC_SecondaryEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_OSC_SecondaryEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_SecondaryEnable_Default( OSC_MODULE_ID index )
79:                  {
80:                      OSCCONSET = _OSCCON_SOSCEN_MASK;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_SecondaryDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_OSC_SecondaryDisable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_OSC_SecondaryDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_SecondaryDisable_Default( OSC_MODULE_ID index )
95:                  {
96:                      OSCCONCLR = _OSCCON_SOSCEN_MASK;
00000024  00000000   NOP
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_SecondaryIsEnabled_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_OSC_SecondaryIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_OSC_SecondaryIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_SecondaryIsEnabled_Default( OSC_MODULE_ID index )
111:                 {
112:                    return (bool)OSCCONbits.SOSCEN;
00000000  00000000   NOP
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_SECONDARYENABLE_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_referenceoutputenable_pic32_2.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOutputEnable_PIC32_2.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOutputEnable
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOutputEnable
16:                          PLIB_OSC_ReferenceOutputEnable
17:                          PLIB_OSC_ReferenceOutputDisable
18:                          PLIB_OSC_ReferenceOutputIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOUTPUTENABLE_PIC32_2_H
49:                  #define _OSC_REFERENCEOUTPUTENABLE_PIC32_2_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOutputEnable_PIC32_2
53:                  
54:                    Summary:
55:                      Implements PIC32_2 variant of PLIB_OSC_ExistsReferenceOutputEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_2 variant of the PLIB_OSC_ExistsReferenceOutputEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOutputEnable PLIB_OSC_ExistsReferenceOutputEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOutputEnable_PIC32_2( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOutputEnable_PIC32_2
70:                  
71:                    Summary:
72:                      Implements PIC32_2 variant of PLIB_OSC_ReferenceOutputEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOutputEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOutputEnable_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      volatile uint32_t *reg = &REFO1CON + (referenceOsc * 0x08u) + 2u;
81:                  
82:                      *reg = _REFO1CON_OE_MASK;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  OSC_ReferenceOutputDisable_PIC32_2
88:                  
89:                    Summary:
90:                      Implements PIC32_2 variant of PLIB_OSC_ReferenceOutputDisable 
91:                  
92:                    Description:
93:                      This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOutputDisable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void OSC_ReferenceOutputDisable_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
97:                  {
98:                      volatile uint32_t *reg = &REFO1CON + (referenceOsc * 0x08u) + 1u;
99:                  
100:                     *reg = _REFO1CON_OE_MASK;
9D00A038  24041000   ADDIU A0, ZERO, 4096
9D00A03C  AC440004   SW A0, 4(V0)
9D00A044  AC440024   SW A0, 36(V0)
9D00A04C  AC440044   SW A0, 68(V0)
9D00A054  AC440064   SW A0, 100(V0)
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  OSC_ReferenceOutputIsEnabled_PIC32_2
106:                 
107:                   Summary:
108:                     Implements PIC32_2 variant of PLIB_OSC_ReferenceOutputIsEnabled 
109:                 
110:                   Description:
111:                     This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOutputIsEnabled function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE bool OSC_ReferenceOutputIsEnabled_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
115:                 {
116:                     volatile uint32_t *reg = &REFO1CON + (referenceOsc * 0x08u);
117:                 
118:                     return ( ((*reg) & _REFO1CON_OE_MASK ) ? true : false );
119:                 }
120:                 
121:                 
122:                 #endif /*_OSC_REFERENCEOUTPUTENABLE_PIC32_2_H*/
123:                 
124:                 /******************************************************************************
125:                  End of File
126:                 */
127:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_referenceoscenable_pic32_2.h  -
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscEnable_PIC32_2.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscEnable
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscEnable
16:                          PLIB_OSC_ReferenceOscEnable
17:                          PLIB_OSC_ReferenceOscDisable
18:                          PLIB_OSC_ReferenceOscIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOSCENABLE_PIC32_2_H
49:                  #define _OSC_REFERENCEOSCENABLE_PIC32_2_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOscEnable_PIC32_2
53:                  
54:                    Summary:
55:                      Implements PIC32_2 variant of PLIB_OSC_ExistsReferenceOscEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_2 variant of the PLIB_OSC_ExistsReferenceOscEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOscEnable PLIB_OSC_ExistsReferenceOscEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscEnable_PIC32_2( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOscEnable_PIC32_2
70:                  
71:                    Summary:
72:                      Implements PIC32_2 variant of PLIB_OSC_ReferenceOscEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOscEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOscEnable_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      volatile uint32_t *reg = &REFO1CON + (referenceOsc * 0x08u) + 2u;
81:                  
82:                      *reg = _REFO1CON_ON_MASK;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  OSC_ReferenceOscDisable_PIC32_2
88:                  
89:                    Summary:
90:                      Implements PIC32_2 variant of PLIB_OSC_ReferenceOscDisable 
91:                  
92:                    Description:
93:                      This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOscDisable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void OSC_ReferenceOscDisable_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
97:                  {
98:                      volatile uint32_t *reg = &REFO1CON + (referenceOsc * 0x08u) + 1u;
99:                  
100:                     *reg = _REFO1CON_ON_MASK;
9D00A02C  3C02BF80   LUI V0, -16512
9D00A030  24421280   ADDIU V0, V0, 4736
9D00A034  AC430004   SW V1, 4(V0)
9D00A040  AC430024   SW V1, 36(V0)
9D00A048  AC430044   SW V1, 68(V0)
9D00A050  AC430064   SW V1, 100(V0)
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  OSC_ReferenceOscIsEnabled_PIC32_2
106:                 
107:                   Summary:
108:                     Implements PIC32_2 variant of PLIB_OSC_ReferenceOscIsEnabled 
109:                 
110:                   Description:
111:                     This template implements the PIC32_2 variant of the PLIB_OSC_ReferenceOscIsEnabled function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE bool OSC_ReferenceOscIsEnabled_PIC32_2( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
115:                 {
116:                     volatile uint32_t *reg =  &REFO1CON + (referenceOsc * 0x08u);
117:                 
118:                     return ( ( *reg & _REFO1CON_ON_MASK ) ? true : false );
119:                 }
120:                 
121:                 
122:                 #endif /*_OSC_REFERENCEOSCENABLE_PIC32_2_H*/
123:                 
124:                 /******************************************************************************
125:                  End of File
126:                 */
127:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_pbclockoutputenable_default.h  
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockOutputEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockOutputEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockOutputEnable
16:                          PLIB_OSC_PBOutputClockEnable
17:                          PLIB_OSC_PBOutputClockDisable
18:                          PLIB_OSC_PBOutputClockIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_PBCLOCKOUTPUTENABLE_DEFAULT_H
49:                  #define _OSC_PBCLOCKOUTPUTENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsPBClockOutputEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OSC_ExistsPBClockOutputEnable
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OSC_ExistsPBClockOutputEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsPBClockOutputEnable PLIB_OSC_ExistsPBClockOutputEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsPBClockOutputEnable_Default( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_PBOutputClockEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_OSC_PBOutputClockEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_OSC_PBOutputClockEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_PBOutputClockEnable_Default( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
79:                  {
80:                      volatile uint32_t *reg = &PB2DIV + ((peripheralBusNumber - 1u) * 0x04u);
81:                  
82:                      if (peripheralBusNumber == OSC_PERIPHERAL_BUS_1)
83:                      {
84:                          PLIB_ASSERT(false, "Peripheral Bus 1 is always enabled by default");
85:                      }
86:                      else
87:                      {
88:                          *(reg + 2u) = _PB2DIV_ON_MASK;
9D009FBC  3C04BF80   LUI A0, -16512
9D009FC0  24841310   ADDIU A0, A0, 4880
9D009FC4  34038000   ORI V1, ZERO, -32768
9D009FC8  AC830008   SW V1, 8(A0)
9D009FDC  AC830018   SW V1, 24(A0)
9D009FF0  AC830028   SW V1, 40(A0)
9D00A004  AC830038   SW V1, 56(A0)
9D00A014  AC830058   SW V1, 88(A0)
9D00A028  AC830068   SW V1, 104(A0)
89:                      }
90:                  }
91:                  
92:                  
93:                  //******************************************************************************
94:                  /* Function :  OSC_PBOutputClockDisable_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_OSC_PBOutputClockDisable 
98:                  
99:                    Description:
100:                     This template implements the Default variant of the PLIB_OSC_PBOutputClockDisable function.
101:                 */
102:                 
103:                 PLIB_TEMPLATE void OSC_PBOutputClockDisable_Default( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
104:                 {
105:                     volatile uint32_t *reg = &PB2DIV + ((peripheralBusNumber - 1u) * 0x04u);
106:                 
107:                     if (peripheralBusNumber == OSC_PERIPHERAL_BUS_1)
108:                     {
109:                         PLIB_ASSERT(false, "Peripheral Bus 1 can not be disabled");
110:                     }
111:                     else
112:                     {
113:                         *(reg + 1u) = _PB2DIV_ON_MASK;
114:                     }
115:                     
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  OSC_PBOutputClockIsEnabled_Default
121:                 
122:                   Summary:
123:                     Implements Default variant of PLIB_OSC_PBOutputClockIsEnabled 
124:                 
125:                   Description:
126:                     This template implements the Default variant of the PLIB_OSC_PBOutputClockIsEnabled function.
127:                 */
128:                 
129:                 PLIB_TEMPLATE bool OSC_PBOutputClockIsEnabled_Default( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
130:                 {
131:                     volatile uint32_t *reg = &PB2DIV + ((peripheralBusNumber - 1u) * 0x04u);
132:                 
133:                     if (peripheralBusNumber == OSC_PERIPHERAL_BUS_1)
134:                     {
135:                         PLIB_ASSERT(false, "Peripheral Bus 1 is always enabled");
136:                         return true;
137:                     }
138:                     else
139:                     {
140:                         return ( (*reg & _PB2DIV_ON_MASK ) ? true : false );
141:                     }
142:                     
143:                 }
144:                 
145:                 
146:                 #endif /*_OSC_PBCLOCKOUTPUTENABLE_DEFAULT_H*/
147:                 
148:                 /******************************************************************************
149:                  End of File
150:                 */
151:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_pbclockdivisor_pic32_2.h  -----
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockDivisor_PIC32_2.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockDivisor
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockDivisor
16:                          PLIB_OSC_PBClockDivisorGet
17:                          PLIB_OSC_PBClockDivisorSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_PBCLOCKDIVISOR_PIC32_2_H
48:                  #define _OSC_PBCLOCKDIVISOR_PIC32_2_H
49:                  
50:                  // *****************************************************************************
51:                  /* Oscillator Peripheral Bus Clock Divisor Value Type
52:                  
53:                    Summary:
54:                      Type of the oscillator PB Clock divisor value.
55:                  
56:                    Description:
57:                      This macro defines the type of the oscillator PB Clock divisor value.
58:                  
59:                    Remarks:
60:                      None
61:                  */
62:                  
63:                  #define OSC_PB_CLOCK_DIV_TYPE						SFR_TYPE
64:                  
65:                  
66:                  // *****************************************************************************
67:                  /* Oscillator Peripheral Bus count
68:                  
69:                    Summary:
70:                      The number of Peripheral buses in available in the device.
71:                  
72:                    Description:
73:                      This macro gives the number of Peripheral buses in available in the device.
74:                  
75:                    Remarks:
76:                      None
77:                  */
78:                  
79:                  #define PERIPHERAL_BUSES_MAX						8
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  OSC_ExistsPBClockDivisor_PIC32_2
84:                  
85:                    Summary:
86:                      Implements PIC32_2 variant of PLIB_OSC_ExistsPBClockDivisor
87:                  
88:                    Description:
89:                      This template implements the PIC32_2 variant of the PLIB_OSC_ExistsPBClockDivisor function.
90:                  */
91:                  
92:                  #define PLIB_OSC_ExistsPBClockDivisor PLIB_OSC_ExistsPBClockDivisor
93:                  PLIB_TEMPLATE bool OSC_ExistsPBClockDivisor_PIC32_2( OSC_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  OSC_PBClockDivisorGet_PIC32_2
101:                 
102:                   Summary:
103:                     Implements PIC32_2 variant of PLIB_OSC_PBClockDivisorGet
104:                 
105:                   Description:
106:                     This template implements the PIC32_2 variant of the PLIB_OSC_PBClockDivisorGet function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE OSC_PB_CLOCK_DIV_TYPE OSC_PBClockDivisorGet_PIC32_2( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
110:                 {
111:                     volatile uint32_t *reg = &PB1DIV + (peripheralBusNumber * 0x04u);
112:                 
113:                     return (OSC_PB_CLOCK_DIV_TYPE)( ( (*reg & _PB1DIV_PBDIV_MASK ) >> _PB1DIV_PBDIV_POSITION ) + 1u );
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  OSC_PBClockDivisorSet_PIC32_2
119:                 
120:                   Summary:
121:                     Implements PIC32_2 variant of PLIB_OSC_PBClockDivisorSet
122:                 
123:                   Description:
124:                     This template implements the PIC32_2 variant of the PLIB_OSC_PBClockDivisorSet function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void OSC_PBClockDivisorSet_PIC32_2( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber , OSC_PB_CLOCK_DIV_TYPE peripheralBusClkDiv )
128:                 {
129:                     volatile uint32_t *reg = &PB1DIV + (peripheralBusNumber * 0x04u);
130:                 
131:                     *reg = ( *reg & (~_PB1DIV_PBDIV_MASK) ) | ( _PB1DIV_PBDIV_MASK & ((peripheralBusClkDiv - 1u) << _PB1DIV_PBDIV_POSITION) );
9D009F94  3C02BF80   LUI V0, -16512
9D009FCC  8C450020   LW A1, 32(V0)
9D009FD0  7C053004   INS A1, ZERO, 0, 7
9D009FD4  34A50002   ORI A1, A1, 2
9D009FD8  AC450020   SW A1, 32(V0)
9D009FE0  8C450030   LW A1, 48(V0)
9D009FE4  7C053004   INS A1, ZERO, 0, 7
9D009FE8  34A50001   ORI A1, A1, 1
9D009FEC  AC450030   SW A1, 48(V0)
9D009FF4  8C450040   LW A1, 64(V0)
9D009FF8  7C053004   INS A1, ZERO, 0, 7
9D009FFC  34A50007   ORI A1, A1, 7
9D00A000  AC450040   SW A1, 64(V0)
9D00A008  8C450060   LW A1, 96(V0)
9D00A00C  7C053004   INS A1, ZERO, 0, 7
9D00A010  AC450060   SW A1, 96(V0)
9D00A018  8C450070   LW A1, 112(V0)
9D00A01C  7C053004   INS A1, ZERO, 0, 7
9D00A020  34A50002   ORI A1, A1, 2
9D00A024  AC450070   SW A1, 112(V0)
132:                 }
133:                 
134:                 
135:                 #endif /*_OSC_PBCLOCKDIVISOR_PIC32_2_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_onwaitaction_default.h  -------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_OnWaitAction_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OnWaitAction
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsOnWaitAction
16:                          PLIB_OSC_OnWaitActionSet
17:                          PLIB_OSC_OnWaitActionGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_ONWAITACTION_DEFAULT_H
48:                  #define _OSC_ONWAITACTION_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsOnWaitAction_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsOnWaitAction
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsOnWaitAction function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsOnWaitAction PLIB_OSC_ExistsOnWaitAction
61:                  PLIB_TEMPLATE bool OSC_ExistsOnWaitAction_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_OnWaitActionSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_OnWaitActionSet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionSet function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_OnWaitActionSet_Default( OSC_MODULE_ID index , OSC_OPERATION_ON_WAIT onWait )
78:                  {
79:                      OSCCONbits.SLPEN = onWait;
00000018  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_OnWaitActionGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_OnWaitActionGet 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE OSC_OPERATION_ON_WAIT OSC_OnWaitActionGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      return (OSC_OPERATION_ON_WAIT)OSCCONbits.SLPEN;
96:                  }
97:                  
98:                  
99:                  #endif /*_OSC_ONWAITACTION_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/osc/templates/osc_frcdivisor_default.h  ---------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_FRCDivisor_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FRCDivisor
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsFRCDivisor
16:                          PLIB_OSC_FRCDivisorSelect
17:                          PLIB_OSC_FRCDivisorGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_FRCDIVISOR_DEFAULT_H
48:                  #define _OSC_FRCDIVISOR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsFRCDivisor_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsFRCDivisor
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsFRCDivisor function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsFRCDivisor PLIB_OSC_ExistsFRCDivisor
61:                  PLIB_TEMPLATE bool OSC_ExistsFRCDivisor_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_FRCDivisorSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_FRCDivisorSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_FRCDivisorSelect_Default( OSC_MODULE_ID index , OSC_FRC_DIV divisorFRC )
78:                  {
79:                      OSCCONbits.FRCDIV = divisorFRC;
9D009F84  3C02BF80   LUI V0, -16512
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_FRCDivisorGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_FRCDivisorGet
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE uint16_t OSC_FRCDivisorGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      uint16_t returnValue  = 0u;
96:                  
97:                      if ( OSCCONbits.FRCDIV != 7u )
98:                      {
99:                          returnValue = ( 1u << OSCCONbits.FRCDIV );
100:                     }
101:                     else
102:                     {
103:                         returnValue = 256u;
104:                     }
105:                 
106:                     return returnValue;
107:                 }
108:                 
109:                 
110:                 #endif /*_OSC_FRCDIVISOR_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_vectorselect_default.h  -------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsVectorSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
60:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_MultiVectorSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
73:                  */
74:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
75:                  {
76:                      INTCONSET = _INTCON_MVEC_MASK;
9D00CC2C  24031000   ADDIU V1, ZERO, 4096
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  INT_SingleVectorSelect_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_INT_SingleVectorSelect 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
87:                  */
88:                  PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
89:                  {
90:                      INTCONCLR = _INTCON_MVEC_MASK;
91:                  }
92:                  
93:                  #endif /*_INT_VECTORSELECT_DEFAULT_H*/
94:                  
95:                  /******************************************************************************
96:                   End of File
97:                  */
98:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_vectorpriority_default.h  -----
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Function :  INT_ExistsVectorPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
60:                  */
61:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
62:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_VectorPrioritySet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
75:                  
76:                    Note:
77:                      The algorithm to calculate and write the field location has changed to use
78:                      actual vector numbers. The enumeration for INT_VECTOR should now match the
79:                      names to the actual vector numbers.
80:                  */
81:                  PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
82:                  {
83:                      volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
84:                      uint32_t mask = 0x07 << ((vector & 0x03) * 8 + 2);
85:                      uint32_t position = (vector & 0x03) * 8 + 2;
86:                  
87:                      /* read-modify-write */
88:                      *IPCx &= ~mask;
9D004B9C  3C02BF81   LUI V0, -16511
9D004BA0  24420140   ADDIU V0, V0, 320
9D004BA4  8C430250   LW V1, 592(V0)
9D004BA8  7C03E684   INS V1, ZERO, 26, 3
9D004BAC  AC430250   SW V1, 592(V0)
9D005B54  3C02BF81   LUI V0, -16511
9D005B58  24420140   ADDIU V0, V0, 320
9D005B5C  8C4F01D0   LW T7, 464(V0)
9D005B60  7C0FE684   INS T7, ZERO, 26, 3
9D005B64  AC4F01D0   SW T7, 464(V0)
9D005C18  8C4C01E0   LW T4, 480(V0)
9D005C1C  7C0C6284   INS T4, ZERO, 10, 3
9D005C20  AC4C01E0   SW T4, 480(V0)
9D005DD0  3C02BF81   LUI V0, -16511
9D005E08  8C440240   LW A0, 576(V0)
9D005E38  8C440240   LW A0, 576(V0)
9D005E3C  7C046284   INS A0, ZERO, 10, 3
9D005E40  AC440240   SW A0, 576(V0)
9D005E64  8C4402B0   LW A0, 688(V0)
9D005E68  7C042084   INS A0, ZERO, 2, 3
9D005E6C  AC4402B0   SW A0, 688(V0)
9D005E94  8C4402A0   LW A0, 672(V0)
9D005E98  7C04E684   INS A0, ZERO, 26, 3
9D005E9C  AC4402A0   SW A0, 672(V0)
9D005EC8  8C4302A0   LW V1, 672(V0)
9D005ECC  7C03A484   INS V1, ZERO, 18, 3
9D005ED0  AC4302A0   SW V1, 672(V0)
9D005F00  8C430270   LW V1, 624(V0)
9D005F04  7C03E684   INS V1, ZERO, 26, 3
9D005F08  AC430270   SW V1, 624(V0)
9D005F30  8C430270   LW V1, 624(V0)
9D005F34  7C03A484   INS V1, ZERO, 18, 3
9D005F38  AC430270   SW V1, 624(V0)
9D005F60  8C430270   LW V1, 624(V0)
9D005F64  7C036284   INS V1, ZERO, 10, 3
9D005F68  AC430270   SW V1, 624(V0)
9D00B894  3C02BF81   LUI V0, -16511
9D00B898  24420140   ADDIU V0, V0, 320
9D00B89C  8C430010   LW V1, 16(V0)
9D00B8A0  7C032084   INS V1, ZERO, 2, 3
9D00B8A4  AC430010   SW V1, 16(V0)
89:                      *IPCx |= (priority << position) & mask;
9D004BB0  8C440250   LW A0, 592(V0)
9D004BB4  3C031800   LUI V1, 6144
9D004BB8  00831825   OR V1, A0, V1
9D004BBC  AC430250   SW V1, 592(V0)
9D005B68  8C5801D0   LW T8, 464(V0)
9D005B6C  3C0F0400   LUI T7, 1024
9D005B70  030F7825   OR T7, T8, T7
9D005B74  AC4F01D0   SW T7, 464(V0)
9D005C24  8C4C01E0   LW T4, 480(V0)
9D005C28  358C0400   ORI T4, T4, 1024
9D005C2C  AC4C01E0   SW T4, 480(V0)
9D005DE4  8C440240   LW A0, 576(V0)
9D005E14  8C450240   LW A1, 576(V0)
9D005E44  8C440240   LW A0, 576(V0)
9D005E48  34840400   ORI A0, A0, 1024
9D005E4C  AC440240   SW A0, 576(V0)
9D005E70  8C4402B0   LW A0, 688(V0)
9D005E74  34840014   ORI A0, A0, 20
9D005E78  AC4402B0   SW A0, 688(V0)
9D005EA0  8C4402A0   LW A0, 672(V0)
9D005EA4  00831825   OR V1, A0, V1
9D005EA8  AC4302A0   SW V1, 672(V0)
9D005ED4  8C4402A0   LW A0, 672(V0)
9D005ED8  3C030014   LUI V1, 20
9D005EDC  00831825   OR V1, A0, V1
9D005EE0  AC4302A0   SW V1, 672(V0)
9D005F0C  8C440270   LW A0, 624(V0)
9D005F10  3C030400   LUI V1, 1024
9D005F14  00831825   OR V1, A0, V1
9D005F18  AC430270   SW V1, 624(V0)
9D005F3C  8C440270   LW A0, 624(V0)
9D005F40  3C030010   LUI V1, 16
9D005F44  00831825   OR V1, A0, V1
9D005F48  AC430270   SW V1, 624(V0)
9D005F6C  8C430270   LW V1, 624(V0)
9D005F70  34631000   ORI V1, V1, 4096
9D005F74  AC430270   SW V1, 624(V0)
9D00B8A8  8C430010   LW V1, 16(V0)
9D00B8AC  34630018   ORI V1, V1, 24
9D00B8B0  AC430010   SW V1, 16(V0)
90:                  }
91:                  
92:                  //******************************************************************************
93:                  /* Function :  INT_VectorPriorityGet_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_INT_VectorPriorityGet 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
100:                 
101:                   Note:
102:                     The algorithm to calculate and write the field location has changed to use
103:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
104:                     names to the actual vector numbers.
105:                 */
106:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
107:                 {
108:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
109:                     uint32_t mask = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position = (((vector & 0x03) * 8) + 2);
111:                 
112:                     return (INT_PRIORITY_LEVEL) ((*IPCx & mask) >> position);
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  INT_VectorSubPrioritySet_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
123:                 
124:                   Note:
125:                     The algorithm to calculate and write the field location has changed to use
126:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
127:                     names to the actual vector numbers.
128:                 */
129:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
130:                 {
131:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
132:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
133:                     uint32_t position = (vector & 0x03) * 8;
134:                 
135:                     /* read-modify-write */
136:                     *IPCx &= ~mask; /* zeroed mask */
9D004BC0  8C430250   LW V1, 592(V0)
9D004BC4  7C03CE04   INS V1, ZERO, 24, 2
9D004BC8  AC430250   SW V1, 592(V0)
9D005B78  8C4F01D0   LW T7, 464(V0)
9D005B7C  7C0FCE04   INS T7, ZERO, 24, 2
9D005B80  AC4F01D0   SW T7, 464(V0)
9D005C30  8C4C01E0   LW T4, 480(V0)
9D005C34  7C0C4A04   INS T4, ZERO, 8, 2
9D005C38  AC4C01E0   SW T4, 480(V0)
9D005DF4  8C440240   LW A0, 576(V0)
9D005E24  8C440240   LW A0, 576(V0)
9D005E28  7C048C04   INS A0, ZERO, 16, 2
9D005E2C  AC440240   SW A0, 576(V0)
9D005E50  8C440240   LW A0, 576(V0)
9D005E54  7C044A04   INS A0, ZERO, 8, 2
9D005E58  AC440240   SW A0, 576(V0)
9D005E7C  8C4402B0   LW A0, 688(V0)
9D005E80  7C040804   INS A0, ZERO, 0, 2
9D005E84  AC4402B0   SW A0, 688(V0)
9D005EAC  8C4302A0   LW V1, 672(V0)
9D005EB0  7C03CE04   INS V1, ZERO, 24, 2
9D005EB4  AC4302A0   SW V1, 672(V0)
9D005EE4  8C4302A0   LW V1, 672(V0)
9D005EE8  7C038C04   INS V1, ZERO, 16, 2
9D005EEC  AC4302A0   SW V1, 672(V0)
9D005F1C  8C430270   LW V1, 624(V0)
9D005F20  7C03CE04   INS V1, ZERO, 24, 2
9D005F24  AC430270   SW V1, 624(V0)
9D005F4C  8C430270   LW V1, 624(V0)
9D005F50  7C038C04   INS V1, ZERO, 16, 2
9D005F54  AC430270   SW V1, 624(V0)
9D005F78  8C430270   LW V1, 624(V0)
9D005F7C  7C034A04   INS V1, ZERO, 8, 2
9D005F80  AC430270   SW V1, 624(V0)
9D00B8B4  8C430010   LW V1, 16(V0)
9D00B8B8  7C030804   INS V1, ZERO, 0, 2
9D00B8BC  AC430010   SW V1, 16(V0)
137:                     *IPCx |= (subPriority << position) & mask; /* set value */
9D004BCC  8C430250   LW V1, 592(V0)
9D005B84  8C4F01D0   LW T7, 464(V0)
9D005B88  AC4F01D0   SW T7, 464(V0)
9D005C3C  8C4C01E0   LW T4, 480(V0)
9D005C40  AC4C01E0   SW T4, 480(V0)
9D005E00  8C440240   LW A0, 576(V0)
9D005E30  8C440240   LW A0, 576(V0)
9D005E34  AC440240   SW A0, 576(V0)
9D005E5C  8C440240   LW A0, 576(V0)
9D005E60  AC440240   SW A0, 576(V0)
9D005E88  8C4402B0   LW A0, 688(V0)
9D005E8C  34840002   ORI A0, A0, 2
9D005E90  AC4402B0   SW A0, 688(V0)
9D005EB8  8C4402A0   LW A0, 672(V0)
9D005EBC  3C030100   LUI V1, 256
9D005EC0  00831825   OR V1, A0, V1
9D005EC4  AC4302A0   SW V1, 672(V0)
9D005EF0  8C4402A0   LW A0, 672(V0)
9D005EF4  3C030001   LUI V1, 1
9D005EF8  00831825   OR V1, A0, V1
9D005EFC  AC4302A0   SW V1, 672(V0)
9D005F28  8C430270   LW V1, 624(V0)
9D005F2C  AC430270   SW V1, 624(V0)
9D005F58  8C430270   LW V1, 624(V0)
9D005F5C  AC430270   SW V1, 624(V0)
9D005F84  8C430270   LW V1, 624(V0)
9D005F88  AC430270   SW V1, 624(V0)
9D00B8C0  8C430010   LW V1, 16(V0)
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  INT_VectorSubPriorityGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
148:                 
149:                   Note:
150:                     The algorithm to calculate and write the field location has changed to use
151:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
152:                     names to the actual vector numbers.
153:                 */
154:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
155:                 {
156:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
157:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
158:                     uint32_t position = (vector & 0x03) * 8;
159:                 
160:                     return (INT_SUBPRIORITY_LEVEL) ((*IPCx & mask) >> position);
161:                 }
162:                 
163:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
164:                 
165:                 /******************************************************************************
166:                  End of File
167:                 */
168:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_sourceflag_default.h  ---------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceFlag_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
61:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceFlagGet_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceFlagGet 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
9D00AC3C  00022942   SRL A1, V0, 5
9D00ACDC  00022942   SRL A1, V0, 5
9D00AD7C  00022942   SRL A1, V0, 5
82:                  
83:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
9D00AC44  3C03BF81   LUI V1, -16511
9D00ACE4  3C03BF81   LUI V1, -16511
9D00AD84  3C03BF81   LUI V1, -16511
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  INT_SourceFlagSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_INT_SourceFlagSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
94:                  
95:                    Note:
96:                      The source enum encoding is (x * 32) + y, where x is the register number 
97:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
98:                  */
99:                  PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
100:                 {
101:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
102:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
103:                 
104:                     *IFSxSET = 1 << (source & 0x1f);
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  INT_SourceFlagClear_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_INT_SourceFlagClear 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
115:                 
116:                   Note:
117:                     The source enum encoding is (x * 32) + y, where x is the register number 
118:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
119:                 */
120:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
121:                 {
122:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
9D0085F4  00042942   SRL A1, A0, 5
9D008618  00042942   SRL A1, A0, 5
9D008630  00063942   SRL A3, A2, 5
9D008634  00073900   SLL A3, A3, 4
9D008638  00671821   ADDU V1, V1, A3
9D00AC6C  00022142   SRL A0, V0, 5
9D00AD0C  00022142   SRL A0, V0, 5
9D00ADAC  00022142   SRL A0, V0, 5
9D00B00C  00023142   SRL A2, V0, 5
9D00B010  00063100   SLL A2, A2, 4
9D00B014  3C05BF81   LUI A1, -16511
9D00B018  24A50040   ADDIU A1, A1, 64
9D00B01C  00A63021   ADDU A2, A1, A2
9D00B030  00022142   SRL A0, V0, 5
9D00B034  00042100   SLL A0, A0, 4
9D00B038  00A42821   ADDU A1, A1, A0
123:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
124:                 
125:                     *IFSxCLR = 1 << (source & 0x1f);
9D0054B4  3C030080   LUI V1, 128
9D00572C  3C030100   LUI V1, 256
9D0059A4  3C030200   LUI V1, 512
9D005B38  3C0EBF81   LUI T6, -16511
9D005B3C  25CE0040   ADDIU T6, T6, 64
9D005B40  3C020080   LUI V0, 128
9D005B44  ADC20034   SW V0, 52(T6)
9D005C0C  3C0D0200   LUI T5, 512
9D005C10  ADCD0034   SW T5, 52(T6)
9D006350  24030010   ADDIU V1, ZERO, 16
9D0065B0  3C030080   LUI V1, 128
9D008608  24020001   ADDIU V0, ZERO, 1
9D008624  00822004   SLLV A0, V0, A0
9D00863C  00C23004   SLLV A2, V0, A2
9D008640  AC660004   SW A2, 4(V1)
9D00AC80  24040001   ADDIU A0, ZERO, 1
9D00AD20  24040001   ADDIU A0, ZERO, 1
9D00ADC0  24040001   ADDIU A0, ZERO, 1
9D00B020  24030001   ADDIU V1, ZERO, 1
9D00B024  00431004   SLLV V0, V1, V0
9D00B028  ACC20004   SW V0, 4(A2)
9D00B03C  00431004   SLLV V0, V1, V0
9D00C628  24020010   ADDIU V0, ZERO, 16
9D00C62C  3C03BF81   LUI V1, -16511
9D00C630  24630040   ADDIU V1, V1, 64
9D00C634  AC620004   SW V0, 4(V1)
00000024  00000000   NOP
00000124  00000000   NOP
126:                 }
127:                 
128:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_sourcecontrol_default.h  ------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
61:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceEnable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceEnable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceEnable function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IECx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D0001CC  00041942   SRL V1, A0, 5
9D008644  3C03BF81   LUI V1, -16511
9D008648  246300C0   ADDIU V1, V1, 192
9D00864C  00673821   ADDU A3, V1, A3
9D008654  00651821   ADDU V1, V1, A1
000000F0  00000000   NOP
000001D0  00000000   NOP
82:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
83:                  
84:                      *IECxSET = 1 << (source & 0x1f);
9D0001E0  24030001   ADDIU V1, ZERO, 1
9D004B8C  3C030080   LUI V1, 128
9D004B90  3C02BF81   LUI V0, -16511
9D004B94  244200C0   ADDIU V0, V0, 192
9D004B98  AC430048   SW V1, 72(V0)
9D005B48  3C0CBF81   LUI T4, -16511
9D005B4C  258C00C0   ADDIU T4, T4, 192
9D005B50  AD820038   SW V0, 56(T4)
9D005C14  AD8D0038   SW T5, 56(T4)
9D008650  ACE60008   SW A2, 8(A3)
9D008658  AC640008   SW A0, 8(V1)
9D00C638  3C03BF81   LUI V1, -16511
00000100  00000000   NOP
00000130  00000000   NOP
000001E4  00000000   NOP
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  INT_SourceDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_INT_SourceDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_INT_SourceDisable function.
95:                  
96:                    Note:
97:                      The source enum encoding is (x * 32) + y, where x is the register number
98:                      (IECx) and y is the bit position. 0b0xxy_yyyy
99:                  */
100:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
101:                 {
102:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
103:                     volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
104:                 
105:                     *IECxCLR = 1 << (source & 0x1f);
9D00BFAC  24060001   ADDIU A2, ZERO, 1
0000000C  00000000   NOP
106:                 }
107:                 
108:                 //******************************************************************************
109:                 /* Function :  INT_SourceIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
116:                 
117:                   Note:
118:                     The source enum encoding is (x * 32) + y, where x is the register number 
119:                     (IECx) and y is the bit position. 0b0xxy_yyyy
120:                 */
121:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
122:                 {
123:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D00B588  00022142   SRL A0, V0, 5
9D00B60C  00022142   SRL A0, V0, 5
9D00B9D0  00023142   SRL A2, V0, 5
9D00BF90  00041142   SRL V0, A0, 5
9D00BF94  00021100   SLL V0, V0, 4
9D00BF98  3C03BF81   LUI V1, -16511
9D00BF9C  246300C0   ADDIU V1, V1, 192
9D00BFA0  00621821   ADDU V1, V1, V0
124:                 
125:                     return (bool)((*IECx >> (source & 0x1f)) & 0x01);
9D00B590  3C03BF81   LUI V1, -16511
9D00B614  3C03BF81   LUI V1, -16511
9D00B9D8  3C05BF81   LUI A1, -16511
9D00BFA4  8C620000   LW V0, 0(V1)
9D00BFA8  3084001F   ANDI A0, A0, 31
9D00BFC0  00821006   SRLV V0, V0, A0
126:                 }
127:                 
128:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_externalintedgeselect_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_ExternalINTEdgeSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ExternalINTEdgeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsExternalINTEdgeSelect
16:                          PLIB_INT_ExternalRisingEdgeSelect
17:                          PLIB_INT_ExternalFallingEdgeSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_EXTERNALINTEDGESELECT_DEFAULT_H
48:                  #define _INT_EXTERNALINTEDGESELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsExternalINTEdgeSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsExternalINTEdgeSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsExternalINTEdgeSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsExternalINTEdgeSelect PLIB_INT_ExistsExternalINTEdgeSelect
60:                  PLIB_TEMPLATE bool INT_ExistsExternalINTEdgeSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_ExternalRisingEdgeSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_ExternalRisingEdgeSelect
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_ExternalRisingEdgeSelect function.
73:                  */
74:                  
75:                  PLIB_TEMPLATE void INT_ExternalRisingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
76:                  {
77:                      INTCONSET = source << _INTCON_INT0EP_POSITION;
0000000C  00000000   NOP
78:                  }
79:                  
80:                  //******************************************************************************
81:                  /* Function :  INT_ExternalFallingEdgeSelect_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_INT_ExternalFallingEdgeSelect
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_INT_ExternalFallingEdgeSelect function.
88:                  */
89:                  PLIB_TEMPLATE void INT_ExternalFallingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
90:                  {
91:                      INTCONCLR = source << _INTCON_INT0EP_POSITION;
0000001C  00000000   NOP
92:                  }
93:                  
94:                  #endif /*_INT_EXTERNALINTEDGESELECT_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/int/templates/int_enablecontrol_pic32.h  --------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  INT_ExistsEnableControl_PIC32
55:                  
56:                    Summary:
57:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
61:                  */
62:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
63:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_Enable_PIC32
70:                  
71:                    Summary:
72:                      Implements PIC32 variant of PLIB_INT_Enable 
73:                  
74:                    Description:
75:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
76:                  */
77:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
78:                  {
79:                      __builtin_mtc0(12, 0,(__builtin_mfc0(12, 0) | 0x0001));
9D009CE4  40026000   MFC0 V0, Status
9D009D1C  40026000   MFC0 V0, Status
9D009D20  34420001   ORI V0, V0, 1
9D009D24  40826000   MTC0 V0, Status
9D009D28  000000C0   EHB
9D00BE0C  40026000   MFC0 V0, Status
9D00C140  40026000   MFC0 V0, Status
80:                      
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  INT_Disable_PIC32
85:                  
86:                    Summary:
87:                      Implements PIC32 variant of PLIB_INT_Disable 
88:                  
89:                    Description:
90:                      This template implements the PIC32 variant of the PLIB_INT_Disable function.
91:                  */
92:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
93:                  {
94:                      __builtin_disable_interrupts();
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PLIB_INT_SetState_PIC32
99:                  
100:                   Summary:
101:                     Implements PIC32 variant of PLIB_INT_Enable 
102:                 
103:                   Description:
104:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
105:                 */
106:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
107:                 {
108:                     __builtin_mtc0(12, 0, interrupt_state);
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
113:                 
114:                   Summary:
115:                     Implements PIC32 variant of PLIB_INT_Disable 
116:                 
117:                   Description:
118:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
119:                 */
120:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
121:                 {
122:                     return (INT_STATE_GLOBAL)__builtin_disable_interrupts();
9D009CC0  41656000   DI A1
9D009CF4  41646000   DI A0
9D009CF8  000000C0   EHB
9D00BDD8  41636000   DI V1
9D00C11C  41626000   DI V0
123:                 }
124:                 
125:                 //******************************************************************************
126:                 /* Function :  INT_IsEnabled_PIC32
127:                 
128:                   Summary:
129:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
130:                 
131:                   Description:
132:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
133:                 */
134:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
135:                 {
136:                     return (bool)(_CP0_GET_STATUS() & 0x01);
137:                 }
138:                 
139:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
140:                 
141:                 /******************************************************************************
142:                  End of File
143:                 */
144:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/devcon/templates/devcon_traceoutput_default.h  --
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_TraceOutput_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TraceOutput
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_TraceOutputEnable
16:                          PLIB_DEVCON_TraceOutputDisable
17:                          PLIB_DEVCON_ExistsTraceOutput
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_TRACEOUTPUT_DEFAULT_H
48:                  #define _DEVCON_TRACEOUTPUT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_TraceOutputEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_DEVCON_TraceOutputEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputEnable function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_TraceOutputEnable_Default( DEVCON_MODULE_ID index )
61:                  {
62:                  	CFGCONbits.TROEN = 1;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_TraceOutputDisable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_DEVCON_TraceOutputDisable
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputDisable function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_TraceOutputDisable_Default( DEVCON_MODULE_ID index )
77:                  {
78:                  	CFGCONbits.TROEN = 0;
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsTraceOutput_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_DEVCON_ExistsTraceOutput
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_DEVCON_ExistsTraceOutput function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsTraceOutput PLIB_DEVCON_ExistsTraceOutput
93:                  PLIB_TEMPLATE bool DEVCON_ExistsTraceOutput_Default( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_TRACEOUTPUT_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/devcon/templates/devcon_syslockunlock_default.h  
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DEVCON_SystemUnlock_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
62:                  {	
63:                  	SYSKEY = 0x00000000;
9D00BDE0  3C02BF80   LUI V0, -16512
00000000  00000000   NOP
64:                  	SYSKEY = 0xAA996655;
9D00BDE8  3C04AA99   LUI A0, -21863
00000008  00000000   NOP
65:                  	SYSKEY = 0x556699AA;
9D00BDF4  3C045566   LUI A0, 21862
00000014  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemLock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemLock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                  	SYSKEY = 0x33333333;
9D00C124  3C043333   LUI A0, 13107
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  DEVCON_ExistsSystemLockUnlock_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
93:                  */
94:                  
95:                  #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
96:                  PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/devcon/templates/devcon_jtagenable_default.h  ---
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_JTAGEnable_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : JTAGEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_JTAGPortEnable
16:                          PLIB_DEVCON_JTAGPortDisable
17:                          PLIB_DEVCON_ExistsJTAGEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_JTAGENABLE_DEFAULT_H
48:                  #define _DEVCON_JTAGENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_JTAGPortEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_DEVCON_JTAGPortEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortEnable function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_JTAGPortEnable_Default( DEVCON_MODULE_ID index )
61:                  {
62:                      *((SFR_TYPE *)(&CFGCON)) |=  1u<< _CFGCON_JTAGEN_POSITION;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_JTAGPortDisable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_DEVCON_JTAGPortDisable
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortDisable function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_JTAGPortDisable_Default( DEVCON_MODULE_ID index )
77:                  {
78:                      *((SFR_TYPE *)(&CFGCON)) &= ~(1 << _CFGCON_JTAGEN_POSITION);
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsJTAGEnable_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_DEVCON_ExistsJTAGEnable
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_DEVCON_ExistsJTAGEnable function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsJTAGEnable PLIB_DEVCON_ExistsJTAGEnable
93:                  PLIB_TEMPLATE bool DEVCON_ExistsJTAGEnable_Default( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_JTAGENABLE_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/devcon/templates/devcon_deviceregslockunlock_pic32mz.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_DeviceRegsLockUnlock_PIC32MZ.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceRegsLockUnlock
13:                      and its Variant : PIC32MZ
14:                      For following APIs :
15:                          PLIB_DEVCON_DeviceRegistersLock
16:                          PLIB_DEVCON_DeviceRegistersUnlock
17:                          PLIB_DEVCON_ExistsDeviceRegsLockUnlock
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H
48:                  #define _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_DeviceRegistersLock_PIC32MZ
52:                  
53:                    Summary:
54:                      Implements PIC32MZ variant of PLIB_DEVCON_DeviceRegistersLock
55:                  
56:                    Description:
57:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_DeviceRegistersLock function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersLock_PIC32MZ( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
61:                  {
62:                  	*((SFR_TYPE *)(&CFGCON)) |= ((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK | _CFGCON_PGLOCK_MASK ) & (registersToLock << _CFGCON_PGLOCK_POSITION));
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_DeviceRegistersUnlock_PIC32MZ
68:                  
69:                    Summary:
70:                      Implements PIC32MZ variant of PLIB_DEVCON_DeviceRegistersUnlock
71:                  
72:                    Description:
73:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_DeviceRegistersUnlock function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersUnlock_PIC32MZ( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
77:                  {
78:                  	*((SFR_TYPE *)(&CFGCON)) &= ~((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK | _CFGCON_PGLOCK_MASK ) & (registersToLock << _CFGCON_PGLOCK_POSITION));
00000020  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsDeviceRegsLockUnlock_PIC32MZ
84:                  
85:                    Summary:
86:                      Implements PIC32MZ variant of PLIB_DEVCON_ExistsDeviceRegsLockUnlock
87:                  
88:                    Description:
89:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_ExistsDeviceRegsLockUnlock function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsDeviceRegsLockUnlock PLIB_DEVCON_ExistsDeviceRegsLockUnlock
93:                  PLIB_TEMPLATE bool DEVCON_ExistsDeviceRegsLockUnlock_PIC32MZ( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_transmitchannelflush_pic32.h  -
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_TransmitChannelFlush_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitChannelFlush
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_TransmitChannelFlush
16:                          PLIB_CAN_ExistsTransmitChannelFlush
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_TRANSMITCHANNELFLUSH_PIC32_H
47:                  #define _CAN_TRANSMITCHANNELFLUSH_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_TransmitChannelFlush_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_TransmitChannelFlush
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_TransmitChannelFlush function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_TransmitChannelFlush_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  
65:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than Maximum" );
66:                  
67:                      // Set the channel for transmit
68:                  	can->CFIFOREG[channel].CFIFOCON0SET = _C1FIFOCON0_TXREQ_MASK;
9D009C5C  24020008   ADDIU V0, ZERO, 8
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  CAN_ExistsTransmitChannelFlush_pic32
74:                  
75:                    Summary:
76:                      Implements pic32 variant of PLIB_CAN_ExistsTransmitChannelFlush
77:                  
78:                    Description:
79:                      This template implements the pic32 variant of the PLIB_CAN_ExistsTransmitChannelFlush function.
80:                  */
81:                  
82:                  #define PLIB_CAN_ExistsTransmitChannelFlush PLIB_CAN_ExistsTransmitChannelFlush
83:                  PLIB_TEMPLATE bool CAN_ExistsTransmitChannelFlush_pic32( CAN_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  
89:                  #endif /*_CAN_TRANSMITCHANNELFLUSH_PIC32_H*/
90:                  
91:                  /******************************************************************************
92:                   End of File
93:                  */
94:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_transmitbufferget_pic32.h  ----
1:                   
2:                   
3:                   /*******************************************************************************
4:                     CAN Peripheral Library Template Implementation
5:                   
6:                     File Name:
7:                       can_TransmitBufferGet_pic32.h
8:                   
9:                     Summary:
10:                      CAN PLIB Template Implementation
11:                  
12:                    Description:
13:                      This header file contains template implementations
14:                      For Feature : TransmitBufferGet
15:                      and its Variant : pic32
16:                      For following APIs :
17:                          PLIB_CAN_TransmitBufferGet
18:                          PLIB_CAN_ExistsTransmitBufferGet
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _CAN_TRANSMITBUFFERGET_PIC32_H
49:                  #define _CAN_TRANSMITBUFFERGET_PIC32_H
50:                  
51:                  #include "../templates/can_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  CAN_TransmitBufferGet_pic32
55:                  
56:                    Summary:
57:                      Implements pic32 variant of PLIB_CAN_TransmitBufferGet 
58:                  
59:                    Description:
60:                      This template implements the pic32 variant of the PLIB_CAN_TransmitBufferGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE CAN_TX_MSG_BUFFER * CAN_TransmitBufferGet_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel )
64:                  {
65:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
66:                  
67:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than Maximum" );
68:                  
69:                      /* Get address of FIFO from buffers */
70:                  	return (CAN_TX_MSG_BUFFER*) _PLIB_PhysToVirtK1(can->CFIFOREG[channel].CFIFOUA0);
9D009B7C  00041180   SLL V0, A0, 6
9D009B80  3C03BF88   LUI V1, -16504
9D009B84  00621021   ADDU V0, V1, V0
9D009B88  8C420370   LW V0, 880(V0)
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  CAN_ExistsTransmitBufferGet_pic32
76:                  
77:                    Summary:
78:                      Implements pic32 variant of PLIB_CAN_ExistsTransmitBufferGet
79:                  
80:                    Description:
81:                      This template implements the pic32 variant of the PLIB_CAN_ExistsTransmitBufferGet function.
82:                  */
83:                  
84:                  #define PLIB_CAN_ExistsTransmitBufferGet PLIB_CAN_ExistsTransmitBufferGet
85:                  PLIB_TEMPLATE bool CAN_ExistsTransmitBufferGet_pic32( CAN_MODULE_ID index )
86:                  {
87:                      return true;
88:                  }
89:                  
90:                  
91:                  #endif /*_CAN_TRANSMITBUFFERGET_PIC32_H*/
92:                  
93:                  /******************************************************************************
94:                   End of File
95:                  */
96:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_syncjumpwidth_default.h  ------
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_SyncJumpWidth_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SyncJumpWidth
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_SyncJumpWidthSet
16:                          PLIB_CAN_ExistsSyncJumpWidthSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_SYNCJUMPWIDTH_DEFAULT_H
47:                  #define _CAN_SYNCJUMPWIDTH_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_SyncJumpWidthSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_SyncJumpWidthSet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_SyncJumpWidthSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_SyncJumpWidthSet_Default( CAN_MODULE_ID index , CAN_TIME_SEGMENT_LENGTH length )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCFG.SJW = length;
9D0049B8  8C430010   LW V1, 16(V0)
9D0049BC  7C033984   INS V1, ZERO, 6, 2
9D0049C0  AC430010   SW V1, 16(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsSyncJumpWidthSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsSyncJumpWidthSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsSyncJumpWidthSet function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsSyncJumpWidthSet PLIB_CAN_ExistsSyncJumpWidthSet
79:                  PLIB_TEMPLATE bool CAN_ExistsSyncJumpWidthSet_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_SYNCJUMPWIDTH_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_receivedmessageget_pic32.h  ---
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ReceivedMessageGet_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedMessageGet
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_ReceivedMessageGet
16:                          PLIB_CAN_ExistsReceivedMessageGet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_RECEIVEDMESSAGEGET_PIC32_H
47:                  #define _CAN_RECEIVEDMESSAGEGET_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_ReceivedMessageGet_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_ReceivedMessageGet 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_ReceivedMessageGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE CAN_RX_MSG_BUFFER * CAN_ReceivedMessageGet_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	
65:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
66:                  
67:                      return ( (CAN_RX_MSG_BUFFER*) _PLIB_PhysToVirtK1(can->CFIFOREG[channel].CFIFOUA0));
9D003990  00101180   SLL V0, S0, 6
9D003994  00621021   ADDU V0, V1, V0
9D003998  8C420370   LW V0, 880(V0)
9D003A70  3C02BF88   LUI V0, -16504
9D003A74  8C4203B0   LW V0, 944(V0)
0000001C  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  CAN_ExistsReceivedMessageGet_pic32
73:                  
74:                    Summary:
75:                      Implements pic32 variant of PLIB_CAN_ExistsReceivedMessageGet
76:                  
77:                    Description:
78:                      This template implements the pic32 variant of the PLIB_CAN_ExistsReceivedMessageGet function.
79:                  */
80:                  
81:                  #define PLIB_CAN_ExistsReceivedMessageGet PLIB_CAN_ExistsReceivedMessageGet
82:                  PLIB_TEMPLATE bool CAN_ExistsReceivedMessageGet_pic32( CAN_MODULE_ID index )
83:                  {
84:                      return true;
85:                  }
86:                  
87:                  
88:                  #endif /*_CAN_RECEIVEDMESSAGEGET_PIC32_H*/
89:                  
90:                  /******************************************************************************
91:                   End of File
92:                  */
93:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_propagationtimesegment_default.h
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_PropagationTimeSegment_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PropagationTimeSegment
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_PropagationTimeSegmentSet
16:                          PLIB_CAN_ExistsPropagationTimeSegment
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_PROPAGATIONTIMESEGMENT_DEFAULT_H
47:                  #define _CAN_PROPAGATIONTIMESEGMENT_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_PropagationTimeSegmentSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_PropagationTimeSegmentSet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_PropagationTimeSegmentSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_PropagationTimeSegmentSet_Default( CAN_MODULE_ID index , CAN_TIME_SEGMENT_LENGTH length )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCFG.PRSEG = length;
9D004990  8C440010   LW A0, 16(V0)
9D004994  24030007   ADDIU V1, ZERO, 7
9D004998  7C645204   INS A0, V1, 8, 3
9D00499C  AC440010   SW A0, 16(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsPropagationTimeSegment_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsPropagationTimeSegment
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsPropagationTimeSegment function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsPropagationTimeSegment PLIB_CAN_ExistsPropagationTimeSegment
79:                  PLIB_TEMPLATE bool CAN_ExistsPropagationTimeSegment_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_PROPAGATIONTIMESEGMENT_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_phasesegment2lengthfreelyprogrammable_default.h
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_PhaseSegment2LengthFreelyProgrammable_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PhaseSegment2LengthFreelyProgrammable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_PhaseSegment2LengthFreelyProgrammableEnable
16:                          PLIB_CAN_PhaseSegment2LengthFreelyProgrammableDisable
17:                          PLIB_CAN_ExistsPhaseSegment2LengthFreelyProgrammable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _CAN_PHASESEGMENT2LENGTHFREELYPROGRAMMABLE_DEFAULT_H
48:                  #define _CAN_PHASESEGMENT2LENGTHFREELYPROGRAMMABLE_DEFAULT_H
49:                  
50:                  #include "../templates/can_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  CAN_PhaseSegment2LengthFreelyProgrammableEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_CAN_PhaseSegment2LengthFreelyProgrammableEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_CAN_PhaseSegment2LengthFreelyProgrammableEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void CAN_PhaseSegment2LengthFreelyProgrammableEnable_Default( CAN_MODULE_ID index )
63:                  {
64:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
65:                  	can->CCFGSET = _C1CFG_SEG2PHTS_MASK;
9D004988  34038000   ORI V1, ZERO, -32768
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  CAN_PhaseSegment2LengthFreelyProgrammableDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_CAN_PhaseSegment2LengthFreelyProgrammableDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_CAN_PhaseSegment2LengthFreelyProgrammableDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void CAN_PhaseSegment2LengthFreelyProgrammableDisable_Default( CAN_MODULE_ID index )
80:                  {
81:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
82:                  	can->CCFGCLR = _C1CFG_SEG2PHTS_MASK;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  CAN_ExistsPhaseSegment2LengthFreelyProgrammable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_CAN_ExistsPhaseSegment2LengthFreelyProgrammable
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_CAN_ExistsPhaseSegment2LengthFreelyProgrammable function.
94:                  */
95:                  
96:                  #define PLIB_CAN_ExistsPhaseSegment2LengthFreelyProgrammable PLIB_CAN_ExistsPhaseSegment2LengthFreelyProgrammable
97:                  PLIB_TEMPLATE bool CAN_ExistsPhaseSegment2LengthFreelyProgrammable_Default( CAN_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_CAN_PHASESEGMENT2LENGTHFREELYPROGRAMMABLE_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_phasesegment2length_default.h  
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_PhaseSegment2Length_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PhaseSegment2Length
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_PhaseSegment2LengthSet
16:                          PLIB_CAN_ExistsPhaseSegment2Length
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_PHASESEGMENT2LENGTH_DEFAULT_H
47:                  #define _CAN_PHASESEGMENT2LENGTH_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_PhaseSegment2LengthSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_PhaseSegment2LengthSet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_PhaseSegment2LengthSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_PhaseSegment2LengthSet_Default( CAN_MODULE_ID index , CAN_TIME_SEGMENT_LENGTH length )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCFG.SEG2PH = length;
9D0049AC  8C440010   LW A0, 16(V0)
9D0049B0  7C649404   INS A0, V1, 16, 3
9D0049B4  AC440010   SW A0, 16(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsPhaseSegment2Length_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsPhaseSegment2Length
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsPhaseSegment2Length function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsPhaseSegment2Length PLIB_CAN_ExistsPhaseSegment2Length
79:                  PLIB_TEMPLATE bool CAN_ExistsPhaseSegment2Length_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_PHASESEGMENT2LENGTH_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_phasesegment1length_default.h  
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_PhaseSegment1Length_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PhaseSegment1Length
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_PhaseSegment1LengthSet
16:                          PLIB_CAN_ExistsPhaseSegment1Length
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_PHASESEGMENT1LENGTH_DEFAULT_H
47:                  #define _CAN_PHASESEGMENT1LENGTH_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_PhaseSegment1LengthSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_PhaseSegment1LengthSet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_PhaseSegment1LengthSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_PhaseSegment1LengthSet_Default( CAN_MODULE_ID index , CAN_TIME_SEGMENT_LENGTH length )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCFG.SEG1PH = length;
9D0049A0  8C440010   LW A0, 16(V0)
9D0049A4  7C646AC4   INS A0, V1, 11, 3
9D0049A8  AC440010   SW A0, 16(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsPhaseSegment1Length_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsPhaseSegment1Length
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsPhaseSegment1Length function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsPhaseSegment1Length PLIB_CAN_ExistsPhaseSegment1Length
79:                  PLIB_TEMPLATE bool CAN_ExistsPhaseSegment1Length_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_PHASESEGMENT1LENGTH_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_operationmodeset_default.h  ---
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_OperationModeSet_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OperationModeSet
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_OperationModeSelect
16:                          PLIB_CAN_ExistsOperationModeWrite
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_OPERATIONMODESET_DEFAULT_H
47:                  #define _CAN_OPERATIONMODESET_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_OperationModeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_OperationModeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_OperationModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_OperationModeSelect_Default( CAN_MODULE_ID index , CAN_OPERATION_MODES opMode )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCON.REQOP = opMode;
9D004960  8C430000   LW V1, 0(V0)
9D004B58  8C430000   LW V1, 0(V0)
9D004B5C  7C03D604   INS V1, ZERO, 24, 3
9D004B60  AC430000   SW V1, 0(V0)
00000000  00000000   NOP
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsOperationModeWrite_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsOperationModeWrite
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsOperationModeWrite function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsOperationModeWrite PLIB_CAN_ExistsOperationModeWrite
79:                  PLIB_TEMPLATE bool CAN_ExistsOperationModeWrite_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_OPERATIONMODESET_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_operationmoderead_default.h  --
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_OperationModeRead_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OperationModeRead
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_OperationModeGet
16:                          PLIB_CAN_ExistsOperationModeRead
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_OPERATIONMODEREAD_DEFAULT_H
47:                  #define _CAN_OPERATIONMODEREAD_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_OperationModeGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_OperationModeGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_OperationModeGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE CAN_OPERATION_MODES CAN_OperationModeGet_Default( CAN_MODULE_ID index )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	return (CAN_OPERATION_MODES) can->CCON.OPMOD;
9D004970  3C04BF88   LUI A0, -16504
9D004978  8C820000   LW V0, 0(A0)
9D00497C  7C421540   EXT V0, V0, 21, 3
9D004B64  3C03BF88   LUI V1, -16504
9D004B68  8C620000   LW V0, 0(V1)
9D004B6C  7C421540   EXT V0, V0, 21, 3
00000014  00000000   NOP
0000001C  00000000   NOP
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsOperationModeRead_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsOperationModeRead
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsOperationModeRead function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsOperationModeRead PLIB_CAN_ExistsOperationModeRead
79:                  PLIB_TEMPLATE bool CAN_ExistsOperationModeRead_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_OPERATIONMODEREAD_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_moduleeventenable_default.h  --
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ModuleEventEnable_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModuleEventEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_ModuleEventEnable
16:                          PLIB_CAN_ModuleEventDisable
17:                          PLIB_CAN_ExistsModuleEventEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _CAN_MODULEEVENTENABLE_DEFAULT_H
48:                  #define _CAN_MODULEEVENTENABLE_DEFAULT_H
49:                  
50:                  #include "../templates/can_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  CAN_ModuleEventEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_CAN_ModuleEventEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_CAN_ModuleEventEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void CAN_ModuleEventEnable_Default( CAN_MODULE_ID index , CAN_MODULE_EVENT flags )
63:                  {
64:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
65:                  	uint32_t mask =  CAN_All_EVENTS << _C1INT_TBIE_POSITION;
66:                  	can->CINTSET = ( (can->CINT.w & ~(mask)) | ( (mask) & ((flags) << _C1INT_TBIE_POSITION)) );
9D004B78  8C440020   LW A0, 32(V0)
9D004B7C  3C0307F0   LUI V1, 2032
9D004B80  3463FFFF   ORI V1, V1, -1
9D004B84  00831824   AND V1, A0, V1
9D004B88  AC430028   SW V1, 40(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  CAN_ModuleEventDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_CAN_ModuleEventDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_CAN_ModuleEventDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void CAN_ModuleEventDisable_Default( CAN_MODULE_ID index , CAN_MODULE_EVENT flags )
81:                  {
82:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
83:                  	can->CINTCLR =  ((flags) << _C1INT_TBIE_POSITION);
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  CAN_ExistsModuleEventEnable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_CAN_ExistsModuleEventEnable
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_CAN_ExistsModuleEventEnable function.
95:                  */
96:                  
97:                  #define PLIB_CAN_ExistsModuleEventEnable PLIB_CAN_ExistsModuleEventEnable
98:                  PLIB_TEMPLATE bool CAN_ExistsModuleEventEnable_Default( CAN_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_CAN_MODULEEVENTENABLE_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_memorybufferassign_default.h  -
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_MemoryBufferAssign_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MemoryBufferAssign
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_MemoryBufferAssign
16:                          PLIB_CAN_ExistsMemoryBufferAssign
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_MEMORYBUFFERASSIGN_DEFAULT_H
47:                  #define _CAN_MEMORYBUFFERASSIGN_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_MemoryBufferAssign_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_MemoryBufferAssign 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_MemoryBufferAssign function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_MemoryBufferAssign_Default( CAN_MODULE_ID index , void * buffer )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CFIFOBA = _PLIB_VirtToPhys(buffer);
9D0049F0  3C02BF88   LUI V0, -16504
9D0049F4  AC430340   SW V1, 832(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsMemoryBufferAssign_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsMemoryBufferAssign
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsMemoryBufferAssign function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsMemoryBufferAssign PLIB_CAN_ExistsMemoryBufferAssign
79:                  PLIB_TEMPLATE bool CAN_ExistsMemoryBufferAssign_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_MEMORYBUFFERASSIGN_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_filtertochannellink_pic32.h  --
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_FilterToChannelLink_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FilterToChannelLink
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_FilterToChannelLink
16:                          PLIB_CAN_ExistsFilterToChannelLink
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_FILTERTOCHANNELLINK_PIC32_H
47:                  #define _CAN_FILTERTOCHANNELLINK_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_FilterToChannelLink_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_FilterToChannelLink 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_FilterToChannelLink function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_FilterToChannelLink_pic32( CAN_MODULE_ID index , CAN_FILTER filter , CAN_FILTER_MASK mask , CAN_CHANNEL channel )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                      
65:                      /* There are 32 filters in total and 8 H/W registers having 4 filters each */
66:                  
67:                      /* This function will link a filter to a channel. FLTCONx is the filter
68:                        control register that is associated with the filter and sub offset
69:                        provides the shift amount with in the filter control register. The
70:                        filter control register has four bytes each controlling a filter.
71:                        The contents of the other filter fields should not be changed. */
72:                  
73:                      uint32_t filterRegIndex = filter >> 2;
74:                      uint32_t filterOffSet = filter % 4;
75:                      uint32_t filterRegValue = 0;
76:                      uint32_t filterRegMask = 0;
77:                      uint32_t maskSelPosition = 0, filterSelPosition = 0;
78:                      
79:                      filterRegMask = ( (_C1FLTCON0_MSEL0_MASK | _C1FLTCON0_FSEL0_MASK) << (filterOffSet * 8) );
80:                      maskSelPosition = ( _C1FLTCON0_MSEL0_POSITION + (filterOffSet * 8) );
81:                      filterSelPosition = ( _C1FLTCON0_FSEL0_POSITION + (filterOffSet * 8) );
82:                      
83:                      /* Get the value of the filter register containing the selected filter */ 
84:                      filterRegValue = can->CFLTCON[filterRegIndex].CFLTCON0.w;
9D004A40  8C4500C0   LW A1, 192(V0)
9D004A8C  8C4700C0   LW A3, 192(V0)
9D004AB4  8C4300C0   LW V1, 192(V0)
85:                      /* Clear the selected filter FSEL and MSEL fields initially */
86:                      filterRegValue &= (~filterRegMask);
9D004A44  7C053004   INS A1, ZERO, 0, 7
9D004A90  7C077204   INS A3, ZERO, 8, 7
9D004AB8  7C03B404   INS V1, ZERO, 16, 7
87:                      /* Write selected FSEL and MSEL values for the filter */
88:                      filterRegValue |= ( ((mask << maskSelPosition) | (channel << filterSelPosition)) & filterRegMask );
9D004A48  34A50001   ORI A1, A1, 1
9D004A94  34E72300   ORI A3, A3, 8960
9D004ABC  3C060044   LUI A2, 68
9D004AC0  00661825   OR V1, V1, A2
89:                  
90:                      /* Finally write the 32-bit filter register value that updates only
91:                       * FSEL and MSEL of the selected filter */
92:                  	can->CFLTCON[filterRegIndex].CFLTCON0.w = filterRegValue;
9D004A4C  AC4500C0   SW A1, 192(V0)
9D004A98  AC4700C0   SW A3, 192(V0)
9D004AC4  AC4300C0   SW V1, 192(V0)
93:                  }
94:                  
95:                  
96:                  //******************************************************************************
97:                  /* Function :  CAN_ExistsFilterToChannelLink_pic32
98:                  
99:                    Summary:
100:                     Implements pic32 variant of PLIB_CAN_ExistsFilterToChannelLink
101:                 
102:                   Description:
103:                     This template implements the pic32 variant of the PLIB_CAN_ExistsFilterToChannelLink function.
104:                 */
105:                 
106:                 #define PLIB_CAN_ExistsFilterToChannelLink PLIB_CAN_ExistsFilterToChannelLink
107:                 PLIB_TEMPLATE bool CAN_ExistsFilterToChannelLink_pic32( CAN_MODULE_ID index )
108:                 {
109:                     return true;
110:                 }
111:                 
112:                 
113:                 #endif /*_CAN_FILTERTOCHANNELLINK_PIC32_H*/
114:                 
115:                 /******************************************************************************
116:                  End of File
117:                 */
118:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_filtermaskconfigure_pic32.h  --
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_FilterMaskConfigure_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FilterMaskConfigure
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_FilterMaskConfigure
16:                          PLIB_CAN_ExistsFilterMaskConfigure
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_FILTERMASKCONFIGURE_PIC32_H
47:                  #define _CAN_FILTERMASKCONFIGURE_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_FilterMaskConfigure_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_FilterMaskConfigure 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_FilterMaskConfigure function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_FilterMaskConfigure_pic32( CAN_MODULE_ID index , CAN_FILTER_MASK mask , uint32_t maskbits , CAN_ID_TYPE idType , CAN_FILTER_MASK_TYPE mide )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                      unsigned int sid;
65:                      unsigned int eid;
66:                  
67:                      if(idType == CAN_EID)
68:                      {
69:                              /* Extract the sid and eid from the specified id and assign these to
70:                           the register fields. */
71:                          maskbits &= 0x1FFFFFFFu;
72:                          sid = (maskbits & 0x1FFC0000u) >> 18u;
73:                          eid = maskbits & 0x3FFFFu;
74:                  		
75:                  		can->CRXM[mask].CRXM0.EID = eid;
76:                  		can->CRXM[mask].CRXM0.SID = sid;
77:                      }
78:                      else if(idType == CAN_SID)
79:                      {
80:                          maskbits &= 0x7FFu;
81:                  		can->CRXM[mask].CRXM0.SID = maskbits;
9D004B20  8C440080   LW A0, 128(V0)
9D004B24  240507F0   ADDIU A1, ZERO, 2032
9D004B28  7CA4FD44   INS A0, A1, 21, 11
9D004B2C  AC440080   SW A0, 128(V0)
9D004B34  8C440090   LW A0, 144(V0)
9D004B38  7CA4FD44   INS A0, A1, 21, 11
9D004B3C  AC440090   SW A0, 144(V0)
9D004B44  8C4400A0   LW A0, 160(V0)
9D004B48  240507E0   ADDIU A1, ZERO, 2016
9D004B4C  7CA4FD44   INS A0, A1, 21, 11
9D004B50  AC4400A0   SW A0, 160(V0)
82:                      }
83:                      else
84:                      {
85:                          /*...*/
86:                      }
87:                      if(mide == CAN_FILTER_MASK_IDE_TYPE)
88:                      {
89:                          /* This means masking will also compare the message type */
90:                  		can->CRXM[mask].CRXM0SET = _C1RXM0_MIDE_MASK;
9D004B30  AC430088   SW V1, 136(V0)
9D004B40  AC430098   SW V1, 152(V0)
9D004B54  AC4300A8   SW V1, 168(V0)
91:                      }
92:                      else if(mide == CAN_FILTER_MASK_ANY_TYPE)
93:                      {
94:                          /* This means any message is masked */
95:                  		can->CRXM[mask].CRXM0CLR = _C1RXM0_MIDE_MASK;
96:                      }
97:                      else
98:                      {
99:                          /*...*/
100:                     }
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  CAN_ExistsFilterMaskConfigure_pic32
106:                 
107:                   Summary:
108:                     Implements pic32 variant of PLIB_CAN_ExistsFilterMaskConfigure
109:                 
110:                   Description:
111:                     This template implements the pic32 variant of the PLIB_CAN_ExistsFilterMaskConfigure function.
112:                 */
113:                 
114:                 #define PLIB_CAN_ExistsFilterMaskConfigure PLIB_CAN_ExistsFilterMaskConfigure
115:                 PLIB_TEMPLATE bool CAN_ExistsFilterMaskConfigure_pic32( CAN_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_CAN_FILTERMASKCONFIGURE_PIC32_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_filterenable_pic32.h  ---------
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_FilterEnable_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FilterEnable
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_FilterEnable
16:                          PLIB_CAN_FilterDisable
17:                          PLIB_CAN_FilterIsDisabled
18:                          PLIB_CAN_ExistsFilterEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _CAN_FILTERENABLE_PIC32_H
49:                  #define _CAN_FILTERENABLE_PIC32_H
50:                  
51:                  #include "../templates/can_registers.h"
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  CAN_FilterEnable_pic32
56:                  
57:                    Summary:
58:                      Implements pic32 variant of PLIB_CAN_FilterEnable 
59:                  
60:                    Description:
61:                      This template implements the pic32 variant of the PLIB_CAN_FilterEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void CAN_FilterEnable_pic32( CAN_MODULE_ID index , CAN_FILTER filter )
65:                  {
66:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
67:                  	unsigned char 	regIndex = filter/4;
68:                      unsigned char 	regOffSET = filter%4;
69:                  
70:                      PLIB_ASSERT( (filter  <= CAN_FILTER31),   "Filter number more than Maximum" );
71:                  
72:                  	can->CFLTCON[regIndex].CFLTCON0SET = (1u << (_C1FLTCON0_FLTEN0_POSITION + (regOffSET*8u)));
9D004AE4  AC4400C8   SW A0, 200(V0)
9D004AFC  34048000   ORI A0, ZERO, -32768
9D004B00  AC4400C8   SW A0, 200(V0)
9D004B18  3C040080   LUI A0, 128
9D004B1C  AC4400C8   SW A0, 200(V0)
73:                  }
74:                  
75:                  
76:                  //******************************************************************************
77:                  /* Function :  CAN_FilterDisable_pic32
78:                  
79:                    Summary:
80:                      Implements pic32 variant of PLIB_CAN_FilterDisable 
81:                  
82:                    Description:
83:                      This template implements the pic32 variant of the PLIB_CAN_FilterDisable function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void CAN_FilterDisable_pic32( CAN_MODULE_ID index , CAN_FILTER filter )
87:                  {
88:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
89:                  	unsigned char 	regIndex = filter/4;
90:                      unsigned char 	regOffSET = filter%4;
91:                      
92:                      PLIB_ASSERT( (filter  <= CAN_FILTER31),   "Filter number more than Maximum" );
93:                  
94:                  	can->CFLTCON[regIndex].CFLTCON0CLR = (1u << (_C1FLTCON0_FLTEN0_POSITION + (regOffSET*8u)));
95:                  }
96:                  
97:                  
98:                  //******************************************************************************
99:                  /* Function :  CAN_FilterIsDisabled_pic32
100:                 
101:                   Summary:
102:                     Implements pic32 variant of PLIB_CAN_FilterIsDisabled 
103:                 
104:                   Description:
105:                     This template implements the pic32 variant of the PLIB_CAN_FilterIsDisabled function.
106:                 */
107:                 
108:                 PLIB_TEMPLATE bool CAN_FilterIsDisabled_pic32( CAN_MODULE_ID index , CAN_FILTER filter )
109:                 {
110:                 	volatile can_registers_t * can = ((can_registers_t *)(index));
111:                 	unsigned char 	regIndex = filter/4;
112:                     unsigned char 	regOffSET = filter%4u;
113:                 
114:                     PLIB_ASSERT( (filter  <= CAN_FILTER31),   "Filter number more than Maximum" );
115:                     
116:                 	return (bool)!(can->CFLTCON[regIndex].CFLTCON0.w & (1u << (_C1FLTCON0_FLTEN0_POSITION + (regOffSET*8u))) ? true : false);
117:                 }
118:                 
119:                 
120:                 //******************************************************************************
121:                 /* Function :  CAN_ExistsFilterEnable_pic32
122:                 
123:                   Summary:
124:                     Implements pic32 variant of PLIB_CAN_ExistsFilterEnable
125:                 
126:                   Description:
127:                     This template implements the pic32 variant of the PLIB_CAN_ExistsFilterEnable function.
128:                 */
129:                 
130:                 #define PLIB_CAN_ExistsFilterEnable PLIB_CAN_ExistsFilterEnable
131:                 PLIB_TEMPLATE bool CAN_ExistsFilterEnable_pic32( CAN_MODULE_ID index )
132:                 {
133:                     return true;
134:                 }
135:                 
136:                 
137:                 #endif /*_CAN_FILTERENABLE_PIC32_H*/
138:                 
139:                 /******************************************************************************
140:                  End of File
141:                 */
142:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_filterconfigure_pic32.h  ------
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_FilterConfigure_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FilterConfigure
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_FilterConfigure
16:                          PLIB_CAN_ExistsFilterConfigure
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_FILTERCONFIGURE_PIC32_H
47:                  #define _CAN_FILTERCONFIGURE_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_FilterConfigure_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_FilterConfigure 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_FilterConfigure function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_FilterConfigure_pic32( CAN_MODULE_ID index , CAN_FILTER filter , uint32_t id , CAN_ID_TYPE filterType )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                      unsigned int sid;
65:                      unsigned int eid;
66:                      PLIB_ASSERT( (filter  <= CAN_FILTER31),   "Filter number more than Maximum" );
67:                  
68:                      if(filterType == CAN_EID)
69:                      {
70:                          /* An extended ID filter has a 29 bit id. The most significant 11 bits are the SID
71:                            and the rest of the 18 bits are EID. */
72:                          id &= 0x1FFFFFFFu;
73:                          sid = (id & 0x1FFC0000u) >> 18u;
74:                          eid = id & 0x3FFFFu;
75:                  
76:                  		can->CRXF[filter].CRXF1.EID = eid;
77:                  		can->CRXF[filter].CRXF1.SID = sid;
78:                  		can->CRXF[filter].CRXF1SET = _C1RXF0_EXID_MASK;
79:                      }
80:                      else
81:                      {
82:                          /* An standard ID has 11 bits. */
83:                          id &= 0x7FFu;
84:                  		can->CRXF[filter].CRXF1.SID = id;
9D004ACC  8C430140   LW V1, 320(V0)
9D004AD0  240505F0   ADDIU A1, ZERO, 1520
9D004AD4  7CA3FD44   INS V1, A1, 21, 11
9D004AD8  AC430140   SW V1, 320(V0)
9D004AE8  8C440150   LW A0, 336(V0)
9D004AEC  24050144   ADDIU A1, ZERO, 324
9D004AF0  7CA4FD44   INS A0, A1, 21, 11
9D004AF4  AC440150   SW A0, 336(V0)
9D004B04  8C440160   LW A0, 352(V0)
9D004B08  240507C0   ADDIU A1, ZERO, 1984
9D004B0C  7CA4FD44   INS A0, A1, 21, 11
9D004B10  AC440160   SW A0, 352(V0)
85:                  		can->CRXF[filter].CRXF1CLR = _C1RXF0_EXID_MASK;
9D004ADC  3C030008   LUI V1, 8
9D004AE0  AC430144   SW V1, 324(V0)
9D004AF8  AC430154   SW V1, 340(V0)
9D004B14  AC430164   SW V1, 356(V0)
86:                      }
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  CAN_ExistsFilterConfigure_pic32
92:                  
93:                    Summary:
94:                      Implements pic32 variant of PLIB_CAN_ExistsFilterConfigure
95:                  
96:                    Description:
97:                      This template implements the pic32 variant of the PLIB_CAN_ExistsFilterConfigure function.
98:                  */
99:                  
100:                 #define PLIB_CAN_ExistsFilterConfigure PLIB_CAN_ExistsFilterConfigure
101:                 PLIB_TEMPLATE bool CAN_ExistsFilterConfigure_pic32( CAN_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_CAN_FILTERCONFIGURE_PIC32_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_enablecontrol_default.h  ------
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_Enable
16:                          PLIB_CAN_Disable
17:                          PLIB_CAN_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _CAN_ENABLECONTROL_DEFAULT_H
48:                  #define _CAN_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "../templates/can_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  CAN_Enable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_CAN_Enable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_CAN_Enable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void CAN_Enable_Default( CAN_MODULE_ID index )
64:                  {
65:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
66:                  	can->CCON.ON = 1;
9D00494C  3C02BF88   LUI V0, -16504
9D004950  8C430000   LW V1, 0(V0)
9D004954  24040001   ADDIU A0, ZERO, 1
9D004958  7C837BC4   INS V1, A0, 15, 1
9D00495C  AC430000   SW V1, 0(V0)
9D00CB1C  3C02BF88   LUI V0, -16504
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  CAN_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_CAN_Disable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_CAN_Disable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void CAN_Disable_Default( CAN_MODULE_ID index )
81:                  {
82:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
83:                  	can->CCON.ON = 0;
00000000  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  CAN_ExistsEnableControl_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_CAN_ExistsEnableControl
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_CAN_ExistsEnableControl function.
95:                  */
96:                  
97:                  #define PLIB_CAN_ExistsEnableControl PLIB_CAN_ExistsEnableControl
98:                  PLIB_TEMPLATE bool CAN_ExistsEnableControl_Default( CAN_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_CAN_ENABLECONTROL_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_channelupdate_pic32.h  --------
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ChannelUpdate_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelUpdate
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_ChannelUpdate
16:                          PLIB_CAN_ExistsChannelUpdate
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_CHANNELUPDATE_PIC32_H
47:                  #define _CAN_CHANNELUPDATE_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_ChannelUpdate_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_ChannelUpdate 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_ChannelUpdate function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_ChannelUpdate_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  
65:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
66:                  	
67:                  	can->CFIFOREG[channel].CFIFOCON0SET = _C1FIFOCON1_UINC_MASK;
9D0039F4  00129180   SLL S2, S2, 6
9D003C00  24032000   ADDIU V1, ZERO, 8192
9D003C04  3C02BF88   LUI V0, -16504
9D003C08  AC430398   SW V1, 920(V0)
9D009C48  00042180   SLL A0, A0, 6
000000BC  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  CAN_ExistsChannelUpdate_pic32
73:                  
74:                    Summary:
75:                      Implements pic32 variant of PLIB_CAN_ExistsChannelUpdate
76:                  
77:                    Description:
78:                      This template implements the pic32 variant of the PLIB_CAN_ExistsChannelUpdate function.
79:                  */
80:                  
81:                  #define PLIB_CAN_ExistsChannelUpdate PLIB_CAN_ExistsChannelUpdate
82:                  PLIB_TEMPLATE bool CAN_ExistsChannelUpdate_pic32( CAN_MODULE_ID index )
83:                  {
84:                      return true;
85:                  }
86:                  
87:                  
88:                  #endif /*_CAN_CHANNELUPDATE_PIC32_H*/
89:                  
90:                  /******************************************************************************
91:                   End of File
92:                  */
93:                  
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_channelfortransmitset_pic32.h  
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ChannelForTransmitSet_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelForTransmitSet
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_ChannelForTransmitSet
16:                          PLIB_CAN_ExistsChannelForTransmitSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_CHANNELFORTRANSMITSET_PIC32_H
47:                  #define _CAN_CHANNELFORTRANSMITSET_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_ChannelForTransmitSet_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_ChannelForTransmitSet 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_ChannelForTransmitSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_ChannelForTransmitSet_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel , uint8_t channelSize , CAN_TX_RTR rtren , CAN_TXCHANNEL_PRIORITY priority )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  
65:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than Maximum" );
66:                  
67:                      // Use channel 0 position as it matches for all.
68:                      // Set the channel for transmit
69:                      can->CFIFOREG[channel].CFIFOCON0SET = _C1FIFOCON1_TXEN_MASK;
9D0049F8  24040080   ADDIU A0, ZERO, 128
9D0049FC  AC440358   SW A0, 856(V0)
9D004A58  AC4403D8   SW A0, 984(V0)
70:                  
71:                      // We need not find the register again.
72:                      if (rtren == CAN_TX_RTR_ENABLED)
73:                      {
74:                  		can->CFIFOREG[channel].CFIFOCON0SET = _C1FIFOCON1_RTREN_MASK;
75:                      }
76:                      else 
77:                      {
78:                          can->CFIFOREG[channel].CFIFOCON0CLR = _C1FIFOCON1_RTREN_MASK;
9D004A00  24070004   ADDIU A3, ZERO, 4
9D004A04  AC470354   SW A3, 852(V0)
9D004A5C  AC4703D4   SW A3, 980(V0)
79:                      }
80:                      /* Write the FIFO size */
81:                      can->CFIFOREG[channel].CFIFOCON0.FSIZE = (channelSize-1u);
9D004A08  8C450350   LW A1, 848(V0)
9D004A0C  2403001F   ADDIU V1, ZERO, 31
9D004A10  7C65A404   INS A1, V1, 16, 5
9D004A14  AC450350   SW A1, 848(V0)
9D004A60  8C4703D0   LW A3, 976(V0)
9D004A64  7C67A404   INS A3, V1, 16, 5
9D004A68  AC4703D0   SW A3, 976(V0)
82:                      /* Write the Tx priority */
83:                      can->CFIFOREG[channel].CFIFOCON0.TXPRI = priority;
9D004A18  8C450350   LW A1, 848(V0)
9D004A1C  24080001   ADDIU T0, ZERO, 1
9D004A20  7D050804   INS A1, T0, 0, 2
9D004A24  AC450350   SW A1, 848(V0)
9D004A6C  8C4703D0   LW A3, 976(V0)
9D004A70  7D070804   INS A3, T0, 0, 2
9D004A74  AC4703D0   SW A3, 976(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  CAN_ExistsChannelForTransmitSet_pic32
89:                  
90:                    Summary:
91:                      Implements pic32 variant of PLIB_CAN_ExistsChannelForTransmitSet
92:                  
93:                    Description:
94:                      This template implements the pic32 variant of the PLIB_CAN_ExistsChannelForTransmitSet function.
95:                  */
96:                  
97:                  #define PLIB_CAN_ExistsChannelForTransmitSet PLIB_CAN_ExistsChannelForTransmitSet
98:                  PLIB_TEMPLATE bool CAN_ExistsChannelForTransmitSet_pic32( CAN_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_CAN_CHANNELFORTRANSMITSET_PIC32_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_channelforreceiveset_pic32.h  -
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ChannelForReceiveSet_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelForReceiveSet
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_ChannelForReceiveSet
16:                          PLIB_CAN_ExistsChannelForReceiveSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_CHANNELFORRECEIVESET_PIC32_H
47:                  #define _CAN_CHANNELFORRECEIVESET_PIC32_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_ChannelForReceiveSet_pic32
53:                  
54:                    Summary:
55:                      Implements pic32 variant of PLIB_CAN_ChannelForReceiveSet 
56:                  
57:                    Description:
58:                      This template implements the pic32 variant of the PLIB_CAN_ChannelForReceiveSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_ChannelForReceiveSet_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel , uint32_t channelSize , CAN_RX_DATA_MODE dataOnly )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	
65:                  	PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than Maximum" );
66:                  
67:                      // Use channel 0 position as it matches for all.
68:                      // Set the channel for receive
69:                  	can->CFIFOREG[channel].CFIFOCON0CLR = _C1FIFOCON0_TXEN_MASK;
9D004A28  AC440394   SW A0, 916(V0)
9D004A78  AC440414   SW A0, 1044(V0)
9D004AA0  AC440454   SW A0, 1108(V0)
70:                  
71:                      // We need not find the register again.
72:                      if (dataOnly == CAN_RX_DATA_ONLY)
73:                      {
74:                  		can->CFIFOREG[channel].CFIFOCON0SET = _C1FIFOCON0_DONLY_MASK;
75:                      }
76:                      else
77:                      {
78:                  		can->CFIFOREG[channel].CFIFOCON0CLR = _C1FIFOCON0_DONLY_MASK;
9D004A2C  24061000   ADDIU A2, ZERO, 4096
9D004A30  AC460394   SW A2, 916(V0)
9D004A7C  AC460414   SW A2, 1044(V0)
9D004AA4  AC460454   SW A2, 1108(V0)
79:                      }
80:                  	
81:                      // Write the FIFO size 
82:                  	can->CFIFOREG[channel].CFIFOCON0.FSIZE = channelSize-1u;
9D004A34  8C450390   LW A1, 912(V0)
9D004A38  7C65A404   INS A1, V1, 16, 5
9D004A3C  AC450390   SW A1, 912(V0)
9D004A80  8C470410   LW A3, 1040(V0)
9D004A84  7C67A404   INS A3, V1, 16, 5
9D004A88  AC470410   SW A3, 1040(V0)
9D004AA8  8C460450   LW A2, 1104(V0)
9D004AAC  7C66A404   INS A2, V1, 16, 5
9D004AB0  AC460450   SW A2, 1104(V0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  CAN_ExistsChannelForReceiveSet_pic32
88:                  
89:                    Summary:
90:                      Implements pic32 variant of PLIB_CAN_ExistsChannelForReceiveSet
91:                  
92:                    Description:
93:                      This template implements the pic32 variant of the PLIB_CAN_ExistsChannelForReceiveSet function.
94:                  */
95:                  
96:                  #define PLIB_CAN_ExistsChannelForReceiveSet PLIB_CAN_ExistsChannelForReceiveSet
97:                  PLIB_TEMPLATE bool CAN_ExistsChannelForReceiveSet_pic32( CAN_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_CAN_CHANNELFORRECEIVESET_PIC32_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_channeleventget_default.h  ----
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ChannelEventGet_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelEventGet
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_ChannelEventGet
16:                          PLIB_CAN_ChannelEventClear
17:                          PLIB_CAN_ExistsChannelEvent
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _CAN_CHANNELEVENTGET_DEFAULT_H
48:                  #define _CAN_CHANNELEVENTGET_DEFAULT_H
49:                  
50:                  #include "../templates/can_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  CAN_ChannelEventGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_CAN_ChannelEventGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_CAN_ChannelEventGet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE CAN_CHANNEL_EVENT CAN_ChannelEventGet_Default( CAN_MODULE_ID index , CAN_CHANNEL channel )
63:                  {
64:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
65:                  
66:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
67:                  
68:                  	return (CAN_CHANNEL_EVENT) ((can->CFIFOREG[channel].CFIFOINT0.w & 0x7FFu) >> _C1FIFOINT0_RXNEMPTYIF_POSITION);
9D003974  00021180   SLL V0, V0, 6
9D003A5C  3C02BF88   LUI V0, -16504
9D009B60  00041180   SLL V0, A0, 6
9D009B64  3C03BF88   LUI V1, -16504
9D009B68  00621021   ADDU V0, V1, V0
9D009B6C  8C430360   LW V1, 864(V0)
00000000  00000000   NOP
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  CAN_ChannelEventClear_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_CAN_ChannelEventClear 
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_CAN_ChannelEventClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void CAN_ChannelEventClear_Default( CAN_MODULE_ID index , CAN_CHANNEL channel , CAN_CHANNEL_EVENT events )
83:                  {
84:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
85:                  
86:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
87:                  
88:                  	can->CFIFOREG[channel].CFIFOINT0CLR = events;
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  CAN_ExistsChannelEvent_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_CAN_ExistsChannelEvent
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_CAN_ExistsChannelEvent function.
100:                 */
101:                 
102:                 #define PLIB_CAN_ExistsChannelEvent PLIB_CAN_ExistsChannelEvent
103:                 PLIB_TEMPLATE bool CAN_ExistsChannelEvent_Default( CAN_MODULE_ID index )
104:                 {
105:                     return true;
106:                 }
107:                 
108:                 
109:                 #endif /*_CAN_CHANNELEVENTGET_DEFAULT_H*/
110:                 
111:                 /******************************************************************************
112:                  End of File
113:                 */
114:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_channeleventenable_pic32.h  ---
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_ChannelEventEnable_pic32.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelEventEnable
13:                      and its Variant : pic32
14:                      For following APIs :
15:                          PLIB_CAN_ChannelEventEnable
16:                          PLIB_CAN_ChannelEventDisable
17:                          PLIB_CAN_ExistsChannelEventEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _CAN_CHANNELEVENTENABLE_PIC32_H
48:                  #define _CAN_CHANNELEVENTENABLE_PIC32_H
49:                  
50:                  #include "../templates/can_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  CAN_ChannelEventEnable_pic32
55:                  
56:                    Summary:
57:                      Implements pic32 variant of PLIB_CAN_ChannelEventEnable 
58:                  
59:                    Description:
60:                      This template implements the pic32 variant of the PLIB_CAN_ChannelEventEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void CAN_ChannelEventEnable_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel , CAN_CHANNEL_EVENT flags )
64:                  {
65:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
66:                  
67:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
68:                      PLIB_ASSERT( (flags  <= CAN_TX_CHANNEL_ANY_EVENT),   "No event corresponding to the flag" );
69:                  
70:                  	can->CFIFOREG[channel].CFIFOINT0SET = (flags << _C1FIFOINT0_RXNEMPTYIE_POSITION);
9D004A50  3C050001   LUI A1, 1
9D004A54  AC4503A8   SW A1, 936(V0)
9D004A9C  AC450428   SW A1, 1064(V0)
9D004AC8  AC450468   SW A1, 1128(V0)
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  CAN_ChannelEventDisable_pic32
76:                  
77:                    Summary:
78:                      Implements pic32 variant of PLIB_CAN_ChannelEventDisable 
79:                  
80:                    Description:
81:                      This template implements the pic32 variant of the PLIB_CAN_ChannelEventDisable function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void CAN_ChannelEventDisable_pic32( CAN_MODULE_ID index , CAN_CHANNEL channel , CAN_CHANNEL_EVENT flags )
85:                  {
86:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
87:                  
88:                      PLIB_ASSERT( (channel  <= CAN_CHANNEL31),   "Channel number more than limit" );
89:                      PLIB_ASSERT( (flags  <= CAN_TX_CHANNEL_ANY_EVENT),   "No event corresponding to the flag" );
90:                  
91:                      can->CFIFOREG[channel].CFIFOINT0CLR = (flags << _C1FIFOINT0_RXNEMPTYIE_POSITION);
92:                  }
93:                  
94:                  
95:                  //******************************************************************************
96:                  /* Function :  CAN_ExistsChannelEventEnable_pic32
97:                  
98:                    Summary:
99:                      Implements pic32 variant of PLIB_CAN_ExistsChannelEventEnable
100:                 
101:                   Description:
102:                     This template implements the pic32 variant of the PLIB_CAN_ExistsChannelEventEnable function.
103:                 */
104:                 
105:                 #define PLIB_CAN_ExistsChannelEventEnable PLIB_CAN_ExistsChannelEventEnable
106:                 PLIB_TEMPLATE bool CAN_ExistsChannelEventEnable_pic32( CAN_MODULE_ID index )
107:                 {
108:                     return true;
109:                 }
110:                 
111:                 
112:                 #endif /*_CAN_CHANNELEVENTENABLE_PIC32_H*/
113:                 
114:                 /******************************************************************************
115:                  End of File
116:                 */
117:                 
---  c:/microchip/harmony/v2_05_01/framework/peripheral/can/templates/can_baudrateprescale_default.h  ---
1:                   /*******************************************************************************
2:                     CAN Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       can_BaudRatePrescale_Default.h
6:                   
7:                     Summary:
8:                       CAN PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRatePrescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_CAN_BaudRatePrescaleSet
16:                          PLIB_CAN_ExistsBaudRatePrescale
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _CAN_BAUDRATEPRESCALE_DEFAULT_H
47:                  #define _CAN_BAUDRATEPRESCALE_DEFAULT_H
48:                  
49:                  #include "../templates/can_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  CAN_BaudRatePrescaleSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_CAN_BaudRatePrescaleSet
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_CAN_BaudRatePrescaleSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void CAN_BaudRatePrescaleSet_Default( CAN_MODULE_ID index , CAN_BAUD_RATE_PRESCALE prescale )
62:                  {
63:                  	volatile can_registers_t * can = ((can_registers_t *)(index));
64:                  	can->CCFG.BRP = prescale;
9D0049C4  8C430010   LW V1, 16(V0)
9D0049C8  7C032804   INS V1, ZERO, 0, 6
9D0049CC  AC430010   SW V1, 16(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  CAN_ExistsBaudRatePrescale_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_CAN_ExistsBaudRatePrescale
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_CAN_ExistsBaudRatePrescale function.
76:                  */
77:                  
78:                  #define PLIB_CAN_ExistsBaudRatePrescale PLIB_CAN_ExistsBaudRatePrescale
79:                  PLIB_TEMPLATE bool CAN_ExistsBaudRatePrescale_Default( CAN_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_CAN_BAUDRATEPRESCALE_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_05_01/framework/osal/osal_impl_basic.h  ------------------------------------
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef _OSAL_IMPL_BASIC_H
50:                  #define _OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  #include "system/int/sys_int.h"
64:                  
65:                  
66:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
67:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
68:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
69:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
70:                  
71:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
72:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
73:                  
74:                  // *****************************************************************************
75:                  /* Macro: OSAL_ASSERT
76:                   */
77:                  
78:                  #define OSAL_ASSERT(test, message)      test
79:                  
80:                  // *****************************************************************************
81:                  /* OSAL Result type
82:                  
83:                    Summary:
84:                      Enumerated type representing the general return value from OSAL functions.
85:                  
86:                    Description:
87:                      This enum represents possible return types from OSAL functions.
88:                  
89:                    Remarks:
90:                      These enum values are the possible return values from OSAL functions
91:                      where a standard success/fail type response is required. The majority
92:                      of OSAL functions will return this type with a few exceptions.
93:                  */
94:                  
95:                  typedef enum OSAL_SEM_TYPE
96:                  {
97:                      OSAL_SEM_TYPE_BINARY,
98:                      OSAL_SEM_TYPE_COUNTING
99:                  } OSAL_SEM_TYPE;
100:                 
101:                 typedef enum OSAL_CRIT_TYPE
102:                 {
103:                     OSAL_CRIT_TYPE_LOW,
104:                     OSAL_CRIT_TYPE_HIGH
105:                 } OSAL_CRIT_TYPE;
106:                 
107:                 typedef enum OSAL_RESULT
108:                 {
109:                     OSAL_RESULT_NOT_IMPLEMENTED = -1,
110:                     OSAL_RESULT_FALSE = 0,
111:                     OSAL_RESULT_TRUE = 1
112:                 } OSAL_RESULT;
113:                 
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 // Section: Section: Interface Routines Group Declarations
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 static __inline__ OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
120:                 static __inline__ OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
121:                 static __inline__ OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
122:                 static __inline__ OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
123:                 static __inline__ OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
124:                 static __inline__ uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
125:                 
126:                 static __inline__ OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
127:                 static __inline__ void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
128:                 
129:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
130:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
131:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
132:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
133:                 
134:                 void* OSAL_Malloc(size_t size);
135:                 void OSAL_Free(void* pData);
136:                 
137:                 OSAL_RESULT OSAL_Initialize();
138:                 
139:                 static __inline__ const char* OSAL_Name(void);
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Interface Routines Group Defintions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 
147:                 /* Critical Section group */
148:                 // *****************************************************************************
149:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
150:                  */
151:                 static OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
152:                 {
153:                    if(severity == OSAL_CRIT_TYPE_LOW)
154:                       return (0);
155:                    /*if priority is set to HIGH the user wants interrupts disabled*/
156:                    return (SYS_INT_StatusGetAndDisable());
9D0093D0  0F4032D5   JAL SYS_INT_StatusGetAndDisable
9D0093E4  0F4032D5   JAL SYS_INT_StatusGetAndDisable
157:                 }
158:                 
159:                 // *****************************************************************************
160:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
161:                  */
162:                 static void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
163:                 {
164:                    if(severity == OSAL_CRIT_TYPE_LOW)
165:                       return;
166:                    /*if priority is set to HIGH the user wants interrupts re-enabled to the state 
167:                    they were before disabling.*/
168:                    SYS_INT_StatusRestore(status);   
9D0093DC  0F4032DC   JAL SYS_INT_StatusRestore
9D0093F0  0F4032DC   JAL SYS_INT_StatusRestore
169:                 }
170:                 
171:                 // *****************************************************************************
172:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
173:                                                 uint8_t maxCount, uint8_t initialCount)
174:                  */
175:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
176:                                                 uint8_t maxCount, uint8_t initialCount)
177:                 {
178:                    OSAL_CRITSECT_DATA_TYPE IntState;
179:                    
180:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
181:                  
182:                    if (type == OSAL_SEM_TYPE_COUNTING)
183:                       *semID = initialCount;
9D0093D8  A2000048   SB ZERO, 72(S0)
9D0093EC  A2000049   SB ZERO, 73(S0)
184:                    else
185:                       *semID = 1;
186:                  
187:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
188:                    
189:                    return OSAL_RESULT_TRUE;
190:                 }
191:                 
192:                 // *****************************************************************************
193:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
194:                  */
195:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
196:                 {
197:                    return (OSAL_RESULT_TRUE);
198:                 }
199:                 
200:                 // *****************************************************************************
201:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
202:                  */
203:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
204:                 {
205:                    OSAL_CRITSECT_DATA_TYPE IntState;
206:                    
207:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
208:                        
209:                    if (*semID > 0)
210:                    {
211:                       (*semID)--;
212:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
213:                       
214:                       return OSAL_RESULT_TRUE;
215:                    }
216:                    
217:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
218:                       
219:                    return OSAL_RESULT_FALSE;
220:                 }
221:                 
222:                 // *****************************************************************************
223:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
224:                  */
225:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
226:                 {
227:                    OSAL_CRITSECT_DATA_TYPE IntState;
228:                    
229:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
230:                    (*semID)++;
231:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
232:                    
233:                    return OSAL_RESULT_TRUE;
234:                 }
235:                 
236:                 // *****************************************************************************
237:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
238:                  */
239:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
240:                 {
241:                     (*semID)++;
000000D8  00000000   NOP
0000013C  00000000   NOP
242:                     return OSAL_RESULT_TRUE;
243:                 }
244:                 
245:                 // *****************************************************************************
246:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
247:                  */
248:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
249:                 {
250:                     return *semID;
251:                 }
252:                 
253:                 // *****************************************************************************
254:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
255:                  */
256:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
257:                 {
258:                    *mutexID = 1;
9D00865C  A2420030   SB V0, 48(S2)
9D00866C  278281D8   ADDIU V0, GP, -32296
9D008670  24030001   ADDIU V1, ZERO, 1
9D008674  A0430001   SB V1, 1(V0)
9D008678  A0430002   SB V1, 2(V0)
259:                    return OSAL_RESULT_TRUE;
260:                 }
261:                 
262:                 // *****************************************************************************
263:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
264:                  */
265:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
266:                 {
267:                    return (OSAL_RESULT_TRUE);
268:                    
269:                 }
270:                 // *****************************************************************************
271:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
272:                  */
273:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
274:                 {
275:                     if (*mutexID == 1)
9D0001B0  90440030   LBU A0, 48(V0)
9D009350  938781D9   LBU A3, -32295(GP)
9D00C044  90650030   LBU A1, 48(V1)
00000018  00000000   NOP
00000024  00000000   NOP
276:                     {
277:                         *mutexID = 0;
9D00C050  A0600030   SB ZERO, 48(V1)
00000028  00000000   NOP
00000030  00000000   NOP
278:                         return OSAL_RESULT_TRUE;
279:                     }
280:                     return OSAL_RESULT_FALSE;
281:                 }
282:                 
283:                 // *****************************************************************************
284:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
285:                  */
286:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
287:                 {
288:                     *mutexID = 1;
9D0001EC  A0430030   SB V1, 48(V0)
9D0093A8  A38281D9   SB V0, -32295(GP)
9D009410  24020001   ADDIU V0, ZERO, 1
9D009414  A38281D9   SB V0, -32295(GP)
9D00C05C  A0640030   SB A0, 48(V1)
00000060  00000000   NOP
000000D4  00000000   NOP
000001F0  00000000   NOP
289:                     return OSAL_RESULT_TRUE;
290:                 }
291:                 
292:                 // Miscellaneous functions
293:                 // *****************************************************************************
294:                 /* Function: void* OSAL_Malloc(size_t size)
295:                  */
296:                 #define OSAL_Malloc(size)                               (malloc(size))
297:                 
298:                 // *****************************************************************************
299:                 /* Function: void OSAL_Free(void* pData)
300:                  */
301:                 #define OSAL_Free(pData)                                (free(pData))
302:                 
303:                 // Initialization and Diagnostics
304:                 // *****************************************************************************
305:                 /* Function: OSAL_RESULT OSAL_Initialize()
306:                  */
307:                 #define OSAL_Initialize()
308:                 
309:                 
310:                 // *****************************************************************************
311:                 /* Function: const char* OSAL_Name()
312:                  */
313:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
314:                 {
315:                    return((const char*) "BASIC");
316:                 }
317:                 
318:                 
319:                 #ifdef __cplusplus
320:                 }
321:                 #endif
322:                 
323:                 #endif // _OSAL_IMPL_BASIC_H
324:                 
325:                 /*******************************************************************************
326:                  End of File
327:                  */
328:                 
329:                 
330:                 
331:                 
---  c:/microchip/harmony/v2_05_01/framework/driver/usart/src/dynamic/drv_usart_byte_model.c  -----------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_byte_model.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver's byte model functionality.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "../drv_usart_local.h"
44:                  
45:                  // *****************************************************************************
46:                  /* Function:
47:                      void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
48:                  
49:                    Summary:
50:                      Dynamic implementation of DRV_USART_WriteByte client interface function.
51:                  
52:                    Description:
53:                      This is the dynamic implementation of DRV_USART_WriteByte client
54:                      interface function.
55:                  
56:                    Remarks:
57:                      See drv_usart.h for usage information.
58:                  */
59:                  
60:                  void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
61:                  {
9D000190  27BDFFE8   ADDIU SP, SP, -24
9D000194  AFBF0014   SW RA, 20(SP)
9D000198  AFB00010   SW S0, 16(SP)
62:                      DRV_USART_CLIENT_OBJ * client;
63:                      DRV_USART_OBJ * hDriver;
64:                  
65:                      /* Validate the client handle */
66:                      client = _DRV_USART_DriverHandleValidate(handle);
9D00019C  0F40323D   JAL _DRV_USART_DriverHandleValidate
9D0001A0  00A08021   ADDU S0, A1, ZERO
67:                  
68:                      if(client == NULL)
9D0001A4  10400012   BEQ V0, ZERO, .LVL12, .LBE48
9D0001A8  24030001   ADDIU V1, ZERO, 1
69:                      {
70:                          SYS_DEBUG(0, "Invalid Driver Handle");
71:                          return;
72:                      }
73:                  
74:                      hDriver = client->hDriver;
9D0001AC  8C420000   LW V0, 0(V0)
75:                  
76:                      /* This function needs to be thread safe */
77:                  
78:                      if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
79:                      {
80:                          /* Send one byte */
81:                          PLIB_USART_TransmitterByteSend(hDriver->moduleId, byte);
82:                          _DRV_USART_InterruptSourceEnable(hDriver->txInterruptSource);
9D0001C8  8C440024   LW A0, 36(V0)
83:                          OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
84:                      }
85:                      else
86:                      {
87:                          SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_WriteByte() function");
88:                      }
89:                  }
9D0001F0  8FBF0014   LW RA, 20(SP)
90:                  
91:                  // *****************************************************************************
92:                  /* Function:
93:                      void DRV_USART_ReadByte( const DRV_HANDLE handle)
94:                  
95:                    Summary:
96:                      Dynamic implementation of DRV_USART_ReadByte client interface function.
97:                  
98:                    Description:
99:                      This is the dynamic implementation of DRV_USART_ReadByte client
100:                     interface function.
101:                 
102:                   Remarks:
103:                     See drv_usart.h for usage information.
104:                 */
105:                 
106:                 uint8_t DRV_USART_ReadByte( const DRV_HANDLE handle )
107:                 {
9D00C028  27BDFFE8   ADDIU SP, SP, -24
9D00C02C  AFBF0014   SW RA, 20(SP)
108:                     DRV_USART_CLIENT_OBJ * client;
109:                     DRV_USART_OBJ * hDriver;
110:                     uint8_t readValue;
111:                 
112:                     /* Validate the client handle */
113:                     client = _DRV_USART_DriverHandleValidate(handle);
9D00C030  0F40323D   JAL _DRV_USART_DriverHandleValidate
9D00C034  00000000   NOP
114:                 
115:                     if(client == NULL)
9D00C038  1040000B   BEQ V0, ZERO, .LVL21
9D00C03C  24040001   ADDIU A0, ZERO, 1
116:                     {
117:                         SYS_DEBUG(0, "Invalid Driver Handle");
118:                         return 0;
9D00C068  00001021   ADDU V0, ZERO, ZERO
119:                     }
120:                 
121:                     hDriver = client->hDriver;
9D00C040  8C430000   LW V1, 0(V0)
122:                 
123:                     /* This function needs to be thread safe */
124:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
125:                     {
126:                         /* Read one byte */
127:                         readValue = PLIB_USART_ReceiverByteReceive(hDriver->moduleId);
128:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
129:                     }
130:                     else
131:                     {
132:                         SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_ReadByte() function");
133:                         return 0;
134:                     }
135:                 	return readValue;
9D00C060  0B40301B   J .LVL22
9D00C064  304200FF   ANDI V0, V0, 255
136:                 }
9D00C06C  8FBF0014   LW RA, 20(SP)
137:                 
138:                 // *****************************************************************************
139:                 /* Function:
140:                     void DRV_USART_ReceiverBufferSizeGet( const DRV_HANDLE handle)
141:                 
142:                   Summary:
143:                     Dynamic implementation of DRV_USART_ReceiverBufferSizeGet client interface
144:                     function.
145:                 
146:                   Description:
147:                     This is the dynamic implementation of DRV_USART_ReceiverBufferSizeGet client
148:                     interface function.
149:                 
150:                   Remarks:
151:                     See drv_usart.h for usage information.
152:                 */
153:                 
154:                 unsigned int DRV_USART_ReceiverBufferSizeGet (const DRV_HANDLE handle )
155:                 {
00000000  00000000   NOP
156:                     DRV_USART_CLIENT_OBJ * client;
157:                 
158:                     /* Validate the client handle */
159:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
160:                 
161:                     if(client == NULL)
162:                     {
163:                         SYS_DEBUG(0, "Invalid Driver Handle");
164:                         return 0;
165:                     }
166:                 
167:                     return 8;
168:                 
169:                 }
00000010  00000000   NOP
170:                 
171:                 // *****************************************************************************
172:                 /* Function:
173:                     void DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle)
174:                 
175:                   Summary:
176:                     Dynamic implementation of DRV_USART_TransmitBufferSizeGet client interface
177:                     function.
178:                 
179:                   Description:
180:                     This is the dynamic implementation of DRV_USART_TransmitBufferSizeGet client
181:                     interface function.
182:                 
183:                   Remarks:
184:                     See drv_usart.h for usage information.
185:                 */
186:                 
187:                 unsigned int DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle )
188:                 {
00000000  00000000   NOP
189:                     DRV_USART_CLIENT_OBJ * client;
190:                 
191:                     /* Validate the client handle */
192:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
193:                 
194:                     if(client == NULL)
195:                     {
196:                         SYS_DEBUG(0, "Invalid Driver Handle");
197:                         return 0;
198:                     }
199:                 
200:                     return 8;
201:                 
202:                 }
00000010  00000000   NOP
203:                 
204:                 // *****************************************************************************
205:                 /* Function:
206:                     void DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle)
207:                 
208:                   Summary:
209:                     Dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client interface
210:                     function.
211:                 
212:                   Description:
213:                     This is the dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client
214:                     interface function.
215:                 
216:                   Remarks:
217:                     See drv_usart.h for usage information.
218:                 */
219:                 
220:                 bool DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle )
221:                 {
00000000  00000000   NOP
222:                     DRV_USART_CLIENT_OBJ * client;
223:                     DRV_USART_OBJ * hDriver;
224:                 
225:                     /* Validate the client handle */
226:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
227:                 
228:                     if(client == NULL)
00000010  00000000   NOP
229:                     {
230:                         SYS_DEBUG(0, "Invalid Driver Handle");
231:                         return false;
232:                     }
233:                 
234:                     hDriver = client->hDriver;
235:                 
236:                     /* If there is data available in the receiver, then this function
237:                        buffer is not empty and this function returns false. */
238:                 
239:                     return(PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId) ? false : true);
00000018  00000000   NOP
240:                 }
0000002C  00000000   NOP
241:                 
242:                 // *****************************************************************************
243:                 /* Function:
244:                     void DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle)
245:                 
246:                   Summary:
247:                     Dynamic implementation of DRV_USART_TransmitBufferIsFull client interface
248:                     function.
249:                 
250:                   Description:
251:                     This is the dynamic implementation of DRV_USART_TransmitBufferIsFull client
252:                     interface function.
253:                 
254:                   Remarks:
255:                     See drv_usart.h for usage information.
256:                 */
257:                 
258:                 bool DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle )
259:                 {
00000000  00000000   NOP
260:                     DRV_USART_CLIENT_OBJ * client;
261:                     DRV_USART_OBJ * hDriver;
262:                 
263:                     /* Validate the client handle */
264:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
265:                 
266:                     if(client == NULL)
00000010  00000000   NOP
267:                     {
268:                         SYS_DEBUG(0, "Invalid Driver Handle");
269:                         return false;
270:                     }
271:                 
272:                     hDriver = client->hDriver;
273:                 
274:                     /* If there is data available in the receiver, then this function
275:                        buffer is not empty and this function returns false. */
276:                 
277:                     return(PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId));
00000018  00000000   NOP
278:                 }
00000028  00000000   NOP
279:                 
---  c:/microchip/harmony/v2_05_01/framework/driver/usart/src/dynamic/drv_usart.c  ----------------------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver.
16:                   *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                   *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  #include "../drv_usart_local.h"
49:                  
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Global Data
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  /* This is the driver instance object array. */
59:                  DRV_USART_OBJ gDrvUSARTObj[DRV_USART_INSTANCES_NUMBER];
60:                  
61:                  /* This is the client object array. */
62:                  DRV_USART_CLIENT_OBJ gDrvUSARTClientObj[DRV_USART_CLIENTS_NUMBER];
63:                  
64:                  /* This object maintains data that is required by all USART
65:                     driver instances. */
66:                  DRV_USART_COMMON_DATA_OBJ gDrvUSARTCommonDataObj;
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: USART Driver Interface Implementations
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  // *****************************************************************************
75:                  
76:                  /* Function:
77:                      SYS_MODULE_OBJ DRV_USART_Initialize
78:                      (
79:                          const SYS_MODULE_INDEX drvIndex,
80:                          const SYS_MODULE_INIT * const init
81:                      )
82:                  
83:                    Summary:
84:                      Dynamic implementation of DRV_USART_Initialize system interface function.
85:                  
86:                    Description:
87:                      This is the dynamic implementation of DRV_USART_Initialize system interface
88:                      function.
89:                  
90:                    Remarks:
91:                      See drv_usart.h for usage information.
92:                   */
93:                  
94:                  SYS_MODULE_OBJ DRV_USART_Initialize
95:                  (
96:                          const SYS_MODULE_INDEX drvIndex,
97:                          const SYS_MODULE_INIT * const init
98:                          ) {
9D0084E8  27BDFFE0   ADDIU SP, SP, -32
9D0084EC  AFBF001C   SW RA, 28(SP)
9D0084F0  AFB20018   SW S2, 24(SP)
9D0084F4  AFB10014   SW S1, 20(SP)
9D0084F8  AFB00010   SW S0, 16(SP)
9D0084FC  00808021   ADDU S0, A0, ZERO
99:                      DRV_USART_OBJ *dObj = (DRV_USART_OBJ*) NULL;
100:                     DRV_USART_INIT *usartInit = NULL;
101:                 
102:                     /* Check if the specified driver index is in valid range */
103:                     if (drvIndex >= DRV_USART_INSTANCES_NUMBER) {
9D008500  2C830003   SLTIU V1, A0, 3
9D008504  10600064   BEQ V1, ZERO, .LVL109
9D008508  2402FFFF   ADDIU V0, ZERO, -1
104:                         SYS_DEBUG(0, "Invalid driver index");
105:                         return SYS_MODULE_OBJ_INVALID;
106:                     }
107:                 
108:                     /* Check if this hardware instance was already initialized */
109:                     if (gDrvUSARTObj[drvIndex].inUse != false) {
9D00850C  00041140   SLL V0, A0, 5
9D008510  000419C0   SLL V1, A0, 7
9D008514  00621023   SUBU V0, V1, V0
9D008518  3C038000   LUI V1, -32768
9D00851C  24635A5C   ADDIU V1, V1, 23132
9D008520  00431021   ADDU V0, V0, V1
9D008524  90430014   LBU V1, 20(V0)
9D008528  1460005B   BNE V1, ZERO, .LVL109
9D00852C  2402FFFF   ADDIU V0, ZERO, -1
9D008530  00A08821   ADDU S1, A1, ZERO
110:                         SYS_DEBUG(0, "Instance already in use");
111:                         return SYS_MODULE_OBJ_INVALID;
112:                     }
113:                 
114:                     /* Assign to the local pointer the init data passed */
115:                     usartInit = (DRV_USART_INIT *) init;
116:                 
117:                     /* Disable the USART module */
118:                     PLIB_USART_Disable(usartInit->usartID);
119:                 
120:                     /* Allocate the driver object and set the operation flag to be in use */
121:                     dObj = &gDrvUSARTObj[drvIndex];
9D008540  00041140   SLL V0, A0, 5
9D008544  000419C0   SLL V1, A0, 7
9D008548  00621023   SUBU V0, V1, V0
9D00854C  3C128000   LUI S2, -32768
9D008550  26525A5C   ADDIU S2, S2, 23132
9D008554  02429021   ADDU S2, S2, V0
122:                     dObj->inUse = true;
9D008558  24020001   ADDIU V0, ZERO, 1
9D00855C  A2420014   SB V0, 20(S2)
123:                 
124:                     /* Update the USART PLIB Id and other parameters. */
125:                 
126:                     dObj->nClients = 0;
9D008560  AE400018   SW ZERO, 24(S2)
127:                     dObj->moduleId = usartInit->usartID;
9D008564  8CA20004   LW V0, 4(A1)
9D008568  AE420000   SW V0, 0(S2)
128:                     dObj->brgClock = usartInit->brgClock;
9D00856C  8CA20014   LW V0, 20(A1)
9D008570  AE42001C   SW V0, 28(S2)
129:                     dObj->isExclusive = false;
9D008574  A2400015   SB ZERO, 21(S2)
130:                     dObj->queueSizeRead = usartInit->queueSizeReceive;
9D008578  8CA20034   LW V0, 52(A1)
9D00857C  AE420034   SW V0, 52(S2)
131:                     dObj->queueSizeWrite = usartInit->queueSizeTransmit;
9D008580  8CA20038   LW V0, 56(A1)
9D008584  AE420038   SW V0, 56(S2)
132:                     dObj->dmaChannelRead = usartInit->dmaChannelReceive;
9D008588  8CA20040   LW V0, 64(A1)
9D00858C  AE420044   SW V0, 68(S2)
133:                     dObj->dmaChannelWrite = usartInit->dmaChannelTransmit;
9D008590  8CA2003C   LW V0, 60(A1)
9D008594  AE420048   SW V0, 72(S2)
134:                     dObj->txInterruptSource = usartInit->interruptTransmit;
9D008598  8CA20028   LW V0, 40(A1)
9D00859C  AE420024   SW V0, 36(S2)
135:                     dObj->rxInterruptSource = usartInit->interruptReceive;
9D0085A0  8CA2002C   LW V0, 44(A1)
9D0085A4  AE420028   SW V0, 40(S2)
136:                     dObj->errorInterruptSource = usartInit->interruptError;
9D0085A8  8CA20030   LW V0, 48(A1)
9D0085AC  AE42002C   SW V0, 44(S2)
137:                     dObj->dmaInterruptTransmit = usartInit->dmaInterruptTransmit;
9D0085B0  8CA20044   LW V0, 68(A1)
9D0085B4  AE42004C   SW V0, 76(S2)
138:                     dObj->dmaInterruptReceive = usartInit->dmaInterruptReceive;
9D0085B8  8CA20048   LW V0, 72(A1)
9D0085BC  AE420050   SW V0, 80(S2)
139:                     dObj->interruptNestingCount = 0;
9D0085C0  AE400020   SW ZERO, 32(S2)
140:                     dObj->queueSizeCurrentRead = 0;
9D0085C4  AE40003C   SW ZERO, 60(S2)
141:                     dObj->queueSizeCurrentWrite = 0;
9D0085C8  AE400040   SW ZERO, 64(S2)
142:                     dObj->queueRead = NULL;
9D0085CC  AE400008   SW ZERO, 8(S2)
143:                     dObj->queueWrite = NULL;
9D0085D0  AE400004   SW ZERO, 4(S2)
144:                     dObj->transmitCallback = NULL;
9D0085D4  AE400054   SW ZERO, 84(S2)
145:                     dObj->receiveCallback = NULL;
9D0085D8  AE400058   SW ZERO, 88(S2)
146:                     dObj->errorCallback = NULL;
9D0085DC  AE40005C   SW ZERO, 92(S2)
147:                     dObj->operationMode = usartInit->mode;
9D0085E0  8CA20008   LW V0, 8(A1)
9D0085E4  AE420010   SW V0, 16(S2)
148:                 
149:                     /* Setup the Hardware */
150:                     _DRV_USART_HardwareSetup(usartInit->usartID, usartInit);
9D0085E8  0F4021AC   JAL _DRV_USART_HardwareSetup
9D0085EC  8CA40004   LW A0, 4(A1)
151:                 
152:                     /* Clear the interrupts */
153:                     SYS_INT_SourceStatusClear(dObj->txInterruptSource);
9D0085F0  8E440024   LW A0, 36(S2)
154:                     SYS_INT_SourceStatusClear(dObj->rxInterruptSource);
9D008614  8E440028   LW A0, 40(S2)
155:                     SYS_INT_SourceStatusClear(dObj->errorInterruptSource);
9D00862C  8E46002C   LW A2, 44(S2)
156:                 
157:                     /* Enable the interrupt source in case of interrupt mode */
158:                     _DRV_USART_InterruptSourceEnable(dObj->errorInterruptSource);
159:                 
160:                     _DRV_USART_ByteModelInterruptSourceEnable(dObj->rxInterruptSource);
161:                 
162:                     /* TODO: Enable DMA interrupts if the DMA channel is selected */
163:                 
164:                     /* Create the hardware instance mutex. */
165:                     if (OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE) {
166:                         return SYS_MODULE_OBJ_INVALID;
167:                     }
168:                 
169:                     /* Check if the global mutexes have been created. If not
170:                        then create these. */
171:                 
172:                     if (!gDrvUSARTCommonDataObj.membersAreInitialized) {
9D008660  938281D8   LBU V0, -32296(GP)
9D008664  54400007   BNEL V0, ZERO, .LVL106
9D008668  8E220004   LW V0, 4(S1)
173:                         /* This means that mutexes where not created. Create them. */
174:                         if (OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE) {
175:                             return SYS_MODULE_OBJ_INVALID;
176:                         }
177:                         if (OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE) {
178:                             return SYS_MODULE_OBJ_INVALID;
179:                         }
180:                         /* Set this flag so that global mutexes get allocated only once */
181:                         gDrvUSARTCommonDataObj.membersAreInitialized = true;
9D00867C  A0430000   SB V1, 0(V0)
182:                     }
183:                 
184:                     /* Enable the USART module */
185:                     PLIB_USART_Enable(usartInit->usartID);
186:                 
187:                     /* Update the status */
188:                     dObj->status = SYS_STATUS_READY;
9D00868C  24020002   ADDIU V0, ZERO, 2
9D008690  AE42000C   SW V0, 12(S2)
189:                 
190:                     /* Return the object structure */
191:                     return ( (SYS_MODULE_OBJ) drvIndex);
9D008694  02001021   ADDU V0, S0, ZERO
192:                 }
9D008698  8FBF001C   LW RA, 28(SP)
193:                 
194:                 // *****************************************************************************
195:                 
196:                 /* Function:
197:                     void DRV_USART_Deinitialize( SYS_MODULE_OBJ object )
198:                 
199:                   Summary:
200:                     Dynamic implementation of DRV_USART_Deinitialize system interface function.
201:                 
202:                   Description:
203:                     This is the dynamic implementation of DRV_USART_Deinitialize system interface
204:                     function.
205:                 
206:                   Remarks:
207:                     See drv_usart.h for usage information.
208:                  */
209:                 
210:                 void DRV_USART_Deinitialize(SYS_MODULE_OBJ object) {
0000000C  00000000   NOP
211:                     DRV_USART_OBJ * dObj;
212:                     DRV_USART_BUFFER_OBJ * iterator;
213:                 
214:                     bool status;
215:                 
216:                     /* Check that the object is valid */
217:                 
218:                     if (object == SYS_MODULE_OBJ_INVALID) {
219:                         SYS_DEBUG(0, "Invalid system object handle");
220:                         return;
221:                     }
222:                 
223:                     if (object >= DRV_USART_INSTANCES_NUMBER) {
00000000  00000000   NOP
224:                         SYS_DEBUG(0, "Invalid system object handle");
225:                         return;
226:                     }
227:                 
228:                     dObj = (DRV_USART_OBJ*) & gDrvUSARTObj[object];
00000018  00000000   NOP
229:                 
230:                     if (!dObj->inUse) {
00000030  00000000   NOP
231:                         SYS_DEBUG(0, "Invalid system object handle");
232:                         return;
233:                     }
234:                 
235:                     /* The driver will not have clients when it is
236:                        being deinitialized. So the order in which
237:                        we do the following steps is not that important */
238:                 
239:                     /* Indicate that this object is not is use */
240:                     dObj->inUse = false;
0000003C  00000000   NOP
241:                 
242:                     /* Deinitialize the USART status */
243:                     dObj->status = SYS_STATUS_UNINITIALIZED;
00000040  00000000   NOP
244:                 
245:                     /* Disable the interrupt */
246:                     status = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource);
00000044  00000000   NOP
247:                     status = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource);
0000004C  00000000   NOP
248:                     status = _DRV_USART_InterruptSourceDisable(dObj->errorInterruptSource);
00000054  00000000   NOP
249:                 
250:                     /* Ignore the warning */
251:                     (void) status;
252:                 
253:                     /* Disable USART module */
254:                     PLIB_USART_Disable(dObj->moduleId);
255:                 
256:                     /* Deallocate all mutexes */
257:                     if (OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE) {
258:                         SYS_DEBUG(0, "Mutex Delete Failed");
259:                         return;
260:                     }
261:                 
262:                     /* TODO: Disable all DMA interrupts */
263:                 
264:                     /* Remove all objects from the read and write queue */
265:                 
266:                     iterator = dObj->queueWrite;
00000068  00000000   NOP
267:                     while (iterator != NULL) {
0000006C  00000000   NOP
0000007C  00000000   NOP
268:                         /* Return the buffer object to the pool */
269:                         iterator->inUse = false;
00000074  00000000   NOP
270:                         iterator = iterator->next;
00000078  00000000   NOP
271:                     }
272:                 
273:                     iterator = dObj->queueRead;
00000084  00000000   NOP
274:                     while (iterator != NULL) {
00000088  00000000   NOP
00000098  00000000   NOP
275:                         /* Return the buffer object to the pool */
276:                         iterator->inUse = false;
00000090  00000000   NOP
277:                         iterator = iterator->next;
00000094  00000000   NOP
278:                     }
279:                 }
000000A0  00000000   NOP
280:                 
281:                 // *****************************************************************************
282:                 
283:                 /* Function:
284:                     SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object )
285:                 
286:                   Summary:
287:                     Dynamic implementation of DRV_USART_Status system interface function.
288:                 
289:                   Description:
290:                     This is the dynamic implementation of DRV_USART_Status system interface
291:                     function.
292:                 
293:                   Remarks:
294:                     See drv_usart.h for usage information.
295:                  */
296:                 
297:                 SYS_STATUS DRV_USART_Status(SYS_MODULE_OBJ object) {
298:                     /* Check if we have a valid object */
299:                     if (object == SYS_MODULE_OBJ_INVALID) {
300:                         SYS_DEBUG(0, "Invalid system object handle");
301:                         return (SYS_STATUS_UNINITIALIZED);
302:                     }
303:                 
304:                     if (object > DRV_USART_INSTANCES_NUMBER) {
00000000  00000000   NOP
305:                         SYS_DEBUG(0, "Invalid system object handle");
306:                         return (SYS_STATUS_UNINITIALIZED);
307:                     }
308:                 
309:                     /* Return the system status of the hardware instance object */
310:                     return (gDrvUSARTObj[object].status);
0000000C  00000000   NOP
311:                 }
00000028  00000000   NOP
312:                 
313:                 // *****************************************************************************
314:                 
315:                 /* Function:
316:                     DRV_HANDLE DRV_USART_Open( const SYS_MODULE_INDEX index,
317:                                                const DRV_IO_INTENT    ioIntent )
318:                 
319:                   Summary:
320:                     Dynamic implementation of DRV_USART_Open client interface function.
321:                 
322:                   Description:
323:                     This is the dynamic implementation of DRV_USART_Open client interface
324:                     function.
325:                 
326:                   Remarks:
327:                     See drv_usart.h for usage information.
328:                  */
329:                 
330:                 DRV_HANDLE DRV_USART_Open
331:                 (
332:                         const SYS_MODULE_INDEX drvIndex,
333:                         const DRV_IO_INTENT ioIntent
334:                         ) {
9D0092E0  27BDFFE8   ADDIU SP, SP, -24
9D0092E4  AFBF0014   SW RA, 20(SP)
9D0092E8  AFB00010   SW S0, 16(SP)
335:                     DRV_USART_CLIENT_OBJ *clientObj;
336:                     DRV_USART_OBJ *dObj;
337:                     unsigned int iClient;
338:                 
339:                     if (drvIndex >= DRV_USART_INSTANCES_NUMBER) {
9D0092EC  2C830003   SLTIU V1, A0, 3
9D0092F0  1060004A   BEQ V1, ZERO, .LVL37
9D0092F4  2402FFFF   ADDIU V0, ZERO, -1
340:                         /* Invalid driver index */
341:                         SYS_DEBUG(0, "Invalid Driver Instance");
342:                         return (DRV_HANDLE_INVALID);
343:                     }
344:                 
345:                     dObj = &gDrvUSARTObj[drvIndex];
9D0092F8  00041140   SLL V0, A0, 5
9D0092FC  000421C0   SLL A0, A0, 7
9D009300  00822023   SUBU A0, A0, V0
9D009304  3C028000   LUI V0, -32768
9D009308  24425A5C   ADDIU V0, V0, 23132
9D00930C  00442021   ADDU A0, V0, A0
346:                 
347:                     if ((dObj->status != SYS_STATUS_READY) || (dObj->inUse == false)) {
9D009310  8C86000C   LW A2, 12(A0)
9D009314  24030002   ADDIU V1, ZERO, 2
9D009318  14C30040   BNE A2, V1, .LVL37
9D00931C  2402FFFF   ADDIU V0, ZERO, -1
9D009320  90830014   LBU V1, 20(A0)
9D009324  5060003E   BEQL V1, ZERO, 0x9D009420
9D009328  8FBF0014   LW RA, 20(SP)
348:                         /* The USART module should be ready */
349:                 
350:                         SYS_DEBUG(0, "Was the driver initialized?");
351:                         return DRV_HANDLE_INVALID;
352:                     }
353:                 
354:                     if (dObj->isExclusive) {
9D00932C  90830015   LBU V1, 21(A0)
9D009330  5460003B   BNEL V1, ZERO, 0x9D009420
9D009334  8FBF0014   LW RA, 20(SP)
355:                         /* This means the another client has opened the driver in exclusive
356:                            mode. The driver cannot be opened again */
357:                 
358:                         SYS_DEBUG(0, "Driver already opened exclusively");
359:                         return ( DRV_HANDLE_INVALID);
360:                     }
361:                 
362:                     if ((dObj->nClients > 0) && (ioIntent & DRV_IO_INTENT_EXCLUSIVE)) {
9D009338  8C830018   LW V1, 24(A0)
9D00933C  10600005   BEQ V1, ZERO, 0x9D009354
9D009340  938781D9   LBU A3, -32295(GP)
9D009344  30A60008   ANDI A2, A1, 8
9D009348  14C00035   BNE A2, ZERO, 0x9D009420
9D00934C  8FBF0014   LW RA, 20(SP)
363:                         /* This means the driver was already opened and another driver was
364:                            trying to open it exclusively.  We cannot give exclusive access in
365:                            this case */
366:                 
367:                         SYS_DEBUG(0, "Driver already opened. Cannot be opened exclusively");
368:                         return (DRV_HANDLE_INVALID);
369:                     }
370:                 
371:                     /* Grab client object mutex here */
372:                 
373:                     if (OSAL_MUTEX_Lock(&(gDrvUSARTCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) {
374:                         /* Enter here only if the lock was obtained (applicable in
375:                            RTOS only). If the mutex lock fails due to time out then
376:                            this code does not get executed */
377:                 
378:                         for (iClient = 0; iClient != DRV_USART_CLIENTS_NUMBER; iClient++) {
9D009374  24080005   ADDIU T0, ZERO, 5
9D009408  14C8FFDB   BNE A2, T0, .LVL22
9D00940C  2442004C   ADDIU V0, V0, 76
379:                             if (!gDrvUSARTClientObj[iClient].inUse) {
9D009360  3C028000   LUI V0, -32768
9D009364  904258E8   LBU V0, 22760(V0)
9D009368  10400008   BEQ V0, ZERO, .LVL23
9D00936C  3C028000   LUI V0, -32768
9D009370  244258E0   ADDIU V0, V0, 22752
9D009378  90470054   LBU A3, 84(V0)
9D00937C  54E00022   BNEL A3, ZERO, .LVL35
9D009380  24C60001   ADDIU A2, A2, 1
9D00938C  00003021   ADDU A2, ZERO, ZERO
380:                                 /* This means we have a free client object to use */
381:                                 clientObj = &gDrvUSARTClientObj[iClient];
9D009384  0B4024E4   J .LVL24
9D009388  3C028000   LUI V0, -32768
9D009390  244258E0   ADDIU V0, V0, 22752
9D009394  2407004C   ADDIU A3, ZERO, 76
9D009398  70C74002   MUL T0, A2, A3
9D00939C  01028021   ADDU S0, T0, V0
382:                                 clientObj->inUse = true;
9D0093A0  24020001   ADDIU V0, ZERO, 1
9D0093A4  A2020008   SB V0, 8(S0)
383:                 
384:                                 /* We have found a client object. Release the mutex */
385:                 
386:                                 OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
387:                 
388:                                 clientObj->hDriver = dObj;
9D0093AC  AE040000   SW A0, 0(S0)
389:                 
390:                                 /* In a case where the driver is configured for polled
391:                                    and bare metal operation, it will not support blocking operation */
392:                 
393:                                 clientObj->ioIntent = (ioIntent | _DRV_USART_ALWAYS_NON_BLOCKING);
9D0093B0  AE050004   SW A1, 4(S0)
394:                                 clientObj->eventHandler = NULL;
9D0093B4  AE000038   SW ZERO, 56(S0)
395:                                 clientObj->context = (uintptr_t) NULL;
9D0093B8  AE000044   SW ZERO, 68(S0)
396:                                 clientObj->error = DRV_USART_ERROR_NONE;
397:                 
398:                                 if (ioIntent & DRV_IO_INTENT_EXCLUSIVE) {
9D0093BC  30A50008   ANDI A1, A1, 8
9D0093C0  10A00002   BEQ A1, ZERO, 0x9D0093CC
9D0093C4  AE00003C   SW ZERO, 60(S0)
399:                                     /* Set the driver exclusive flag */
400:                                     dObj->isExclusive = true;
9D0093C8  A0820015   SB V0, 21(A0)
401:                                 }
402:                 
403:                                 dObj->nClients++;
9D0093CC  24630001   ADDIU V1, V1, 1
404:                 
405:                                 /* Create the semaphores */
406:                                 if (OSAL_SEM_Create(&(clientObj->semReadDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE) {
407:                                     SYS_DEBUG(0, "Semaphore creation failed");
408:                                     return (DRV_HANDLE_INVALID);
409:                                 }
410:                                 if (OSAL_SEM_Create(&(clientObj->semWriteDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE) {
411:                                     SYS_DEBUG(0, "Semaphore creation failed");
412:                                     return (DRV_HANDLE_INVALID);
413:                                 }
414:                                 /* Update the client status */
415:                                 clientObj->status = DRV_USART_CLIENT_STATUS_READY;
9D0093F8  24020002   ADDIU V0, ZERO, 2
9D0093FC  AE020040   SW V0, 64(S0)
416:                                 return ((DRV_HANDLE) clientObj);
9D009400  0B402507   J .LVL37
9D009404  02001021   ADDU V0, S0, ZERO
417:                             }
418:                         }
419:                 
420:                         /* Could not find a client object. Release the mutex and
421:                            return with an invalid handle. */
422:                         OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
423:                     }
424:                 
425:                     /* If we have reached here, it means either we could not find a spare
426:                        client object or the mutex timed out in a RTOS environment. */
427:                 
428:                     return DRV_HANDLE_INVALID;
9D009418  2402FFFF   ADDIU V0, ZERO, -1
429:                 }
9D00941C  8FBF0014   LW RA, 20(SP)
430:                 
431:                 // *****************************************************************************
432:                 
433:                 /* Function:
434:                     DRV_CLIENT_STATUS DRV_USART_Close ( DRV_HANDLE handle)
435:                 
436:                   Summary:
437:                     Dynamic implementation of DRV_USART_Close client interface function.
438:                 
439:                   Description:
440:                     This is the dynamic implementation of DRV_USART_Close client interface
441:                     function.
442:                 
443:                   Remarks:
444:                     See drv_usart.h for usage information.
445:                  */
446:                 
447:                 void DRV_USART_Close(DRV_HANDLE handle) {
00000000  00000000   NOP
448:                     /* This function closes the client, The client
449:                        object is deallocated and returned to the
450:                        pool. */
451:                 
452:                     DRV_USART_CLIENT_OBJ * clientObj;
453:                     DRV_USART_OBJ * dObj;
454:                 
455:                     /* Validate the handle */
456:                     clientObj = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
457:                 
458:                     if (clientObj == NULL) {
00000010  00000000   NOP
459:                         /* Driver handle is not valid */
460:                         SYS_DEBUG(0, "Invalid Driver Handle");
461:                         return;
462:                     }
463:                 
464:                     dObj = (DRV_USART_OBJ *) clientObj->hDriver;
00000018  00000000   NOP
465:                 
466:                     /* Remove all buffers that this client owns from the driver queue. This
467:                        function will map to _DRV_USART_ClientBufferQueueObjectsRemove() if the
468:                        driver was built for buffer queue support. Else this condition always
469:                        maps to true. */
470:                 
471:                     if (!_DRV_USART_CLIENT_BUFFER_QUEUE_OBJECTS_REMOVE(clientObj)) {
472:                         /* The function could fail if the mutex time out occurred */
473:                         SYS_DEBUG(0, "Could not remove client buffer objects");
474:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
475:                         return;
476:                     }
477:                 
478:                     /* Deallocate all semaphores */
479:                     if (OSAL_SEM_Delete(&(clientObj->semWriteDone)) != OSAL_RESULT_TRUE) {
480:                         SYS_DEBUG(0, "Unable to delete client write done semaphore");
481:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
482:                         return;
483:                     }
484:                     if (OSAL_SEM_Delete(&(clientObj->semReadDone)) != OSAL_RESULT_TRUE) {
485:                         SYS_DEBUG(0, "Unable to delete client read done semaphore");
486:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
487:                         return;
488:                     }
489:                     /* Reduce the number of clients */
490:                     dObj->nClients--;
0000001C  00000000   NOP
491:                 
492:                     /* Reset the exclusive flag */
493:                     dObj->isExclusive = false;
00000028  00000000   NOP
494:                 
495:                     /* De-allocate the object */
496:                     clientObj->status = DRV_USART_CLIENT_STATUS_CLOSED;
0000002C  00000000   NOP
497:                     clientObj->inUse = false;
00000030  00000000   NOP
498:                 
499:                     return;
500:                 }
00000034  00000000   NOP
501:                 
502:                 // *****************************************************************************
503:                 
504:                 /* Function:
505:                     void DRV_USART_ByteTransmitCallbackSet
506:                     (
507:                         const SYS_MODULE_INDEX index,
508:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
509:                     )
510:                 
511:                   Summary:
512:                     Registers transmit callback function.
513:                 
514:                   Description:
515:                     This function is used to register the callback function to be invoked
516:                     upon transmission of a byte.
517:                 
518:                   Remarks:
519:                     See drv_usart.h for usage information.
520:                  */
521:                 
522:                 void DRV_USART_ByteTransmitCallbackSet
523:                 (
524:                         const SYS_MODULE_INDEX index,
525:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
526:                         ) {
527:                     if (index >= DRV_USART_INSTANCES_NUMBER) {
9D00C848  2C820003   SLTIU V0, A0, 3
9D00C84C  10400007   BEQ V0, ZERO, 0x9D00C86C
9D00C850  00041140   SLL V0, A0, 5
528:                         /* Invalid driver index */
529:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
530:                     } else {
531:                         gDrvUSARTObj[index].transmitCallback = eventHandler;
9D00C854  000421C0   SLL A0, A0, 7
532:                     }
533:                 }
534:                 
535:                 // *****************************************************************************
536:                 
537:                 /* Function:
538:                     void DRV_USART_ByteReceiveCallbackSet
539:                     (
540:                         const SYS_MODULE_INDEX index,
541:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
542:                     )
543:                 
544:                   Summary:
545:                     Registers receive callback function.
546:                 
547:                   Description:
548:                     This function is used to register the callback function to be invoked
549:                     upon reception of a byte.
550:                 
551:                   Remarks:
552:                     See drv_usart.h for usage information.
553:                  */
554:                 
555:                 void DRV_USART_ByteReceiveCallbackSet
556:                 (
557:                         const SYS_MODULE_INDEX index,
558:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
559:                         ) {
560:                     if (index >= DRV_USART_INSTANCES_NUMBER) {
9D00C874  2C820003   SLTIU V0, A0, 3
9D00C878  10400007   BEQ V0, ZERO, 0x9D00C898
9D00C87C  00041140   SLL V0, A0, 5
561:                         /* Invalid driver index */
562:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
563:                     } else {
564:                         gDrvUSARTObj[index].receiveCallback = eventHandler;
9D00C880  000421C0   SLL A0, A0, 7
565:                     }
566:                 }
567:                 
568:                 // *****************************************************************************
569:                 
570:                 /* Function:
571:                     void DRV_USART_ByteErrorCallbackSet
572:                     (
573:                         const SYS_MODULE_INDEX index,
574:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
575:                     )
576:                 
577:                   Summary:
578:                     Registers error notification callback function.
579:                 
580:                   Description:
581:                     This function is used to register the callback function to be invoked
582:                     to notify error on the tx or the rx path in byte model of operation.
583:                 
584:                   Remarks:
585:                     See drv_usart.h for usage information.
586:                  */
587:                 
588:                 void DRV_USART_ByteErrorCallbackSet
589:                 (
590:                         const SYS_MODULE_INDEX index,
591:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
592:                         ) {
593:                     if (index >= DRV_USART_INSTANCES_NUMBER) {
00000000  00000000   NOP
594:                         /* Invalid driver index */
595:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
596:                     } else {
597:                         gDrvUSARTObj[index].errorCallback = eventHandler;
0000000C  00000000   NOP
598:                     }
599:                 }
600:                 
601:                 
602:                 // *****************************************************************************
603:                 
604:                 /* Function:
605:                     DRV_USART_ERROR DRV_USART_ErrorGet( DRV_HANDLE hClient )
606:                 
607:                   Summary:
608:                     Dynamic implementation of DRV_USART_ErrorGet client interface function.
609:                 
610:                   Description:
611:                     This is the dynamic implementation of DRV_USART_ErrorGet client interface
612:                     function.
613:                 
614:                   Remarks:
615:                     See drv_usart.h for usage information.
616:                  */
617:                 
618:                 DRV_USART_ERROR DRV_USART_ErrorGet(DRV_HANDLE hClient) {
00000000  00000000   NOP
619:                     DRV_USART_CLIENT_OBJ * clientObj;
620:                     DRV_USART_ERROR error;
621:                 
622:                     /* Validate the handle */
623:                     clientObj = _DRV_USART_DriverHandleValidate(hClient);
00000008  00000000   NOP
624:                 
625:                     if (clientObj == NULL) {
00000010  00000000   NOP
626:                         /* Driver handle is not valid. Return error */
627:                         SYS_DEBUG(0, "Invalid client handle");
628:                         return DRV_USART_BAUD_SET_ERROR;
629:                     }
630:                 
631:                     /* Return the error. Clear the error before
632:                        returning. */
633:                 
634:                     error = clientObj->error;
00000018  00000000   NOP
635:                     clientObj->error = DRV_USART_ERROR_NONE;
0000001C  00000000   NOP
636:                     return (error);
637:                 }
00000024  00000000   NOP
638:                 
639:                 // *****************************************************************************
640:                 
641:                 /* Function:
642:                     DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
643:                 
644:                   Summary:
645:                     Dynamic implementation of DRV_USART_BaudSet client interface function.
646:                 
647:                   Description:
648:                     This is the dynamic implementation of DRV_USART_BaudSet client interface
649:                     function.
650:                 
651:                   Remarks:
652:                     See drv_usart.h for usage information.
653:                  */
654:                 
655:                 DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud) {
00000000  00000000   NOP
656:                     DRV_USART_OBJ * hDriver;
657:                     DRV_USART_CLIENT_OBJ * client;
658:                     USART_MODULE_ID plibID;
659:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
00000088  00000000   NOP
000000D0  00000000   NOP
660:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
661:                     bool isEnabled = false;
662:                 #endif
663:                 
664:                     /* Validate the handle */
665:                     client = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
666:                 
667:                     if (client == NULL) {
00000014  00000000   NOP
668:                         /* Driver handle is not valid. Return error */
669:                         SYS_DEBUG(0, "Invalid client handle");
670:                         return DRV_USART_BAUD_SET_ERROR;
000000E0  00000000   NOP
671:                     }
672:                 
673:                     hDriver = (DRV_USART_OBJ*) client->hDriver;
0000001C  00000000   NOP
674:                     plibID = hDriver->moduleId;
00000020  00000000   NOP
675:                 
676:                     if (OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) {
677:                         int32_t brgValueLow = 0;
678:                         int32_t brgValueHigh = 0;
679:                 
680:                         brgValueLow = ((hDriver->brgClock / baud) >> 4) - 1;
00000034  00000000   NOP
00000090  00000000   NOP
681:                         brgValueHigh = ((hDriver->brgClock / baud) >> 2) - 1;
00000044  00000000   NOP
682:                 
683:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
684:                         isEnabled = PLIB_USART_ModuleIsBusy(plibID);
685:                         if (isEnabled) {
686:                             PLIB_USART_Disable(plibID);
687:                             while (PLIB_USART_ModuleIsBusy(plibID));
688:                         }
689:                 #endif
690:                         /* Check if the baud value can be set with high baud settings */
691:                         if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX)) {
0000004C  00000000   NOP
692:                             PLIB_USART_BaudRateHighEnable(plibID);
693:                             PLIB_USART_BaudRateHighSet(plibID, hDriver->brgClock, baud);
694:                         }            /* Check if the baud value can be set with low baud settings */
695:                         else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX)) {
00000094  00000000   NOP
696:                             PLIB_USART_BaudRateHighDisable(plibID);
697:                             PLIB_USART_BaudRateSet(plibID, hDriver->brgClock, baud);
698:                         } else {
699:                             retVal = DRV_USART_BAUD_SET_ERROR;
700:                         }
701:                 
702:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
703:                         if (isEnabled) {
704:                             PLIB_USART_Enable(plibID);
705:                         }
706:                 #endif
707:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
708:                     } else {
709:                         /* The mutex timed out */
710:                         SYS_DEBUG(0, "Hardware instance mutex time out in DRV_USART_BaudSet() function");
711:                         retVal = DRV_USART_BAUD_SET_ERROR;
712:                     }
713:                 
714:                     return retVal;
715:                 }
000000E4  00000000   NOP
716:                 
717:                 // *****************************************************************************
718:                 
719:                 /* Function:
720:                     DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
721:                     (
722:                         DRV_HANDLE handle,
723:                         DRV_USART_LINE_CONTROL lineControlMode
724:                     )
725:                 
726:                   Summary:
727:                     Dynamic implementation of DRV_USART_LineControlSet client interface function.
728:                 
729:                   Description:
730:                     This is the dynamic implementation of DRV_USART_LineControlSet client
731:                     interface function.
732:                 
733:                   Remarks:
734:                     See drv_usart.h for usage information.
735:                  */
736:                 
737:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
738:                 (
739:                         DRV_HANDLE handle,
740:                         DRV_USART_LINE_CONTROL lineControlMode
741:                         ) {
00000000  00000000   NOP
742:                     DRV_USART_OBJ * hDriver;
743:                     DRV_USART_CLIENT_OBJ * client;
744:                     USART_MODULE_ID plibID;
745:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
746:                     bool isEnabled = false;
747:                 #endif
748:                 
749:                     /* Validate the driver handle */
750:                     client = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
751:                 
752:                     if (client == NULL) {
00000014  00000000   NOP
753:                         /* Driver handle is not valid. Return error */
754:                 
755:                         SYS_DEBUG(0, "Invalid driver handle");
756:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
00000070  00000000   NOP
757:                     }
758:                 
759:                     hDriver = (DRV_USART_OBJ*) client->hDriver;
0000001C  00000000   NOP
760:                     plibID = hDriver->moduleId;
00000020  00000000   NOP
761:                 
762:                     if (OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) {
763:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
764:                         isEnabled = PLIB_USART_ModuleIsBusy(plibID);
765:                         if (isEnabled) {
766:                             PLIB_USART_Disable(plibID);
767:                             while (PLIB_USART_ModuleIsBusy(plibID));
768:                         }
769:                 #endif
770:                         /* Set the Line Control Mode */
771:                         PLIB_USART_LineControlModeSelect(plibID, lineControlMode);
772:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
773:                         if (isEnabled) {
774:                             PLIB_USART_Enable(plibID);
775:                         }
776:                 #endif
777:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
778:                     } else {
779:                         SYS_DEBUG(0, "Hardware Instance Mutex time out in DRV_USART_LineControlSet() function");
780:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
781:                     }
782:                 
783:                     /* Return success */
784:                     return (DRV_USART_LINE_CONTROL_SET_SUCCESS);
00000068  00000000   NOP
785:                 }
00000074  00000000   NOP
786:                 
787:                 // *****************************************************************************
788:                 
789:                 /* Function:
790:                     void DRV_USART_TasksTransmit (SYS_MODULE_OBJ object )
791:                 
792:                   Summary:
793:                     Dynamic implementation of DRV_USART_TasksTransmit system interface function.
794:                 
795:                   Description:
796:                     This is the dynamic implementation of DRV_USART_TasksTransmit system interface
797:                     function.
798:                 
799:                   Remarks:
800:                     See drv_usart.h for usage information.
801:                  */
802:                 
803:                 void DRV_USART_TasksTransmit(SYS_MODULE_OBJ object) {
9D00ABFC  27BDFFE8   ADDIU SP, SP, -24
9D00AC00  AFBF0014   SW RA, 20(SP)
9D00AC04  AFB00010   SW S0, 16(SP)
804:                     /* This is the USART Driver Transmit tasks routine.
805:                        In this function, the driver checks if a transmit
806:                        interrupt is active and if there are any buffers in
807:                        queue. If so the buffer is serviced. A buffer that
808:                        is serviced completely is removed from the queue.
809:                      */
810:                 
811:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00AC08  00041140   SLL V0, A0, 5
9D00AC0C  000481C0   SLL S0, A0, 7
9D00AC10  02021023   SUBU V0, S0, V0
9D00AC14  3C108000   LUI S0, -32768
9D00AC18  26105A5C   ADDIU S0, S0, 23132
9D00AC1C  02028021   ADDU S0, S0, V0
812:                 
813:                     if ((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY)) {
9D00AC20  92020014   LBU V0, 20(S0)
9D00AC24  10400019   BEQ V0, ZERO, .LVL307, .LBE504, .LBE503, .LBE502
9D00AC28  24020002   ADDIU V0, ZERO, 2
9D00AC2C  8E03000C   LW V1, 12(S0)
9D00AC30  14620017   BNE V1, V0, 0x9D00AC90
9D00AC34  8FBF0014   LW RA, 20(SP)
814:                         /* This instance of the driver is not initialized. Don't
815:                          * do anything */
816:                         return;
817:                     }
818:                 
819:                     if (SYS_INT_SourceStatusGet(hDriver->txInterruptSource)) {
9D00AC38  8E020024   LW V0, 36(S0)
9D00AC58  5040000E   BEQL V0, ZERO, .LVL308
9D00AC5C  8FB00010   LW S0, 16(SP)
820:                         /* The USART driver is configured to generate an
821:                            interrupt when the FIFO is empty. Additionally
822:                            the queue is not empty. Which means there is
823:                            work to done in this routine. */
824:                 
825:                         _DRV_USART_TRANSMIT_BUFFER_QUEUE_TASKS(object);
9D00AC60  0F402D56   JAL _DRV_USART_ByteTransmitTasks
9D00AC64  00000000   NOP
826:                 
827:                         /* Clear up the interrupt flag */
828:                         SYS_INT_SourceStatusClear(hDriver->txInterruptSource);
9D00AC68  8E020024   LW V0, 36(S0)
829:                     }
830:                 }
9D00AC8C  8FBF0014   LW RA, 20(SP)
831:                 
832:                 
833:                 // *****************************************************************************
834:                 
835:                 /* Function:
836:                     void DRV_USART_TasksError (SYS_MODULE_OBJ object );
837:                 
838:                   Summary:
839:                     Maintains the driver's error state machine and implements its ISR
840:                 
841:                   Description:
842:                     This routine is used to maintain the driver's internal error state machine
843:                     and implement its error ISR for interrupt-driven implementations.  In
844:                     polling mode, this function should be called from the SYS_Tasks function.
845:                     In interrupt mode, this function should be called in the error interrupt
846:                     service routine of the USART that is associated with this USART driver
847:                     hardware instance.
848:                 
849:                   Remarks:
850:                     Refer to drv_usart.h for usage information.
851:                  */
852:                 
853:                 void DRV_USART_TasksError(SYS_MODULE_OBJ object) {
9D00AD3C  27BDFFE8   ADDIU SP, SP, -24
9D00AD40  AFBF0014   SW RA, 20(SP)
9D00AD44  AFB00010   SW S0, 16(SP)
854:                     /* This is the USART Driver Error tasks routine. In this function, the
855:                      * driver checks if an error interrupt has occurred. If so the error
856:                      * condition is cleared.  */
857:                 
858:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00AD48  00041140   SLL V0, A0, 5
9D00AD4C  000481C0   SLL S0, A0, 7
9D00AD50  02021023   SUBU V0, S0, V0
9D00AD54  3C108000   LUI S0, -32768
9D00AD58  26105A5C   ADDIU S0, S0, 23132
9D00AD5C  02028021   ADDU S0, S0, V0
859:                 
860:                     if ((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY)) {
9D00AD60  92020014   LBU V0, 20(S0)
9D00AD64  10400019   BEQ V0, ZERO, .LVL347, .LBE522, .LBE521, .LBE520
9D00AD68  24020002   ADDIU V0, ZERO, 2
9D00AD6C  8E03000C   LW V1, 12(S0)
9D00AD70  14620017   BNE V1, V0, 0x9D00ADD0
9D00AD74  8FBF0014   LW RA, 20(SP)
861:                         /* This instance of the driver is not initialized. Don't
862:                          * do anything */
863:                         return;
864:                     }
865:                 
866:                     if (SYS_INT_SourceStatusGet(hDriver->errorInterruptSource)) {
9D00AD78  8E02002C   LW V0, 44(S0)
9D00AD98  5040000E   BEQL V0, ZERO, .LVL348
9D00AD9C  8FB00010   LW S0, 16(SP)
867:                         /* This means an error has occurred */
868:                         _DRV_USART_ERROR_TASKS(object);
9D00ADA0  0F402D77   JAL _DRV_USART_ByteErrorTasks
9D00ADA4  00000000   NOP
869:                 
870:                         /* Clear up the error interrupt flag */
871:                         SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D00ADA8  8E02002C   LW V0, 44(S0)
872:                     }
873:                 }
9D00ADCC  8FBF0014   LW RA, 20(SP)
874:                 
875:                 // *****************************************************************************
876:                 
877:                 /* Function:
878:                     DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus (DRV_HANDLE handle )
879:                 
880:                   Summary:
881:                     Dynamic implementation of DRV_USART_ClientStatus client interface function.
882:                 
883:                   Description:
884:                     This is the dynamic implementation of DRV_USART_ClientStatus client interface
885:                     function.
886:                 
887:                   Remarks:
888:                     See drv_usart.h for usage information.
889:                  */
890:                 
891:                 DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus(DRV_HANDLE handle) {
00000000  00000000   NOP
892:                     DRV_USART_CLIENT_OBJ * client;
893:                 
894:                     /* Validate the driver handle */
895:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
896:                 
897:                     if (client == NULL) {
00000010  00000000   NOP
898:                         /* Driver handle is not valid */
899:                 
900:                         SYS_DEBUG(0, "Invalid driver handle");
901:                         return DRV_USART_CLIENT_STATUS_CLOSED;
902:                     }
903:                 
904:                     /* Return the client status */
905:                     return (client->status);
906:                 }
0000001C  00000000   NOP
907:                 
908:                 // *****************************************************************************
909:                 
910:                 /* Function:
911:                     void DRV_USART_TasksReceive (SYS_MODULE_OBJ object )
912:                 
913:                   Summary:
914:                     Dynamic implementation of DRV_USART_Initialize system interface function.
915:                 
916:                   Description:
917:                     This is the dynamic implementation of DRV_USART_Initialize system interface
918:                     function.
919:                 
920:                   Remarks:
921:                     See drv_usart.h for usage information.
922:                  */
923:                 
924:                 void DRV_USART_TasksReceive(SYS_MODULE_OBJ object) {
9D00AC9C  27BDFFE8   ADDIU SP, SP, -24
9D00ACA0  AFBF0014   SW RA, 20(SP)
9D00ACA4  AFB00010   SW S0, 16(SP)
925:                     /* This is the USART Driver Receive tasks routine. If the receive
926:                        interrupt flag is set, the tasks routines are executed.
927:                      */
928:                 
929:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00ACA8  00041140   SLL V0, A0, 5
9D00ACAC  000481C0   SLL S0, A0, 7
9D00ACB0  02021023   SUBU V0, S0, V0
9D00ACB4  3C108000   LUI S0, -32768
9D00ACB8  26105A5C   ADDIU S0, S0, 23132
9D00ACBC  02028021   ADDU S0, S0, V0
930:                 
931:                     if ((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY)) {
9D00ACC0  92020014   LBU V0, 20(S0)
9D00ACC4  10400019   BEQ V0, ZERO, .LVL325, .LBE513, .LBE512, .LBE511
9D00ACC8  24020002   ADDIU V0, ZERO, 2
9D00ACCC  8E03000C   LW V1, 12(S0)
9D00ACD0  14620017   BNE V1, V0, 0x9D00AD30
9D00ACD4  8FBF0014   LW RA, 20(SP)
932:                         /* This instance of the driver is not initialized. Dont
933:                            do anything */
934:                 
935:                         return;
936:                     }
937:                 
938:                     if (SYS_INT_SourceStatusGet(hDriver->rxInterruptSource)) {
9D00ACD8  8E020028   LW V0, 40(S0)
9D00ACF8  5040000E   BEQL V0, ZERO, .LVL326
9D00ACFC  8FB00010   LW S0, 16(SP)
939:                         _DRV_USART_RECEIVE_BUFFER_QUEUE_TASKS(object);
9D00AD00  0F402E6D   JAL _DRV_USART_ByteReceiveTasks
9D00AD04  00000000   NOP
940:                 
941:                         /* Clear up the interrupt flag */
942:                         SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D00AD08  8E020028   LW V0, 40(S0)
943:                     }
944:                 }
9D00AD2C  8FBF0014   LW RA, 20(SP)
945:                 
946:                 // *****************************************************************************
947:                 
948:                 /* Function:
949:                     DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
950:                 
951:                   Summary:
952:                     Dynamic implementation of DRV_USART_TransferStatus client interface function.
953:                 
954:                   Description:
955:                     This is the dynamic implementation of DRV_USART_TransferStatus client
956:                     interface function.
957:                 
958:                   Remarks:
959:                     See drv_usart.h for usage information.
960:                  */
961:                 
962:                 DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle) {
9D00B948  27BDFFE8   ADDIU SP, SP, -24
9D00B94C  AFBF0014   SW RA, 20(SP)
963:                     DRV_USART_CLIENT_OBJ * client;
964:                     DRV_USART_OBJ * hDriver;
965:                     DRV_USART_TRANSFER_STATUS result = 0;
966:                 
967:                     client = _DRV_USART_DriverHandleValidate(handle);
9D00B950  0F40323D   JAL _DRV_USART_DriverHandleValidate
9D00B954  00000000   NOP
968:                 
969:                     /* Validate the handle */
970:                     if (client == NULL) {
9D00B958  50400013   BEQL V0, ZERO, 0x9D00B9A8
9D00B95C  00001021   ADDU V0, ZERO, ZERO
971:                         SYS_DEBUG(0, "Invalid Driver handle");
972:                         return 0;
973:                     }
974:                 
975:                     hDriver = client->hDriver;
976:                 
977:                     /* If the Rx interrupt flag is set then there is data available
978:                        else there isn't */
979:                     result |= (PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId)) ?
9D00B960  8C420000   LW V0, 0(V0)
9D00B970  24050001   ADDIU A1, ZERO, 1
9D00B974  24060002   ADDIU A2, ZERO, 2
9D00B978  00C4280A   MOVZ A1, A2, A0
9D00B97C  00A02021   ADDU A0, A1, ZERO
980:                             DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT : DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
981:                 
982:                     /* If the TX interrupt flag is set, then the Tx Buffer is empty */
983:                     result |= (PLIB_USART_TransmitterIsEmpty(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY : 0;
9D00B988  24050008   ADDIU A1, ZERO, 8
9D00B98C  0002280A   MOVZ A1, ZERO, V0
9D00B990  00A41025   OR V0, A1, A0
984:                 
985:                     /* Check if the TX buffer is full */
986:                     result |= (PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL : 0;
9D00B99C  24040004   ADDIU A0, ZERO, 4
9D00B9A0  0003200A   MOVZ A0, ZERO, V1
9D00B9A4  00441025   OR V0, V0, A0
987:                 
988:                     return (result);
989:                 }
9D00B9A8  8FBF0014   LW RA, 20(SP)
990:                 
991:                 // *****************************************************************************
992:                 // *****************************************************************************
993:                 // Section: File scope functions
994:                 // *****************************************************************************
995:                 // *****************************************************************************
996:                 
997:                 // *****************************************************************************
998:                 
999:                 /* void _DRV_USART_HardwareSetup
1000:                   (
1001:                        USART_MODULE_ID  plibID,
1002:                        DRV_USART_INIT * init
1003:                   )
1004:                
1005:                  Summary:
1006:                    Initializes the USART module based on the init data structure.
1007:                
1008:                  Description:
1009:                    This function initializes the USART module based on the init data structure.
1010:                
1011:                  Remarks:
1012:                    This is a private function and should not be called directly by the
1013:                    application.
1014:                 */
1015:                
1016:                void _DRV_USART_HardwareSetup(USART_MODULE_ID plibID, DRV_USART_INIT * init) {
1017:                    bool loopbackMode = false;
9D008718  0B4021CA   J .LVL53
9D00871C  00004021   ADDU T0, ZERO, ZERO
1018:                    bool irdaMode = false;
9D0086C8  00004021   ADDU T0, ZERO, ZERO
9D0086CC  0B4021CA   J .LVL53
9D0086D0  0002400A   MOVZ T0, ZERO, V0
9D008714  00003821   ADDU A3, ZERO, ZERO
9D008720  00003821   ADDU A3, ZERO, ZERO
1019:                    bool wakeFromSleep = false;
1020:                    bool stopInIdle = false;
1021:                    bool autoBaud = false;
1022:                
1023:                    /* Check the operational mode and update the relevant flags */
1024:                    switch (init->mode) {
9D0086B0  8CA20008   LW V0, 8(A1)
9D0086B4  24030002   ADDIU V1, ZERO, 2
9D0086B8  10430006   BEQ V0, V1, .LVL45, .LBB335, .LBB336, .LBB337
9D0086BC  24030003   ADDIU V1, ZERO, 3
9D0086C0  10430017   BEQ V0, V1, .LVL52
9D0086C4  2C470001   SLTIU A3, V0, 1
1025:                        case DRV_USART_OPERATION_MODE_ADDRESSED:
1026:                        {
1027:                            PLIB_USART_ReceiverAddressDetectEnable(plibID);
1028:                            PLIB_USART_AddressSet(plibID, init->modeData.AddressedModeInit.address);
9D0086DC  90A3000C   LBU V1, 12(A1)
1029:                #if defined (PLIB_USART_ExistsReceiverAddressAutoDetect)
1030:                            PLIB_USART_ReceiverAddressAutoDetectEnable(plibID, PLIB_USART_AddressGet(plibID));
1031:                #endif
1032:                        }
1033:                            break;
1034:                        case DRV_USART_OPERATION_MODE_IRDA:
1035:                            irdaMode = true;
1036:                            break;
1037:                        case DRV_USART_OPERATION_MODE_LOOPBACK:
1038:                            loopbackMode = true;
9D008724  24080001   ADDIU T0, ZERO, 1
1039:                            break;
1040:                        default:
1041:                            break;
1042:                    }
1043:                
1044:                    /* Handshaking */
1045:                    if (init->handshake != DRV_USART_HANDSHAKE_NONE) {
9D008728  8CA30020   LW V1, 32(A1)
9D00872C  24020002   ADDIU V0, ZERO, 2
9D008730  50620005   BEQL V1, V0, .LVL56
9D008734  8CA20010   LW V0, 16(A1)
1046:                        /* Note that this mode is exclusive of DRV_USART_OPERATION_MODE_IRDA.
1047:                           In that if the driver must be set up to use DRV_USART_OPERATION_MODE_IRDA
1048:                           then handshake parameter of the init data structure must be
1049:                           DRV_USART_HANDSHAKE_NONE. Setting up the driver to use Simplex or
1050:                           flow control will over ride the requirements of the IRDA mode.*/
1051:                
1052:                        /* Set the handshake mode to either simplex or flow control */
1053:                
1054:                        PLIB_USART_HandshakeModeSelect(plibID, init->handshake);
1055:                    }
1056:                
1057:                
1058:                    /* Wake up the part from sleep on any activity on the RX Line */
1059:                    wakeFromSleep = (init->flags & DRV_USART_INIT_FLAG_WAKE_ON_START);
9D008744  8CA20010   LW V0, 16(A1)
1060:                
1061:                    /* When the CPU enters IDLE mode, stop the USART */
1062:                    stopInIdle = (init->flags & DRV_USART_INIT_FLAG_STOP_IN_IDLE);
9D008748  7C460080   EXT A2, V0, 2, 1
1063:                
1064:                    /* When the CPU enters IDLE mode, stop the USART */
1065:                    autoBaud = (init->flags & DRV_USART_INIT_FLAG_AUTO_BAUD);
9D00874C  7C490040   EXT T1, V0, 1, 1
1066:                
1067:                    /* Initialize the USART based on initialization data structure */
1068:                    PLIB_USART_InitializeModeGeneral(plibID, autoBaud, loopbackMode,
1069:                            wakeFromSleep, irdaMode, stopInIdle);
1070:                
1071:                    /* Set the line control mode */
1072:                    PLIB_USART_LineControlModeSelect(plibID, init->lineControl);
9D00878C  8CA20018   LW V0, 24(A1)
1073:                
1074:                    /* We set the receive interrupt mode to receive an interrupt whenever FIFO
1075:                       is not empty */
1076:                    PLIB_USART_InitializeOperation(plibID, USART_RECEIVE_FIFO_ONE_CHAR,
9D0087BC  8CA30024   LW V1, 36(A1)
1077:                            USART_TRANSMIT_FIFO_IDLE, init->linesEnable);
1078:                
1079:                    /* Set the baud rate and enable the USART */
1080:                    PLIB_USART_BaudSetAndEnable(plibID, init->brgClock, init->baud);
9D0087E8  8CA60014   LW A2, 20(A1)
9D0087EC  8CA2001C   LW V0, 28(A1)
1081:                }
1082:                
1083:                // *****************************************************************************
1084:                
1085:                /* Function:
1086:                    DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1087:                
1088:                  Summary:
1089:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1090:                
1091:                  Description:
1092:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1093:                    This function return NULL if the handle is invalid else it return a pointer
1094:                    to the USART Driver Client Object associated with this handle.
1095:                
1096:                  Remarks:
1097:                    This is a private function and should not be called directly by an
1098:                    application.
1099:                 */
1100:                
1101:                DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle) {
1102:                    /* This function returns the pointer to the client object that is
1103:                       associated with this handle if the handle is valid. Returns NULL
1104:                       otherwise. */
1105:                
1106:                    DRV_USART_CLIENT_OBJ * client;
1107:                
1108:                    if ((DRV_HANDLE_INVALID == handle) ||
9D00C8F4  2482FFFF   ADDIU V0, A0, -1
9D00C8F8  2C42FFFE   SLTIU V0, V0, -2
9D00C8FC  10400005   BEQ V0, ZERO, .LVL113
9D00C900  00000000   NOP
1109:                            (0 == handle)) {
1110:                        return (NULL);
1111:                    }
1112:                
1113:                    client = (DRV_USART_CLIENT_OBJ *) handle;
1114:                
1115:                    if (!client->inUse) {
9D00C904  90820008   LBU V0, 8(A0)
1116:                        return (NULL);
9D00C908  0002200A   MOVZ A0, ZERO, V0
9D00C90C  03E00008   JR RA
9D00C910  00801021   ADDU V0, A0, ZERO
1117:                    }
1118:                
1119:                    return (client);
1120:                }
9D00C914  03E00008   JR RA
1121:                
1122:                // *****************************************************************************
1123:                // *****************************************************************************
1124:                // Section: File scope functions
1125:                // *****************************************************************************
1126:                // *****************************************************************************
1127:                
1128:                bool _DRV_USART_ClientBufferQueueObjectsRemove(DRV_USART_CLIENT_OBJ * clientObj) {
00000000  00000000   NOP
1129:                    DRV_USART_OBJ * dObj = clientObj->hDriver;
00000014  00000000   NOP
1130:                    bool interruptWasEnabled = false;
1131:                    DRV_USART_BUFFER_OBJ * iterator = NULL;
1132:                
1133:                    if (OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) {
1134:                        /* Disable the transmit interrupt */
1135:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource);
0000002C  00000000   NOP
1136:                        iterator = dObj->queueWrite;
00000034  00000000   NOP
1137:                        while (iterator != NULL) {
00000038  00000000   NOP
00000088  00000000   NOP
1138:                            if (clientObj == (DRV_USART_CLIENT_OBJ *) iterator->hClient) {
00000040  00000000   NOP
1139:                                /* That means this buffer object is owned
1140:                                   by this client. This buffer object should
1141:                                   be removed. The following code removes
1142:                                   the object from a doubly linked list queue. */
1143:                
1144:                                iterator->inUse = false;
0000004C  00000000   NOP
1145:                                if (iterator->previous != NULL) {
00000050  00000000   NOP
1146:                                    iterator->previous->next = iterator->next;
0000005C  00000000   NOP
1147:                                }
1148:                                if (iterator->next != NULL) {
00000064  00000000   NOP
1149:                                    iterator->next->previous = iterator->previous;
00000070  00000000   NOP
1150:                                }
1151:                                /* Decrementing Current queue size */
1152:                                dObj->queueSizeCurrentWrite--;
00000078  00000000   NOP
1153:                
1154:                            }
1155:                            iterator = iterator->next;
00000084  00000000   NOP
1156:                        }
1157:                        /* If there are no buffers in the write queue.
1158:                         * Make the head pointer point to NULL */
1159:                        if (dObj->queueSizeCurrentWrite == 0) {
00000090  00000000   NOP
1160:                            dObj->queueWrite = NULL;
1161:                        } else {
1162:                            /* Iterate to update the head pointer to point
1163:                             * the first valid buffer object in the queue */
1164:                            iterator = dObj->queueWrite;
1165:                            while (iterator != NULL) {
000000A4  00000000   NOP
000000DC  00000000   NOP
1166:                                if (iterator->inUse == true) {
000000AC  00000000   NOP
000000C4  00000000   NOP
1167:                                    dObj->queueWrite = iterator;
000000BC  00000000   NOP
1168:                                    break;
000000D4  00000000   NOP
1169:                                }
1170:                                iterator = iterator->next;
1171:                            }
1172:                        }
1173:                
1174:                
1175:                        /* Re-enable the interrupt if it was enabled */
1176:                        if (interruptWasEnabled) {
000000E4  00000000   NOP
1177:                            _DRV_USART_InterruptSourceEnable(dObj->txInterruptSource);
000000EC  00000000   NOP
1178:                        }
1179:                
1180:                        /* Now check the receive buffer queue. Start by disabling the
1181:                           receive interrupt */
1182:                
1183:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource);
0000010C  00000000   NOP
1184:                        iterator = dObj->queueRead;
00000114  00000000   NOP
1185:                        while (iterator != NULL) {
00000118  00000000   NOP
00000168  00000000   NOP
1186:                            if (clientObj == (DRV_USART_CLIENT_OBJ *) iterator->hClient) {
00000120  00000000   NOP
1187:                                /* That means this buffer object is owned
1188:                                   by this client. This buffer object should
1189:                                   be removed. The following code removed
1190:                                   the object from a doubly linked list queue. */
1191:                
1192:                                iterator->inUse = false;
0000012C  00000000   NOP
1193:                                if (iterator->previous != NULL) {
00000130  00000000   NOP
1194:                                    iterator->previous->next = iterator->next;
0000013C  00000000   NOP
1195:                                }
1196:                                if (iterator->next != NULL) {
00000144  00000000   NOP
1197:                                    iterator->next->previous = iterator->previous;
00000150  00000000   NOP
1198:                                }
1199:                                /* Decrementing Current queue size */
1200:                                dObj->queueSizeCurrentRead--;
00000158  00000000   NOP
1201:                            }
1202:                            iterator = iterator->next;
00000164  00000000   NOP
1203:                        }
1204:                        /* If there are no buffers in the read queue.
1205:                         * Make the head pointer point to NULL */
1206:                        if (dObj->queueSizeCurrentRead == 0) {
00000170  00000000   NOP
1207:                            dObj->queueRead = NULL;
1208:                        } else {
1209:                            /* Iterate to update the head pointer to point
1210:                             * the first valid buffer object in the queue */
1211:                            iterator = dObj->queueRead;
1212:                            while (iterator != NULL) {
00000184  00000000   NOP
000001BC  00000000   NOP
1213:                                if (iterator->inUse == true) {
0000018C  00000000   NOP
000001A4  00000000   NOP
1214:                                    dObj->queueRead = iterator;
0000019C  00000000   NOP
1215:                                    break;
000001B4  00000000   NOP
1216:                                }
1217:                                iterator = iterator->next;
1218:                            }
1219:                        }
1220:                
1221:                        if (interruptWasEnabled) {
000001C4  00000000   NOP
1222:                            _DRV_USART_InterruptSourceEnable(dObj->rxInterruptSource);
000001CC  00000000   NOP
1223:                        }
1224:                
1225:                        /* Unlock the mutex */
1226:                
1227:                        OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
1228:                    } else {
1229:                        /* The case where the mutex lock timed out and the
1230:                           client buffer objects could not be removed from
1231:                           the driver queue, the close function should fail. */
1232:                
1233:                        return false;
1234:                    }
1235:                
1236:                    return true;
000001F8  00000000   NOP
1237:                }
000001FC  00000000   NOP
1238:                
1239:                void _DRV_USART_BufferQueueRxTasks(SYS_MODULE_OBJ object) {
00000000  00000000   NOP
1240:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
00000014  00000000   NOP
1241:                    DRV_USART_BUFFER_OBJ * bufferObj;
1242:                    DRV_USART_CLIENT_OBJ * client;
1243:                    USART_MODULE_ID plibID;
1244:                
1245:                    bool status;
1246:                
1247:                    plibID = hDriver->moduleId;
1248:                
1249:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1250:                       routine would be called from another thread. We need to get the driver
1251:                       instance mutex before updating the queue. If the driver is configured for
1252:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1253:                
1254:                    if (DRV_USART_INTERRUPT_MODE == false) {
1255:                        if (OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) {
1256:                            /* We were able to take the mutex */
1257:                        } else {
1258:                            /* The mutex acquisition timed out. Return with an
1259:                               invalid handle. This code will not execute
1260:                               if there is no RTOS. */
1261:                            return;
1262:                        }
1263:                    }
1264:                
1265:                    /* In this function, the driver checks if there are any buffers in queue. If
1266:                       so the buffer is serviced. A buffer that is serviced completely is
1267:                       removed from the queue. Start by getting the buffer at the head of the
1268:                       queue */
1269:                
1270:                    bufferObj = hDriver->queueRead;
0000002C  00000000   NOP
1271:                
1272:                    if (bufferObj != NULL) {
00000030  00000000   NOP
1273:                        /* The USART driver is configured to generate an interrupt when the FIFO
1274:                           is not empty. Additionally the queue is not empty. Which means there
1275:                           is work to done in this routine. Read data from the FIFO until either
1276:                           the FIFO is empty or until we have read the requested number of bytes.
1277:                         */
1278:                        while ((PLIB_USART_ReceiverDataIsAvailable(plibID))
00000044  00000000   NOP
00000084  00000000   NOP
1279:                                && (bufferObj->nCurrentBytes < bufferObj->size)) {
0000004C  00000000   NOP
0000008C  00000000   NOP
1280:                            bufferObj->buffer[bufferObj->nCurrentBytes] = PLIB_USART_ReceiverByteReceive(plibID);
00000064  00000000   NOP
1281:                            bufferObj->nCurrentBytes++;
00000070  00000000   NOP
1282:                        }
1283:                
1284:                        /* Check if this buffer is done */
1285:                        if (bufferObj->nCurrentBytes >= bufferObj->size) {
000000A4  00000000   NOP
1286:                            /* This means the buffer is completed. If there
1287:                               is a callback registered with client, then
1288:                               call it */
1289:                
1290:                            client = (DRV_USART_CLIENT_OBJ *) bufferObj->hClient;
000000B4  00000000   NOP
1291:                            if ((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD)) {
000000B8  00000000   NOP
1292:                                /* Call the event handler. We additionally increment the
1293:                                   interrupt nesting count which lets the driver functions
1294:                                   that are called from the event handler know that an
1295:                                   interrupt context is active.
1296:                                 */
1297:                
1298:                                hDriver->interruptNestingCount++;
000000D4  00000000   NOP
1299:                
1300:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
000000E0  00000000   NOP
1301:                                        bufferObj->bufferHandle,
1302:                                        client->context);
1303:                
1304:                                hDriver->interruptNestingCount--;
000000F4  00000000   NOP
1305:                            }
1306:                
1307:                            /* Get the next buffer in the queue and deallocate
1308:                               this buffer */
1309:                
1310:                            hDriver->queueRead = bufferObj->next;
00000100  00000000   NOP
1311:                            bufferObj->inUse = false;
00000108  00000000   NOP
1312:                            hDriver->queueSizeCurrentRead--;
0000010C  00000000   NOP
1313:                
1314:                            /* Reset the next and previous pointers */
1315:                            bufferObj->next = NULL;
00000118  00000000   NOP
1316:                            bufferObj->previous = NULL;
0000011C  00000000   NOP
1317:                
1318:                            /* Reset the current head's previous pointer */
1319:                            if (hDriver->queueRead != NULL) {
00000120  00000000   NOP
1320:                                hDriver->queueRead->previous = NULL;
1321:                            }
1322:                
1323:                            if (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE) {
0000012C  00000000   NOP
1324:                                /* This means we should post the semaphore */
1325:                                _DRV_USART_SEM_POST(&(client->semReadDone));
1326:                            }
1327:                        }
1328:                    }
1329:                
1330:                    if (hDriver->queueRead == NULL) {
00000148  00000000   NOP
1331:                        /* The queue is empty. We can disable the interrupt */
1332:                        status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
00000154  00000000   NOP
1333:                        /* Ignore the warning */
1334:                        (void) status;
1335:                    }
1336:                
1337:                    /* Release the mutex */
1338:                
1339:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1340:                }
0000015C  00000000   NOP
1341:                
1342:                void _DRV_USART_BufferQueueTxTasks(SYS_MODULE_OBJ object) {
00000000  00000000   NOP
1343:                    /* Start by getting the buffer at the head of queue. */
1344:                
1345:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
00000018  00000000   NOP
1346:                    DRV_USART_BUFFER_OBJ * bufferObj;
1347:                    DRV_USART_CLIENT_OBJ * client;
1348:                    USART_MODULE_ID plibID;
1349:                
1350:                    bool status;
1351:                
1352:                    bufferObj = hDriver->queueWrite;
00000030  00000000   NOP
1353:                    plibID = hDriver->moduleId;
1354:                
1355:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1356:                       routine would be called from another thread. We need to get the driver
1357:                       instance mutex before updating the queue. If the driver is configured for
1358:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1359:                
1360:                    if (DRV_USART_INTERRUPT_MODE == false) {
1361:                        if (OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER)) {
1362:                            /* We were able to take the mutex */
1363:                        } else {
1364:                            /* The mutex acquisition timed out. Return with an
1365:                               invalid handle. This code will not execute
1366:                               if there is no RTOS. */
1367:                            return;
1368:                        }
1369:                    }
1370:                
1371:                    if (bufferObj != NULL) {
00000034  00000000   NOP
1372:                        /* This means the queue is not empty. Check if this buffer is done */
1373:                        if (bufferObj->nCurrentBytes >= bufferObj->size) {
0000003C  00000000   NOP
1374:                            /* This means the buffer is completed. If there
1375:                               is a callback registered with client, then
1376:                               call it */
1377:                
1378:                            client = (DRV_USART_CLIENT_OBJ *) bufferObj->hClient;
00000050  00000000   NOP
1379:                            if ((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD)) {
00000054  00000000   NOP
1380:                                /* Before calling the event handler, the interrupt nesting
1381:                                   counter is incremented. This will allow driver routine that
1382:                                   are called from the event handler to know the interrupt
1383:                                   nesting level. Events are only generated for buffers that
1384:                                   were submitted using the buffer add routine */
1385:                
1386:                                hDriver->interruptNestingCount++;
00000070  00000000   NOP
1387:                
1388:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
0000007C  00000000   NOP
1389:                                        bufferObj->bufferHandle,
1390:                                        client->context);
1391:                
1392:                                /* Decrement the nesting count */
1393:                                hDriver->interruptNestingCount--;
00000090  00000000   NOP
1394:                            }
1395:                
1396:                            /* Get the next buffer in the queue and deallocate
1397:                             * this buffer */
1398:                
1399:                            hDriver->queueWrite = bufferObj->next;
0000009C  00000000   NOP
1400:                            bufferObj->inUse = false;
000000A4  00000000   NOP
1401:                            hDriver->queueSizeCurrentWrite--;
000000A8  00000000   NOP
1402:                
1403:                            /* Reset the next and previous pointers */
1404:                            bufferObj->next = NULL;
000000B4  00000000   NOP
1405:                            bufferObj->previous = NULL;
000000B8  00000000   NOP
1406:                
1407:                            /* Reset the current head's previous pointer */
1408:                            if (hDriver->queueWrite != NULL) {
000000BC  00000000   NOP
1409:                                hDriver->queueWrite->previous = NULL;
1410:                            }
1411:                
1412:                            if (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE) {
000000C8  00000000   NOP
1413:                                /* This means we should post the semaphore */
1414:                                _DRV_USART_SEM_POST(&(client->semWriteDone));
1415:                
1416:                            }
1417:                        }
1418:                    }
1419:                
1420:                    /* Check if the queue is still not empty and process
1421:                       the buffer */
1422:                
1423:                    if (hDriver->queueWrite != NULL) {
000000E4  00000000   NOP
1424:                        bufferObj = hDriver->queueWrite;
1425:                        if (hDriver->operationMode == DRV_USART_OPERATION_MODE_ADDRESSED) {
000000F8  00000000   NOP
1426:                            uint16_t *buf_ptr;
1427:                            buf_ptr = (uint16_t *) bufferObj->buffer;
00000134  00000000   NOP
1428:                
1429:                            /* Fill up the FIFO with data until the FIFO is full
1430:                               and we have data to send */
1431:                            while ((!PLIB_USART_TransmitterBufferIsFull(plibID))
00000138  00000000   NOP
00000184  00000000   NOP
1432:                                    && (bufferObj->nCurrentBytes < bufferObj->size)) {
0000018C  00000000   NOP
1433:                                if ((bufferObj->nCurrentBytes == 0) && (false == bufferObj->isAddressSent)) {
00000140  00000000   NOP
1434:                                    /* Send Address */
1435:                                    PLIB_USART_Transmitter9BitsSend(plibID, bufferObj->address, true);
1436:                                    bufferObj->isAddressSent = true;
00000160  00000000   NOP
1437:                                } else {
1438:                                    /* Send data */
1439:                                    PLIB_USART_Transmitter9BitsSend(plibID, buf_ptr[bufferObj->nCurrentBytes], false);
1440:                                    bufferObj->nCurrentBytes++; // Here it is incrementing the 16-bit words number.
00000170  00000000   NOP
1441:                                }
1442:                            }
1443:                        } else {
1444:                            /* Fill up the FIFO with data until the FIFO is full
1445:                               and we have data to send */
1446:                            while ((!PLIB_USART_TransmitterBufferIsFull(plibID))
00000110  00000000   NOP
000001C8  00000000   NOP
1447:                                    && (bufferObj->nCurrentBytes < bufferObj->size)) {
00000118  00000000   NOP
000001D0  00000000   NOP
1448:                                /* Send data */
1449:                                PLIB_USART_TransmitterByteSend(plibID, bufferObj->buffer[bufferObj->nCurrentBytes]);
000001A8  00000000   NOP
1450:                                bufferObj->nCurrentBytes++;
000001B4  00000000   NOP
1451:                            }
1452:                        }
1453:                    } else {
1454:                        /* If the queue is empty, then disable the TX interrupt */
1455:                        status = _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
000001E8  00000000   NOP
1456:                        /* Ignore the warning */
1457:                        (void) status;
1458:                    }
1459:                
1460:                    /* Release the mutex */
1461:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1462:                }
0000012C  00000000   NOP
000001F0  00000000   NOP
1463:                
1464:                void _DRV_USART_BufferQueueErrorTasks(SYS_MODULE_OBJ object) {
00000000  00000000   NOP
1465:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
00000014  00000000   NOP
1466:                    DRV_USART_BUFFER_OBJ * bufferObj;
1467:                    DRV_USART_CLIENT_OBJ * clientObj;
1468:                    bool mutexGrabbed = true;
1469:                    bool status = false;
1470:                
1471:                    /* USART driver will take care that TX erros( like overflow etc) are not 
1472:                     * going to occur at any time based on checks before write.
1473:                     * So, only RX errors are to be handled/reported */
1474:                
1475:                    /* Get the RX buffer at the head */
1476:                    bufferObj = hDriver->queueRead;
0000002C  00000000   NOP
1477:                
1478:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1479:                     * routine would be called from another thread. We need to get the driver
1480:                     * instance mutex before updating the queue. If the driver is configured for
1481:                     * interrupt mode, then OSAL_MUTEX_Lock will compile to true */
1482:                
1483:                    if (DRV_USART_INTERRUPT_MODE == false) {
1484:                        if (!OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER)) {
1485:                            /* The mutex acquisition timed out.
1486:                             * This code will not execute if there is no RTOS. */
1487:                            mutexGrabbed = false;
1488:                        }
1489:                    }
1490:                
1491:                    /* mutexGrabbed will always be true for non-RTOS case.
1492:                     * Will be false when mutex aquisition timed out in RTOS mode */
1493:                    if (true == mutexGrabbed) {
1494:                
1495:                        if (bufferObj != NULL) {
00000030  00000000   NOP
1496:                            /* Get the client objact */
1497:                            clientObj = (DRV_USART_CLIENT_OBJ *) bufferObj->hClient;
00000038  00000000   NOP
1498:                
1499:                            /* Update the USART client error flag */
1500:                            clientObj->error = PLIB_USART_ErrorsGet(hDriver->moduleId);
00000048  00000000   NOP
1501:                
1502:                            /* Clear error condition */
1503:                            _DRV_USART_ErrorConditionClear(hDriver);
0000004C  00000000   NOP
1504:                
1505:                            /* Call event handler in Buffer queue request only.
1506:                             * If it's a File i/o request then DRV_USART_Read call itself 
1507:                             * will return with error result */
1508:                            if ((clientObj->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD)) {
00000054  00000000   NOP
1509:                                /* Call the event handler with buffer event error state */
1510:                                clientObj->eventHandler(DRV_USART_BUFFER_EVENT_ERROR,
00000070  00000000   NOP
1511:                                        bufferObj->bufferHandle,
1512:                                        clientObj->context);
1513:                            }
1514:                
1515:                
1516:                            /* Get the next buffer in the queue and deallocate
1517:                             * this buffer */
1518:                            hDriver->queueRead = bufferObj->next;
00000080  00000000   NOP
1519:                            bufferObj->inUse = false;
00000088  00000000   NOP
1520:                            hDriver->queueSizeCurrentRead--;
0000008C  00000000   NOP
1521:                
1522:                            /* Reset the next and previous pointers */
1523:                            bufferObj->next = NULL;
00000098  00000000   NOP
1524:                            bufferObj->previous = NULL;
0000009C  00000000   NOP
1525:                
1526:                            /* If queue head is not null, update buffer pointer parameters*/
1527:                            if (hDriver->queueRead != NULL) {
000000A0  00000000   NOP
1528:                                /* Reset the updated head's previous pointer */
1529:                                hDriver->queueRead->previous = NULL;
1530:                            } else {
1531:                                /* Queue is empty disable the RX interrupt */
1532:                                status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
000000B4  00000000   NOP
1533:                
1534:                                /* Ignore the warning */
1535:                                (void) status;
1536:                            }
1537:                        } else {
1538:                            /* There is no buffer in the queue.
1539:                             * Flush the RX to clear the error condition */
1540:                            _DRV_USART_ErrorConditionClear(hDriver);
000000C4  00000000   NOP
1541:                        }
1542:                    }
1543:                
1544:                    /* Release the mutex in RTOS environment*/
1545:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1546:                }
000000BC  00000000   NOP
000000CC  00000000   NOP
1547:                
1548:                void _DRV_USART_ErrorConditionClear(DRV_USART_OBJ *hDriver) {
1549:                    uint8_t dummyData = 0u;
1550:                    /* RX length = (FIFO level + RX register) */
1551:                    uint8_t RXlength = _DRV_USART_RX_DEPTH;
1552:                
1553:                    /* If it's a overrun error then clear it to flush FIFO */
1554:                    if (USART_ERROR_RECEIVER_OVERRUN & PLIB_USART_ErrorsGet(hDriver->moduleId)) {
9D00AFB8  7C630040   EXT V1, V1, 1, 1
9D00AFBC  5060000C   BEQL V1, ZERO, .LVL261, .LBB484, .LBB485, .LBB486
9D00AFC0  8C830000   LW V1, 0(A0)
1555:                        PLIB_USART_ReceiverOverrunErrorClear(hDriver->moduleId);
1556:                    }
1557:                
1558:                    /* Read existing error bytes from FIFO to clear parity and framing error flags*/
1559:                    while ((USART_ERROR_PARITY | USART_ERROR_FRAMING) & PLIB_USART_ErrorsGet(hDriver->moduleId)) {
9D00AFFC  30A50006   ANDI A1, A1, 6
9D00B000  14A0FFF4   BNE A1, ZERO, .LVL257, .LBB481, .LBB482, .LBB483
9D00B004  00000000   NOP
1560:                        dummyData = PLIB_USART_ReceiverByteReceive(hDriver->moduleId);
1561:                        RXlength--;
1562:                
1563:                        /* Try to flush error bytes for one full FIFO and exit instead of 
1564:                         * blocking here if more error bytes are received*/
1565:                        if (0u == RXlength) {
9D00AFE0  14400004   BNE V0, ZERO, .LVL262
9D00AFE4  00000000   NOP
9D00AFE8  0B402C03   J .LVL264, .LBB487, .LBB488, .LBB489
9D00AFEC  8C82002C   LW V0, 44(A0)
1566:                            break;
1567:                        }
1568:                    }
1569:                
1570:                    /* Ignore the warning */
1571:                    (void) dummyData;
1572:                
1573:                    /* Clear error interrupt flag */
1574:                    SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D00B008  8C82002C   LW V0, 44(A0)
1575:                
1576:                    /* Clear up the receive interrupt flag so that RX interrupt is not 
1577:                     * triggered for error bytes*/
1578:                    SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D00B02C  8C820028   LW V0, 40(A0)
1579:                }
1580:                
1581:                void _DRV_USART_ByteTransmitTasks(SYS_MODULE_OBJ object) {
9D00B558  27BDFFE0   ADDIU SP, SP, -32
9D00B55C  AFBF001C   SW RA, 28(SP)
9D00B560  AFB10018   SW S1, 24(SP)
9D00B564  AFB00014   SW S0, 20(SP)
9D00B568  00808021   ADDU S0, A0, ZERO
1582:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00B56C  00041140   SLL V0, A0, 5
9D00B570  000489C0   SLL S1, A0, 7
9D00B574  02221023   SUBU V0, S1, V0
9D00B578  3C118000   LUI S1, -32768
9D00B57C  26315A5C   ADDIU S1, S1, 23132
9D00B580  02228821   ADDU S1, S1, V0
1583:                
1584:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->txInterruptSource)) {
9D00B584  8E220024   LW V0, 36(S1)
9D00B5A4  10600009   BEQ V1, ZERO, 0x9D00B5CC
9D00B5A8  8FBF001C   LW RA, 28(SP)
1585:                        /* Disable the interrupt, to avoid calling ISR continuously*/
1586:                        _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
9D00B5AC  0F402FE0   JAL SYS_INT_SourceDisable
9D00B5B0  00402021   ADDU A0, V0, ZERO
1587:                
1588:                        if (hDriver->transmitCallback != NULL) {
9D00B5B4  8E220054   LW V0, 84(S1)
9D00B5B8  10400004   BEQ V0, ZERO, 0x9D00B5CC
9D00B5BC  8FBF001C   LW RA, 28(SP)
1589:                            hDriver->transmitCallback(object);
9D00B5C0  0040F809   JALR V0
9D00B5C4  3204FFFF   ANDI A0, S0, -1
1590:                        }
1591:                    }
1592:                
1593:                }
9D00B5C8  8FBF001C   LW RA, 28(SP)
1594:                
1595:                void _DRV_USART_ByteReceiveTasks(SYS_MODULE_OBJ object) {
9D00BA00  27BDFFE8   ADDIU SP, SP, -24
9D00BA04  AFBF0014   SW RA, 20(SP)
1596:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00B9B4  00041140   SLL V0, A0, 5
9D00B9B8  000419C0   SLL V1, A0, 7
9D00B9BC  00621023   SUBU V0, V1, V0
9D00B9C0  3C038000   LUI V1, -32768
9D00B9C4  24635A5C   ADDIU V1, V1, 23132
9D00B9C8  00621821   ADDU V1, V1, V0
1597:                
1598:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->rxInterruptSource)) {
9D00B9CC  8C620028   LW V0, 40(V1)
9D00B9EC  1040000A   BEQ V0, ZERO, .LCFI33
9D00B9F0  00000000   NOP
1599:                        if (hDriver->receiveCallback != NULL) {
9D00B9F4  8C620058   LW V0, 88(V1)
9D00B9F8  10400007   BEQ V0, ZERO, .LCFI33
9D00B9FC  00000000   NOP
1600:                            hDriver->receiveCallback(object);
9D00BA08  0040F809   JALR V0
9D00BA0C  3084FFFF   ANDI A0, A0, -1
1601:                        }
1602:                    }
1603:                }
9D00BA10  8FBF0014   LW RA, 20(SP)
1604:                
1605:                void _DRV_USART_ByteErrorTasks(SYS_MODULE_OBJ object) {
9D00B5DC  27BDFFE0   ADDIU SP, SP, -32
9D00B5E0  AFBF001C   SW RA, 28(SP)
9D00B5E4  AFB10018   SW S1, 24(SP)
9D00B5E8  AFB00014   SW S0, 20(SP)
9D00B5EC  00808021   ADDU S0, A0, ZERO
1606:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00B5F0  00041140   SLL V0, A0, 5
9D00B5F4  000489C0   SLL S1, A0, 7
9D00B5F8  02221023   SUBU V0, S1, V0
9D00B5FC  3C118000   LUI S1, -32768
9D00B600  26315A5C   ADDIU S1, S1, 23132
9D00B604  02228821   ADDU S1, S1, V0
1607:                
1608:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->errorInterruptSource)) {
9D00B608  8E22002C   LW V0, 44(S1)
9D00B628  10400009   BEQ V0, ZERO, 0x9D00B650
9D00B62C  8FBF001C   LW RA, 28(SP)
1609:                        /* Clear error condition */
1610:                        _DRV_USART_ErrorConditionClear(hDriver);
9D00B630  0F402BEC   JAL _DRV_USART_ErrorConditionClear
9D00B634  02202021   ADDU A0, S1, ZERO
1611:                
1612:                        if (hDriver->errorCallback != NULL) {
9D00B638  8E22005C   LW V0, 92(S1)
9D00B63C  10400004   BEQ V0, ZERO, 0x9D00B650
9D00B640  8FBF001C   LW RA, 28(SP)
1613:                            hDriver->errorCallback(object);
9D00B644  0040F809   JALR V0
9D00B648  3204FFFF   ANDI A0, S0, -1
1614:                        }
1615:                    }
1616:                }
9D00B64C  8FBF001C   LW RA, 28(SP)
1617:                
1618:                /*******************************************************************************
1619:                 End of File
1620:                 */
1621:                
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/uart_handler.c  ---
1:                   #include "uart_Handler.h"
2:                   #include "app.h"
3:                   unsigned int UART_buff_modulo_inc(const unsigned int value, const unsigned int modulus);
4:                   void RXEventHandler(const SYS_MODULE_INDEX index);
5:                   void TXEventHandler(const SYS_MODULE_INDEX index);
6:                   
7:                   volatile bool Transmit_stall[6];
8:                   
9:                   unsigned char transmitArrays[6][UART_BUFFER_SIZE];
10:                  unsigned char receiveArrays[6][UART_BUFFER_SIZE];
11:                  
12:                  UART_Object_t *_TXEventHandlerUARTobjects[6];
13:                  UART_Object_t *_RXEventHandlerUARTobjects[6];
14:                  /*  
15:                   * NOTE:
16:                   * If you have separate uart modules for the same uart object call the InitRXUARTModule & InitRTXUARTModule
17:                   * opposded to InitUARTModule below
18:                   */
19:                  bool InitUARTModule(UART_Object_t* _UART, SYS_MODULE_INDEX _uartModule)
20:                  {
9D00B218  27BDFFE0   ADDIU SP, SP, -32
9D00B21C  AFBF001C   SW RA, 28(SP)
9D00B220  AFB10018   SW S1, 24(SP)
9D00B224  AFB00014   SW S0, 20(SP)
9D00B228  00808021   ADDU S0, A0, ZERO
9D00B22C  00A08821   ADDU S1, A1, ZERO
21:                      _UART->RxBuffer = createRingBuffer(_UART->RxBuffer,UART_BUFFER_SIZE);
9D00B230  8C840000   LW A0, 0(A0)
9D00B234  0F400044   JAL createRingBuffer
9D00B238  24050100   ADDIU A1, ZERO, 256
9D00B23C  AE020000   SW V0, 0(S0)
22:                      _UART->TxBuffer = createRingBuffer(_UART->TxBuffer,UART_BUFFER_SIZE);
9D00B240  8E040004   LW A0, 4(S0)
9D00B244  0F400044   JAL createRingBuffer
9D00B248  24050100   ADDIU A1, ZERO, 256
9D00B24C  AE020004   SW V0, 4(S0)
23:                  
24:                      //making the TX&RX modules and handlers all the same
25:                      _UART->uartTXModule = _uartModule;
9D00B250  A611001A   SH S1, 26(S0)
26:                      _UART->uartRXModule = _uartModule;
9D00B254  A6110018   SH S1, 24(S0)
27:                      
28:                      _UART->uartTXHandle = DRV_USART_Open(_uartModule, DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE | DRV_IO_INTENT_SHARED );
9D00B258  02202021   ADDU A0, S1, ZERO
9D00B25C  0F4024B8   JAL DRV_USART_Open
9D00B260  24050007   ADDIU A1, ZERO, 7
9D00B264  AE020014   SW V0, 20(S0)
29:                      _UART->uartRXHandle = _UART->uartTXHandle;
9D00B268  AE020010   SW V0, 16(S0)
30:                      
31:                      InitRXEventHandler(_UART);
9D00B26C  0F403142   JAL InitRXEventHandler
9D00B270  02002021   ADDU A0, S0, ZERO
32:                      InitTXEventHandler(_UART);
9D00B274  0F403151   JAL InitTXEventHandler
9D00B278  02002021   ADDU A0, S0, ZERO
33:                      
34:                      if (DRV_HANDLE_INVALID == _UART->uartTXHandle && DRV_HANDLE_INVALID == _UART->uartRXHandle)
9D00B27C  8E040014   LW A0, 20(S0)
9D00B280  2403FFFF   ADDIU V1, ZERO, -1
9D00B284  14830004   BNE A0, V1, 0x9D00B298
9D00B288  24020001   ADDIU V0, ZERO, 1
9D00B28C  8E020010   LW V0, 16(S0)
9D00B290  24420001   ADDIU V0, V0, 1
9D00B294  0002102B   SLTU V0, ZERO, V0
35:                      {
36:                          //TODO: make error indication with LEDs (flash them all or something)
37:                          
38:                          // Unable to open the driver
39:                          // May be the driver is not initialized or the initialization
40:                          // is not complete.
41:                          return false;
42:                      }
43:                      return true;
44:                  }
9D00B298  8FBF001C   LW RA, 28(SP)
45:                  
46:                  bool InitRXUARTModule(UART_Object_t* _UART, SYS_MODULE_INDEX _uartModule)
47:                  {
00000000  00000000   NOP
48:                      //setting the ringbuffer's buffer array to an array with predetermined size
49:                      //setting the uart object to reference the buffer instance
50:                      _UART->RxBuffer = createRingBuffer(_UART->RxBuffer,UART_BUFFER_SIZE);
00000018  00000000   NOP
51:                      //storing the uart instance (0 through 6) as possible values
52:                      _UART->uartRXModule = _uartModule;
00000028  00000000   NOP
53:                      //opening the uart channel
54:                      _UART->uartRXHandle = DRV_USART_Open(_uartModule, DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE | DRV_IO_INTENT_SHARED );
0000002C  00000000   NOP
55:                   
56:                      InitRXEventHandler(_UART);
0000003C  00000000   NOP
57:                      
58:                      if (DRV_HANDLE_INVALID == _UART->uartRXHandle)
00000044  00000000   NOP
59:                      {
60:                          // Unable to open the driver
61:                          // May be the driver is not initialized or the initialization
62:                          // is not complete.
63:                          return false;
64:                      }
65:                      return true;
66:                  }
0000004C  00000000   NOP
67:                  /* Function: InitTXUARTModule:
68:                   * 
69:                   * Purpose: Sets the functions that will be called when the corresponding interrupt fires
70:                   */
71:                  bool InitTXUARTModule(UART_Object_t* _UART, SYS_MODULE_INDEX _uartModule)
72:                  {
00000000  00000000   NOP
73:                  
74:                      _UART->TxBuffer = createRingBuffer(_UART->TxBuffer,UART_BUFFER_SIZE);;
00000018  00000000   NOP
75:                      
76:                      _UART->uartTXModule = _uartModule;
00000028  00000000   NOP
77:                      _UART->uartTXHandle = DRV_USART_Open(_uartModule, DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE | DRV_IO_INTENT_SHARED );
0000002C  00000000   NOP
78:                      InitTXEventHandler(_UART);
0000003C  00000000   NOP
79:                      
80:                      if (DRV_HANDLE_INVALID == _UART->uartTXHandle)
00000044  00000000   NOP
81:                      {
82:                          // Unable to open the driver
83:                          // May be the driver is not initialized or the initialization
84:                          // is not complete.
85:                          return false;
86:                      }
87:                      return true;
88:                  }
0000004C  00000000   NOP
89:                  /* Function: InitRXEventHandler & InitTXEventHandler:
90:                   * 
91:                   * Purpose: Sets the functions that will be called when the receive interrupt fires
92:                   */
93:                  void InitRXEventHandler(UART_Object_t* _uartObj)
94:                  {
9D00C508  27BDFFE8   ADDIU SP, SP, -24
9D00C50C  AFBF0014   SW RA, 20(SP)
95:                      _RXEventHandlerUARTobjects[_uartObj->uartRXModule] = _uartObj;
9D00C510  94820018   LHU V0, 24(A0)
9D00C514  00022880   SLL A1, V0, 2
9D00C518  3C038000   LUI V1, -32768
9D00C51C  24634B38   ADDIU V1, V1, 19256
9D00C520  00A31821   ADDU V1, A1, V1
9D00C524  AC640000   SW A0, 0(V1)
96:                     
97:                      DRV_USART_ByteReceiveCallbackSet(_uartObj->uartRXModule, RXEventHandler);
9D00C528  00402021   ADDU A0, V0, ZERO
9D00C52C  3C059D01   LUI A1, -25343
9D00C530  0F40321D   JAL DRV_USART_ByteReceiveCallbackSet
9D00C534  24A5B450   ADDIU A1, A1, -19376
98:                  }
9D00C538  8FBF0014   LW RA, 20(SP)
99:                  /* Function: InitTXEventHandler:
100:                  * 
101:                  * Purpose: Sets the functions that will be called when the transmit interrupt fires
102:                  */
103:                 void InitTXEventHandler(UART_Object_t* _uartObj)
104:                 {
9D00C544  27BDFFE8   ADDIU SP, SP, -24
9D00C548  AFBF0014   SW RA, 20(SP)
105:                     _TXEventHandlerUARTobjects[_uartObj->uartTXModule] = _uartObj;
9D00C54C  9482001A   LHU V0, 26(A0)
9D00C550  00022880   SLL A1, V0, 2
9D00C554  3C038000   LUI V1, -32768
9D00C558  24635150   ADDIU V1, V1, 20816
9D00C55C  00A31821   ADDU V1, A1, V1
9D00C560  AC640000   SW A0, 0(V1)
106:                     
107:                     DRV_USART_ByteTransmitCallbackSet(_uartObj->uartTXModule, TXEventHandler);
9D00C564  00402021   ADDU A0, V0, ZERO
9D00C568  3C059D01   LUI A1, -25343
9D00C56C  0F403212   JAL DRV_USART_ByteTransmitCallbackSet
9D00C570  24A5B6E4   ADDIU A1, A1, -18716
108:                 }
9D00C574  8FBF0014   LW RA, 20(SP)
109:                 
110:                 
111:                 
112:                 /**********************************************************************************
113:                  *********************Transmit/Receive Management Functions************************
114:                  **********************************************************************************/
115:                 
116:                 //Sends the data in the uartObjects TX buffer (thus the buffer must have info to send)
117:                 void Send_put(UART_Object_t* _TXobject, unsigned char _data)
118:                 {
9D00BC6C  27BDFFE0   ADDIU SP, SP, -32
9D00BC70  AFBF001C   SW RA, 28(SP)
9D00BC74  AFB10018   SW S1, 24(SP)
9D00BC78  AFB00014   SW S0, 20(SP)
9D00BC7C  00808021   ADDU S0, A0, ZERO
119:                    
120:                     //Put the data into the RX buffer
121:                     Buffer_Put(_TXobject->TxBuffer, _data);
9D00BC80  0F402DF9   JAL Buffer_Put
9D00BC84  8C840004   LW A0, 4(A0)
122:                     //use DRV_USART_TransmitBufferIsFull(Handle);
123:                     //If the interrupt is disabled then we won't call the write function again 
124:                     if( !(DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL & DRV_USART_TransferStatus(_TXobject->uartTXHandle)) )
9D00BC88  0F402E52   JAL DRV_USART_TransferStatus
9D00BC8C  8E040014   LW A0, 20(S0)
9D00BC90  30420004   ANDI V0, V0, 4
9D00BC94  14400008   BNE V0, ZERO, 0x9D00BCB8
9D00BC98  8FBF001C   LW RA, 28(SP)
125:                     {
126:                         DRV_USART_WriteByte(_TXobject->uartTXHandle, Buffer_Get(_TXobject->TxBuffer));
9D00BC9C  8E110014   LW S1, 20(S0)
9D00BCA0  0F403133   JAL Buffer_Get
9D00BCA4  8E040004   LW A0, 4(S0)
9D00BCA8  02202021   ADDU A0, S1, ZERO
9D00BCAC  0F400064   JAL DRV_USART_WriteByte
9D00BCB0  00402821   ADDU A1, V0, ZERO
127:                     }
128:                 }
9D00BCB4  8FBF001C   LW RA, 28(SP)
129:                 
130:                 // Event Processing Technique. Event is received when
131:                 // a byte is received.
132:                 uint8_t data ;
133:                 void RXEventHandler(const SYS_MODULE_INDEX index)
134:                 {
9D00B450  27BDFFE0   ADDIU SP, SP, -32
9D00B454  AFBF001C   SW RA, 28(SP)
9D00B458  AFB10018   SW S1, 24(SP)
9D00B45C  AFB00014   SW S0, 20(SP)
135:                     if(getLoadedState())
9D00B460  0F403327   JAL getLoadedState
9D00B464  00808821   ADDU S1, A0, ZERO
9D00B468  10400015   BEQ V0, ZERO, .LVL6, .LBE2
9D00B46C  00111880   SLL V1, S1, 2
136:                     {
137:                         //Byte has been Received. Handle the event.
138:                         DRV_HANDLE  handle = _RXEventHandlerUARTobjects[index]->uartRXHandle;
9D00B470  3C028000   LUI V0, -32768
9D00B474  24424B38   ADDIU V0, V0, 19256
9D00B478  7C43100A   LWX V0, V1(V0)
9D00B47C  8C500010   LW S0, 16(V0)
139:                         while((DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT & DRV_USART_TransferStatus(handle)))
9D00B488  0B402D2B   J .LVL4
9D00B48C  00628821   ADDU S1, V1, V0
9D00B4AC  0F402E52   JAL DRV_USART_TransferStatus
9D00B4B0  02002021   ADDU A0, S0, ZERO
9D00B4B4  30420001   ANDI V0, V0, 1
9D00B4B8  1440FFF5   BNE V0, ZERO, 0x9D00B490
9D00B4BC  00000000   NOP
140:                         {
141:                             data = DRV_USART_ReadByte(handle);
9D00B490  0F40300A   JAL DRV_USART_ReadByte
9D00B494  02002021   ADDU A0, S0, ZERO
9D00B498  A382811E   SB V0, -32482(GP)
142:                             Buffer_Put(_RXEventHandlerUARTobjects[index]->RxBuffer ,data);
9D00B480  3C028000   LUI V0, -32768
9D00B484  24424B38   ADDIU V0, V0, 19256
9D00B49C  8E230000   LW V1, 0(S1)
9D00B4A0  8C640000   LW A0, 0(V1)
9D00B4A4  0F402DF9   JAL Buffer_Put
9D00B4A8  00402821   ADDU A1, V0, ZERO
143:                         } 
144:                     }
145:                 }
9D00B4C0  8FBF001C   LW RA, 28(SP)
146:                 
147:                 void TXEventHandler(const SYS_MODULE_INDEX index)
148:                 {
9D00B6E4  27BDFFE0   ADDIU SP, SP, -32
9D00B6E8  AFBF001C   SW RA, 28(SP)
9D00B6EC  AFB10018   SW S1, 24(SP)
9D00B6F0  AFB00014   SW S0, 20(SP)
9D00B6F4  00808021   ADDU S0, A0, ZERO
149:                     //Byte has finished transmitting
150:                     if(Buffer_Size(_TXEventHandlerUARTobjects[index]->TxBuffer) > 0)
9D00B6F8  00041880   SLL V1, A0, 2
9D00B6FC  3C028000   LUI V0, -32768
9D00B700  24425150   ADDIU V0, V0, 20816
9D00B704  7C43100A   LWX V0, V1(V0)
9D00B708  0F403323   JAL Buffer_Size
9D00B70C  8C440004   LW A0, 4(V0)
9D00B710  1840000D   BLEZ V0, 0x9D00B748
9D00B714  27828118   ADDIU V0, GP, -32488
151:                     {
152:                         //Transmit the next byte
153:                         DRV_USART_WriteByte(
9D00B728  8E110014   LW S1, 20(S0)
9D00B72C  0F403133   JAL Buffer_Get
9D00B730  8E040004   LW A0, 4(S0)
9D00B734  02202021   ADDU A0, S1, ZERO
9D00B738  0F400064   JAL DRV_USART_WriteByte
9D00B73C  00402821   ADDU A1, V0, ZERO
9D00B740  0B402DD5   J 0x9D00B754
9D00B744  8FBF001C   LW RA, 28(SP)
154:                                 _TXEventHandlerUARTobjects[index]->uartTXHandle,
9D00B718  00108080   SLL S0, S0, 2
9D00B71C  3C028000   LUI V0, -32768
9D00B720  24425150   ADDIU V0, V0, 20816
9D00B724  7C50800A   LWX S0, S0(V0)
155:                                 Buffer_Get(_TXEventHandlerUARTobjects[index]->TxBuffer));
156:                     }
157:                     else
158:                     {
159:                         Transmit_stall[index] = false;
9D00B748  00508021   ADDU S0, V0, S0
9D00B74C  A2000000   SB ZERO, 0(S0)
160:                         //May need to disable the interrupt here!
161:                     }
162:                 }
9D00B750  8FBF001C   LW RA, 28(SP)
163:                 
164:                 
165:                 int Receive_available(UART_Object_t* _this)
166:                 {
00000000  00000000   NOP
167:                     return Buffer_Size(_this->RxBuffer);
00000008  00000000   NOP
168:                 }
00000010  00000000   NOP
169:                 ////this is need to use the prinf function
170:                 void _mon_putc(char c){
171:                     while(U4STAbits.UTXBF == 1){
9D00CAA4  3C03BF82   LUI V1, -16510
9D00CAA8  8C622610   LW V0, 9744(V1)
9D00CAAC  30420200   ANDI V0, V0, 512
9D00CAB0  1440FFFD   BNE V0, ZERO, 0x9D00CAA8
9D00CAB4  3C02BF82   LUI V0, -16510
172:                         
173:                     }
174:                     U4TXREG = c;
9D00CAB8  AC442620   SW A0, 9760(V0)
175:                     
176:                 }
177:                 //
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/timers.c  ---------
1:                   //*****************************************
2:                   //********TIMER.C file code****************
3:                   //*****************************************
4:                   #include "Timers.h"
5:                   #include <stdlib.h>
6:                   unsigned long globalTime;
7:                   
8:                   unsigned long millis(void)
9:                   {
10:                      return globalTime;
9D00C660  8F858114   LW A1, -32492(GP)
11:                  }
00000000  00000000   NOP
12:                  
13:                  bool timerDone(timers_t * t)
14:                  {
15:                  
16:                      if(abs(millis()-t->lastMillis)> t->timerInterval)
9D00C664  8C830004   LW V1, 4(A0)
9D00C668  00A31823   SUBU V1, A1, V1
9D00C66C  000317C3   SRA V0, V1, 31
9D00C670  00431826   XOR V1, V0, V1
9D00C674  00621823   SUBU V1, V1, V0
9D00C678  8C860000   LW A2, 0(A0)
9D00C67C  00C3182B   SLTU V1, A2, V1
9D00C680  10600003   BEQ V1, ZERO, 0x9D00C690
9D00C684  00001021   ADDU V0, ZERO, ZERO
17:                      {
18:                          t->lastMillis=millis();
9D00C688  AC850004   SW A1, 4(A0)
19:                          return true;
9D00C68C  24020001   ADDIU V0, ZERO, 1
20:                      }
21:                      else
22:                      {
23:                          return false;
24:                      }
25:                  }
9D00C690  03E00008   JR RA
26:                  
27:                  void setTimerInterval(timers_t * t, unsigned long interval)
28:                  {
29:                      if(t->timerInterval != interval)
9D00CC18  8C820000   LW V0, 0(A0)
30:                          t->timerInterval = interval;
31:                  }
32:                  
33:                  void resetTimer(timers_t * t)
34:                  {
35:                      t->lastMillis=millis();
00000000  00000000   NOP
36:                  }
37:                  //Call this function in your timer interrupt that fires at 1ms
38:                  void globalTimerTracker( )
39:                  {
40:                      globalTime++;
9D00CC50  8F828114   LW V0, -32492(GP)
41:                  }
42:                  timers_t time;
43:                  void delay(int interval)
44:                  {
9D00C81C  27BDFFE8   ADDIU SP, SP, -24
9D00C820  AFBF0014   SW RA, 20(SP)
45:                      time.timerInterval= interval;
9D00C824  AF84810C   SW A0, -32500(GP)
46:                      time.lastMillis=millis();
9D00C828  8F828114   LW V0, -32492(GP)
9D00C82C  AF828110   SW V0, -32496(GP)
47:                      while(!timerDone(&time));
9D00C830  0F403198   JAL timerDone
9D00C834  2784810C   ADDIU A0, GP, -32500
9D00C838  1040FFFD   BEQ V0, ZERO, .LVL4
9D00C83C  8FBF0014   LW RA, 20(SP)
48:                  }
9D00C840  03E00008   JR RA
49:                  
50:                  //*****************************************
51:                  //**********    END OF C file  ************
52:                  //*****************************************
53:                  
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/telemetry.c  ------
1:                   #include "Telemetry.h"
2:                   #include "Definitions.h"
3:                   #include "Pozyx.h"
4:                   #include "FastTransfer.h"
5:                   #include <math.h>
6:                   #include "Timers.h"
7:                   
8:                   #define InicialHeading  0
9:                   int HeadingVal = InicialHeading;
10:                  point_t HeadingStartWayPoint;
11:                  
12:                  double thisheading;
13:                  
14:                  double CalculateHeading(point_t startPoint, point_t endPoint) {
00000000  00000000   NOP
15:                      thisheading = atan2((double) ((double) endPoint.y - (double) startPoint.y), (double) ((double) endPoint.x - (double) startPoint.x)) * RAD_TO_DEGREE;
00000018  00000000   NOP
00000050  00000000   NOP
16:                  //    if ((endPoint.y - startPoint.y) < 0 && (endPoint.x - startPoint.x) < 0) //Quad 3
17:                  //        thisheading = -thisheading;
18:                  //    else if ((endPoint.y - startPoint.y) < 0 && (endPoint.x - startPoint.x) > 0) //quad 4
19:                  //        thisheading = -180 + thisheading;
20:                  //    else if ((endPoint.y - startPoint.y) > 0 && (endPoint.x - startPoint.x) > 0) //quad 1
21:                  //        thisheading = thisheading;
22:                  //    else if ((endPoint.y - startPoint.y) > 0 && (endPoint.x - startPoint.x) < 0) //quad 2
23:                  //        thisheading = 180 - thisheading;
24:                      return thisheading;
25:                  
26:                  }
00000060  00000000   NOP
27:                  
28:                  double pointDistance(point_t pointA, point_t pointB) {
00000000  00000000   NOP
29:                      return sqrt((pointB.y - pointA.y)*(pointB.y - pointA.y) + (pointB.x - pointA.x)*(pointB.x - pointA.x));
00000018  00000000   NOP
30:                  }
0000003C  00000000   NOP
31:                  
32:                  void updateHeading(int _heading) {
33:                      HeadingVal += _heading;
34:                  }
35:                  
36:                  int getHeading() {
37:                      return HeadingVal;
38:                  }
39:                  
40:                  int getInicialHeading() {
41:                      return InicialHeading;
42:                  }
43:                  
44:                  void CalcInicialHeading() {
00000000  00000000   NOP
45:                      int16_t pozyxHeading = 0;
46:                      receiveData(&PozyxFT);
00000008  00000000   NOP
47:                      pozyxHeading = (int16_t)getPozyxHeading();
00000014  00000000   NOP
48:                  
49:                      if (pozyxHeading < 45 && pozyxHeading > -45)
00000028  00000000   NOP
50:                          HeadingVal = 0;
51:                      else if (pozyxHeading >= 45 && pozyxHeading < 135)
00000048  00000000   NOP
52:                          HeadingVal = 90;
00000058  00000000   NOP
53:                      else if (abs(pozyxHeading) >= 135)
00000064  00000000   NOP
54:                          HeadingVal = 180;
00000078  00000000   NOP
55:                      else if (pozyxHeading <= -45 && pozyxHeading > -135)
00000084  00000000   NOP
56:                          HeadingVal = -90;
00000094  00000000   NOP
57:                  }
00000098  00000000   NOP
58:                  
59:                  void setInicialHeading(int _heading) {
60:                      HeadingVal = _heading;
61:                  }
62:                  
63:                  void captureHeadingWaypoint(point_t _Waypoint) {
00000000  00000000   NOP
64:                      HeadingStartWayPoint = _Waypoint;
00000008  00000000   NOP
65:                  }
66:                  
67:                  double calcHeadingFromWaypoint(point_t secondWaypoint) {
00000000  00000000   NOP
68:                      return CalculateHeading(HeadingStartWayPoint, secondWaypoint);
00000018  00000000   NOP
69:                  
70:                  }
00000024  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D00CB38  27BDFFE8   ADDIU SP, SP, -24
9D00CB3C  AFBF0014   SW RA, 20(SP)
74:                      /* Maintain system services */
75:                  
76:                      /* Maintain Device Drivers */
77:                  
78:                      /* Maintain Middleware & Other Libraries */
79:                  
80:                      /* Maintain the application's state machine. */
81:                      APP_Tasks();
9D00CB40  0F40281B   JAL APP_Tasks
9D00CB44  00000000   NOP
82:                  }
9D00CB48  8FBF0014   LW RA, 20(SP)
83:                  
84:                  
85:                  /*******************************************************************************
86:                   End of File
87:                   */
88:                  
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include "system/common/sys_common.h"
63:                  #include "app.h"
64:                  #include "system_definitions.h"
65:                  #include "changeNotification.h"
66:                  #include "Timers.h"
67:                  #include "../../CAN_Handler/CAN.h"
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: System Interrupt Vector Functions
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                   
74:                  void __ISR(_UART2_TX_VECTOR, ipl5AUTO) _IntHandlerDrvUsartTransmitInstance0(void)
75:                  {
9D006B98  415DE800   RDPGPR SP, SP
9D006B9C  401B7000   MFC0 K1, EPC
9D006BA0  401A6002   MFC0 K0, SRSCtl
9D006BA4  27BDFED0   ADDIU SP, SP, -304
9D006BA8  AFBB012C   SW K1, 300(SP)
9D006BAC  401B6000   MFC0 K1, Status
9D006BB0  AFBA0124   SW K0, 292(SP)
9D006BB4  AFBB0128   SW K1, 296(SP)
9D006BB8  7C1B7844   INS K1, ZERO, 1, 15
9D006BBC  377B1400   ORI K1, K1, 5120
9D006BC0  409B6000   MTC0 K1, Status
9D006BC4  AFA30018   SW V1, 24(SP)
9D006BC8  AFA20014   SW V0, 20(SP)
9D006BCC  8FA30124   LW V1, 292(SP)
9D006BD0  3063000F   ANDI V1, V1, 15
9D006BD4  14600011   BNE V1, ZERO, 0x9D006C1C
9D006BD8  00000000   NOP
9D006BDC  AFBF0054   SW RA, 84(SP)
9D006BE0  AFB90050   SW T9, 80(SP)
9D006BE4  AFB8004C   SW T8, 76(SP)
9D006BE8  AFAF0048   SW T7, 72(SP)
9D006BEC  AFAE0044   SW T6, 68(SP)
9D006BF0  AFAD0040   SW T5, 64(SP)
9D006BF4  AFAC003C   SW T4, 60(SP)
9D006BF8  AFAB0038   SW T3, 56(SP)
9D006BFC  AFAA0034   SW T2, 52(SP)
9D006C00  AFA90030   SW T1, 48(SP)
9D006C04  AFA8002C   SW T0, 44(SP)
9D006C08  AFA70028   SW A3, 40(SP)
9D006C0C  AFA60024   SW A2, 36(SP)
9D006C10  AFA50020   SW A1, 32(SP)
9D006C14  AFA4001C   SW A0, 28(SP)
9D006C18  AFA10010   SW AT, 16(SP)
9D006C1C  F7B300F0   SDC1 F19, 240(SP)
9D006C20  F7B200E8   SDC1 F18, 232(SP)
9D006C24  F7B100E0   SDC1 F17, 224(SP)
9D006C28  F7B000D8   SDC1 F16, 216(SP)
9D006C2C  F7AF00D0   SDC1 F15, 208(SP)
9D006C30  F7AE00C8   SDC1 F14, 200(SP)
9D006C34  F7AD00C0   SDC1 F13, 192(SP)
9D006C38  F7AC00B8   SDC1 F12, 184(SP)
9D006C3C  F7AB00B0   SDC1 F11, 176(SP)
9D006C40  F7AA00A8   SDC1 F10, 168(SP)
9D006C44  F7A900A0   SDC1 F9, 160(SP)
9D006C48  F7A80098   SDC1 F8, 152(SP)
9D006C4C  F7A70090   SDC1 F7, 144(SP)
9D006C50  F7A60088   SDC1 F6, 136(SP)
9D006C54  F7A50080   SDC1 F5, 128(SP)
9D006C58  F7A40078   SDC1 F4, 120(SP)
9D006C5C  F7A30070   SDC1 F3, 112(SP)
9D006C60  F7A20068   SDC1 F2, 104(SP)
9D006C64  F7A10060   SDC1 F1, 96(SP)
9D006C68  F7A00058   SDC1 F0, 88(SP)
9D006C6C  00001012   MFLO V0
9D006C70  AFA2011C   SW V0, 284(SP)
9D006C74  00001810   MFHI V1
9D006C78  AFA30118   SW V1, 280(SP)
9D006C7C  00201012   MFLO V0
9D006C80  AFA20114   SW V0, 276(SP)
9D006C84  00201810   MFHI V1
9D006C88  AFA30110   SW V1, 272(SP)
9D006C8C  00401012   MFLO V0
9D006C90  AFA2010C   SW V0, 268(SP)
9D006C94  00401810   MFHI V1
9D006C98  AFA30108   SW V1, 264(SP)
9D006C9C  00601012   MFLO V0
9D006CA0  AFA20104   SW V0, 260(SP)
9D006CA4  00601810   MFHI V1
9D006CA8  AFA30100   SW V1, 256(SP)
9D006CAC  7C3F1CB8   RDDSP V1, 0x3F
9D006CB0  AFA3000C   SW V1, 12(SP)
9D006CB4  4442F800   CFC1 V0, F31
9D006CB8  AFA200FC   SW V0, 252(SP)
76:                      DRV_USART_TasksTransmit(sysObj.drvUsart0);
9D006CBC  3C028000   LUI V0, -32768
9D006CC0  0F402AFF   JAL DRV_USART_TasksTransmit
9D006CC4  8C444B2C   LW A0, 19244(V0)
77:                  }
9D006CC8  8FA200FC   LW V0, 252(SP)
78:                  void __ISR(_UART2_RX_VECTOR, ipl1AUTO) _IntHandlerDrvUsartReceiveInstance0(void)
79:                  {
9D006DEC  415DE800   RDPGPR SP, SP
9D006DF0  401B7000   MFC0 K1, EPC
9D006DF4  401A6002   MFC0 K0, SRSCtl
9D006DF8  27BDFED0   ADDIU SP, SP, -304
9D006DFC  AFBB012C   SW K1, 300(SP)
9D006E00  401B6000   MFC0 K1, Status
9D006E04  AFBA0124   SW K0, 292(SP)
9D006E08  AFBB0128   SW K1, 296(SP)
9D006E0C  7C1B7844   INS K1, ZERO, 1, 15
9D006E10  377B0400   ORI K1, K1, 1024
9D006E14  409B6000   MTC0 K1, Status
9D006E18  AFA30018   SW V1, 24(SP)
9D006E1C  AFA20014   SW V0, 20(SP)
9D006E20  8FA30124   LW V1, 292(SP)
9D006E24  3063000F   ANDI V1, V1, 15
9D006E28  14600011   BNE V1, ZERO, 0x9D006E70
9D006E2C  00000000   NOP
9D006E30  AFBF0054   SW RA, 84(SP)
9D006E34  AFB90050   SW T9, 80(SP)
9D006E38  AFB8004C   SW T8, 76(SP)
9D006E3C  AFAF0048   SW T7, 72(SP)
9D006E40  AFAE0044   SW T6, 68(SP)
9D006E44  AFAD0040   SW T5, 64(SP)
9D006E48  AFAC003C   SW T4, 60(SP)
9D006E4C  AFAB0038   SW T3, 56(SP)
9D006E50  AFAA0034   SW T2, 52(SP)
9D006E54  AFA90030   SW T1, 48(SP)
9D006E58  AFA8002C   SW T0, 44(SP)
9D006E5C  AFA70028   SW A3, 40(SP)
9D006E60  AFA60024   SW A2, 36(SP)
9D006E64  AFA50020   SW A1, 32(SP)
9D006E68  AFA4001C   SW A0, 28(SP)
9D006E6C  AFA10010   SW AT, 16(SP)
9D006E70  F7B300F0   SDC1 F19, 240(SP)
9D006E74  F7B200E8   SDC1 F18, 232(SP)
9D006E78  F7B100E0   SDC1 F17, 224(SP)
9D006E7C  F7B000D8   SDC1 F16, 216(SP)
9D006E80  F7AF00D0   SDC1 F15, 208(SP)
9D006E84  F7AE00C8   SDC1 F14, 200(SP)
9D006E88  F7AD00C0   SDC1 F13, 192(SP)
9D006E8C  F7AC00B8   SDC1 F12, 184(SP)
9D006E90  F7AB00B0   SDC1 F11, 176(SP)
9D006E94  F7AA00A8   SDC1 F10, 168(SP)
9D006E98  F7A900A0   SDC1 F9, 160(SP)
9D006E9C  F7A80098   SDC1 F8, 152(SP)
9D006EA0  F7A70090   SDC1 F7, 144(SP)
9D006EA4  F7A60088   SDC1 F6, 136(SP)
9D006EA8  F7A50080   SDC1 F5, 128(SP)
9D006EAC  F7A40078   SDC1 F4, 120(SP)
9D006EB0  F7A30070   SDC1 F3, 112(SP)
9D006EB4  F7A20068   SDC1 F2, 104(SP)
9D006EB8  F7A10060   SDC1 F1, 96(SP)
9D006EBC  F7A00058   SDC1 F0, 88(SP)
9D006EC0  00001012   MFLO V0
9D006EC4  AFA2011C   SW V0, 284(SP)
9D006EC8  00001810   MFHI V1
9D006ECC  AFA30118   SW V1, 280(SP)
9D006ED0  00201012   MFLO V0
9D006ED4  AFA20114   SW V0, 276(SP)
9D006ED8  00201810   MFHI V1
9D006EDC  AFA30110   SW V1, 272(SP)
9D006EE0  00401012   MFLO V0
9D006EE4  AFA2010C   SW V0, 268(SP)
9D006EE8  00401810   MFHI V1
9D006EEC  AFA30108   SW V1, 264(SP)
9D006EF0  00601012   MFLO V0
9D006EF4  AFA20104   SW V0, 260(SP)
9D006EF8  00601810   MFHI V1
9D006EFC  AFA30100   SW V1, 256(SP)
9D006F00  7C3F1CB8   RDDSP V1, 0x3F
9D006F04  AFA3000C   SW V1, 12(SP)
9D006F08  4442F800   CFC1 V0, F31
9D006F0C  AFA200FC   SW V0, 252(SP)
80:                      DRV_USART_TasksReceive(sysObj.drvUsart0);
9D006F10  3C028000   LUI V0, -32768
9D006F14  0F402B27   JAL DRV_USART_TasksReceive
9D006F18  8C444B2C   LW A0, 19244(V0)
81:                  }
9D006F1C  8FA200FC   LW V0, 252(SP)
82:                  void __ISR(_UART2_FAULT_VECTOR, ipl1AUTO) _IntHandlerDrvUsartErrorInstance0(void)
83:                  {
9D007040  415DE800   RDPGPR SP, SP
9D007044  401B7000   MFC0 K1, EPC
9D007048  401A6002   MFC0 K0, SRSCtl
9D00704C  27BDFED0   ADDIU SP, SP, -304
9D007050  AFBB012C   SW K1, 300(SP)
9D007054  401B6000   MFC0 K1, Status
9D007058  AFBA0124   SW K0, 292(SP)
9D00705C  AFBB0128   SW K1, 296(SP)
9D007060  7C1B7844   INS K1, ZERO, 1, 15
9D007064  377B0400   ORI K1, K1, 1024
9D007068  409B6000   MTC0 K1, Status
9D00706C  AFA30018   SW V1, 24(SP)
9D007070  AFA20014   SW V0, 20(SP)
9D007074  8FA30124   LW V1, 292(SP)
9D007078  3063000F   ANDI V1, V1, 15
9D00707C  14600011   BNE V1, ZERO, 0x9D0070C4
9D007080  00000000   NOP
9D007084  AFBF0054   SW RA, 84(SP)
9D007088  AFB90050   SW T9, 80(SP)
9D00708C  AFB8004C   SW T8, 76(SP)
9D007090  AFAF0048   SW T7, 72(SP)
9D007094  AFAE0044   SW T6, 68(SP)
9D007098  AFAD0040   SW T5, 64(SP)
9D00709C  AFAC003C   SW T4, 60(SP)
9D0070A0  AFAB0038   SW T3, 56(SP)
9D0070A4  AFAA0034   SW T2, 52(SP)
9D0070A8  AFA90030   SW T1, 48(SP)
9D0070AC  AFA8002C   SW T0, 44(SP)
9D0070B0  AFA70028   SW A3, 40(SP)
9D0070B4  AFA60024   SW A2, 36(SP)
9D0070B8  AFA50020   SW A1, 32(SP)
9D0070BC  AFA4001C   SW A0, 28(SP)
9D0070C0  AFA10010   SW AT, 16(SP)
9D0070C4  F7B300F0   SDC1 F19, 240(SP)
9D0070C8  F7B200E8   SDC1 F18, 232(SP)
9D0070CC  F7B100E0   SDC1 F17, 224(SP)
9D0070D0  F7B000D8   SDC1 F16, 216(SP)
9D0070D4  F7AF00D0   SDC1 F15, 208(SP)
9D0070D8  F7AE00C8   SDC1 F14, 200(SP)
9D0070DC  F7AD00C0   SDC1 F13, 192(SP)
9D0070E0  F7AC00B8   SDC1 F12, 184(SP)
9D0070E4  F7AB00B0   SDC1 F11, 176(SP)
9D0070E8  F7AA00A8   SDC1 F10, 168(SP)
9D0070EC  F7A900A0   SDC1 F9, 160(SP)
9D0070F0  F7A80098   SDC1 F8, 152(SP)
9D0070F4  F7A70090   SDC1 F7, 144(SP)
9D0070F8  F7A60088   SDC1 F6, 136(SP)
9D0070FC  F7A50080   SDC1 F5, 128(SP)
9D007100  F7A40078   SDC1 F4, 120(SP)
9D007104  F7A30070   SDC1 F3, 112(SP)
9D007108  F7A20068   SDC1 F2, 104(SP)
9D00710C  F7A10060   SDC1 F1, 96(SP)
9D007110  F7A00058   SDC1 F0, 88(SP)
9D007114  00001012   MFLO V0
9D007118  AFA2011C   SW V0, 284(SP)
9D00711C  00001810   MFHI V1
9D007120  AFA30118   SW V1, 280(SP)
9D007124  00201012   MFLO V0
9D007128  AFA20114   SW V0, 276(SP)
9D00712C  00201810   MFHI V1
9D007130  AFA30110   SW V1, 272(SP)
9D007134  00401012   MFLO V0
9D007138  AFA2010C   SW V0, 268(SP)
9D00713C  00401810   MFHI V1
9D007140  AFA30108   SW V1, 264(SP)
9D007144  00601012   MFLO V0
9D007148  AFA20104   SW V0, 260(SP)
9D00714C  00601810   MFHI V1
9D007150  AFA30100   SW V1, 256(SP)
9D007154  7C3F1CB8   RDDSP V1, 0x3F
9D007158  AFA3000C   SW V1, 12(SP)
9D00715C  4442F800   CFC1 V0, F31
9D007160  AFA200FC   SW V0, 252(SP)
84:                      DRV_USART_TasksError(sysObj.drvUsart0);
9D007164  3C028000   LUI V0, -32768
9D007168  0F402B4F   JAL DRV_USART_TasksError
9D00716C  8C444B2C   LW A0, 19244(V0)
85:                  }
9D007170  8FA200FC   LW V0, 252(SP)
86:                   
87:                   
88:                  
89:                   
90:                  void __ISR(_UART4_TX_VECTOR, ipl5AUTO) _IntHandlerDrvUsartTransmitInstance1(void)
91:                  {
9D007294  415DE800   RDPGPR SP, SP
9D007298  401B7000   MFC0 K1, EPC
9D00729C  401A6002   MFC0 K0, SRSCtl
9D0072A0  27BDFED0   ADDIU SP, SP, -304
9D0072A4  AFBB012C   SW K1, 300(SP)
9D0072A8  401B6000   MFC0 K1, Status
9D0072AC  AFBA0124   SW K0, 292(SP)
9D0072B0  AFBB0128   SW K1, 296(SP)
9D0072B4  7C1B7844   INS K1, ZERO, 1, 15
9D0072B8  377B1400   ORI K1, K1, 5120
9D0072BC  409B6000   MTC0 K1, Status
9D0072C0  AFA30018   SW V1, 24(SP)
9D0072C4  AFA20014   SW V0, 20(SP)
9D0072C8  8FA30124   LW V1, 292(SP)
9D0072CC  3063000F   ANDI V1, V1, 15
9D0072D0  14600011   BNE V1, ZERO, 0x9D007318
9D0072D4  00000000   NOP
9D0072D8  AFBF0054   SW RA, 84(SP)
9D0072DC  AFB90050   SW T9, 80(SP)
9D0072E0  AFB8004C   SW T8, 76(SP)
9D0072E4  AFAF0048   SW T7, 72(SP)
9D0072E8  AFAE0044   SW T6, 68(SP)
9D0072EC  AFAD0040   SW T5, 64(SP)
9D0072F0  AFAC003C   SW T4, 60(SP)
9D0072F4  AFAB0038   SW T3, 56(SP)
9D0072F8  AFAA0034   SW T2, 52(SP)
9D0072FC  AFA90030   SW T1, 48(SP)
9D007300  AFA8002C   SW T0, 44(SP)
9D007304  AFA70028   SW A3, 40(SP)
9D007308  AFA60024   SW A2, 36(SP)
9D00730C  AFA50020   SW A1, 32(SP)
9D007310  AFA4001C   SW A0, 28(SP)
9D007314  AFA10010   SW AT, 16(SP)
9D007318  F7B300F0   SDC1 F19, 240(SP)
9D00731C  F7B200E8   SDC1 F18, 232(SP)
9D007320  F7B100E0   SDC1 F17, 224(SP)
9D007324  F7B000D8   SDC1 F16, 216(SP)
9D007328  F7AF00D0   SDC1 F15, 208(SP)
9D00732C  F7AE00C8   SDC1 F14, 200(SP)
9D007330  F7AD00C0   SDC1 F13, 192(SP)
9D007334  F7AC00B8   SDC1 F12, 184(SP)
9D007338  F7AB00B0   SDC1 F11, 176(SP)
9D00733C  F7AA00A8   SDC1 F10, 168(SP)
9D007340  F7A900A0   SDC1 F9, 160(SP)
9D007344  F7A80098   SDC1 F8, 152(SP)
9D007348  F7A70090   SDC1 F7, 144(SP)
9D00734C  F7A60088   SDC1 F6, 136(SP)
9D007350  F7A50080   SDC1 F5, 128(SP)
9D007354  F7A40078   SDC1 F4, 120(SP)
9D007358  F7A30070   SDC1 F3, 112(SP)
9D00735C  F7A20068   SDC1 F2, 104(SP)
9D007360  F7A10060   SDC1 F1, 96(SP)
9D007364  F7A00058   SDC1 F0, 88(SP)
9D007368  00001012   MFLO V0
9D00736C  AFA2011C   SW V0, 284(SP)
9D007370  00001810   MFHI V1
9D007374  AFA30118   SW V1, 280(SP)
9D007378  00201012   MFLO V0
9D00737C  AFA20114   SW V0, 276(SP)
9D007380  00201810   MFHI V1
9D007384  AFA30110   SW V1, 272(SP)
9D007388  00401012   MFLO V0
9D00738C  AFA2010C   SW V0, 268(SP)
9D007390  00401810   MFHI V1
9D007394  AFA30108   SW V1, 264(SP)
9D007398  00601012   MFLO V0
9D00739C  AFA20104   SW V0, 260(SP)
9D0073A0  00601810   MFHI V1
9D0073A4  AFA30100   SW V1, 256(SP)
9D0073A8  7C3F1CB8   RDDSP V1, 0x3F
9D0073AC  AFA3000C   SW V1, 12(SP)
9D0073B0  4442F800   CFC1 V0, F31
9D0073B4  AFA200FC   SW V0, 252(SP)
92:                      DRV_USART_TasksTransmit(sysObj.drvUsart1);
9D0073B8  3C028000   LUI V0, -32768
9D0073BC  0F402AFF   JAL DRV_USART_TasksTransmit
9D0073C0  8C444B30   LW A0, 19248(V0)
93:                  }
9D0073C4  8FA200FC   LW V0, 252(SP)
94:                  void __ISR(_UART4_RX_VECTOR, ipl5AUTO) _IntHandlerDrvUsartReceiveInstance1(void)
95:                  {
9D0074E8  415DE800   RDPGPR SP, SP
9D0074EC  401B7000   MFC0 K1, EPC
9D0074F0  401A6002   MFC0 K0, SRSCtl
9D0074F4  27BDFED0   ADDIU SP, SP, -304
9D0074F8  AFBB012C   SW K1, 300(SP)
9D0074FC  401B6000   MFC0 K1, Status
9D007500  AFBA0124   SW K0, 292(SP)
9D007504  AFBB0128   SW K1, 296(SP)
9D007508  7C1B7844   INS K1, ZERO, 1, 15
9D00750C  377B1400   ORI K1, K1, 5120
9D007510  409B6000   MTC0 K1, Status
9D007514  AFA30018   SW V1, 24(SP)
9D007518  AFA20014   SW V0, 20(SP)
9D00751C  8FA30124   LW V1, 292(SP)
9D007520  3063000F   ANDI V1, V1, 15
9D007524  14600011   BNE V1, ZERO, 0x9D00756C
9D007528  00000000   NOP
9D00752C  AFBF0054   SW RA, 84(SP)
9D007530  AFB90050   SW T9, 80(SP)
9D007534  AFB8004C   SW T8, 76(SP)
9D007538  AFAF0048   SW T7, 72(SP)
9D00753C  AFAE0044   SW T6, 68(SP)
9D007540  AFAD0040   SW T5, 64(SP)
9D007544  AFAC003C   SW T4, 60(SP)
9D007548  AFAB0038   SW T3, 56(SP)
9D00754C  AFAA0034   SW T2, 52(SP)
9D007550  AFA90030   SW T1, 48(SP)
9D007554  AFA8002C   SW T0, 44(SP)
9D007558  AFA70028   SW A3, 40(SP)
9D00755C  AFA60024   SW A2, 36(SP)
9D007560  AFA50020   SW A1, 32(SP)
9D007564  AFA4001C   SW A0, 28(SP)
9D007568  AFA10010   SW AT, 16(SP)
9D00756C  F7B300F0   SDC1 F19, 240(SP)
9D007570  F7B200E8   SDC1 F18, 232(SP)
9D007574  F7B100E0   SDC1 F17, 224(SP)
9D007578  F7B000D8   SDC1 F16, 216(SP)
9D00757C  F7AF00D0   SDC1 F15, 208(SP)
9D007580  F7AE00C8   SDC1 F14, 200(SP)
9D007584  F7AD00C0   SDC1 F13, 192(SP)
9D007588  F7AC00B8   SDC1 F12, 184(SP)
9D00758C  F7AB00B0   SDC1 F11, 176(SP)
9D007590  F7AA00A8   SDC1 F10, 168(SP)
9D007594  F7A900A0   SDC1 F9, 160(SP)
9D007598  F7A80098   SDC1 F8, 152(SP)
9D00759C  F7A70090   SDC1 F7, 144(SP)
9D0075A0  F7A60088   SDC1 F6, 136(SP)
9D0075A4  F7A50080   SDC1 F5, 128(SP)
9D0075A8  F7A40078   SDC1 F4, 120(SP)
9D0075AC  F7A30070   SDC1 F3, 112(SP)
9D0075B0  F7A20068   SDC1 F2, 104(SP)
9D0075B4  F7A10060   SDC1 F1, 96(SP)
9D0075B8  F7A00058   SDC1 F0, 88(SP)
9D0075BC  00001012   MFLO V0
9D0075C0  AFA2011C   SW V0, 284(SP)
9D0075C4  00001810   MFHI V1
9D0075C8  AFA30118   SW V1, 280(SP)
9D0075CC  00201012   MFLO V0
9D0075D0  AFA20114   SW V0, 276(SP)
9D0075D4  00201810   MFHI V1
9D0075D8  AFA30110   SW V1, 272(SP)
9D0075DC  00401012   MFLO V0
9D0075E0  AFA2010C   SW V0, 268(SP)
9D0075E4  00401810   MFHI V1
9D0075E8  AFA30108   SW V1, 264(SP)
9D0075EC  00601012   MFLO V0
9D0075F0  AFA20104   SW V0, 260(SP)
9D0075F4  00601810   MFHI V1
9D0075F8  AFA30100   SW V1, 256(SP)
9D0075FC  7C3F1CB8   RDDSP V1, 0x3F
9D007600  AFA3000C   SW V1, 12(SP)
9D007604  4442F800   CFC1 V0, F31
9D007608  AFA200FC   SW V0, 252(SP)
96:                      DRV_USART_TasksReceive(sysObj.drvUsart1);
9D00760C  3C028000   LUI V0, -32768
9D007610  0F402B27   JAL DRV_USART_TasksReceive
9D007614  8C444B30   LW A0, 19248(V0)
97:                  }
9D007618  8FA200FC   LW V0, 252(SP)
98:                  void __ISR(_UART4_FAULT_VECTOR, ipl5AUTO) _IntHandlerDrvUsartErrorInstance1(void)
99:                  {
9D00773C  415DE800   RDPGPR SP, SP
9D007740  401B7000   MFC0 K1, EPC
9D007744  401A6002   MFC0 K0, SRSCtl
9D007748  27BDFED0   ADDIU SP, SP, -304
9D00774C  AFBB012C   SW K1, 300(SP)
9D007750  401B6000   MFC0 K1, Status
9D007754  AFBA0124   SW K0, 292(SP)
9D007758  AFBB0128   SW K1, 296(SP)
9D00775C  7C1B7844   INS K1, ZERO, 1, 15
9D007760  377B1400   ORI K1, K1, 5120
9D007764  409B6000   MTC0 K1, Status
9D007768  AFA30018   SW V1, 24(SP)
9D00776C  AFA20014   SW V0, 20(SP)
9D007770  8FA30124   LW V1, 292(SP)
9D007774  3063000F   ANDI V1, V1, 15
9D007778  14600011   BNE V1, ZERO, 0x9D0077C0
9D00777C  00000000   NOP
9D007780  AFBF0054   SW RA, 84(SP)
9D007784  AFB90050   SW T9, 80(SP)
9D007788  AFB8004C   SW T8, 76(SP)
9D00778C  AFAF0048   SW T7, 72(SP)
9D007790  AFAE0044   SW T6, 68(SP)
9D007794  AFAD0040   SW T5, 64(SP)
9D007798  AFAC003C   SW T4, 60(SP)
9D00779C  AFAB0038   SW T3, 56(SP)
9D0077A0  AFAA0034   SW T2, 52(SP)
9D0077A4  AFA90030   SW T1, 48(SP)
9D0077A8  AFA8002C   SW T0, 44(SP)
9D0077AC  AFA70028   SW A3, 40(SP)
9D0077B0  AFA60024   SW A2, 36(SP)
9D0077B4  AFA50020   SW A1, 32(SP)
9D0077B8  AFA4001C   SW A0, 28(SP)
9D0077BC  AFA10010   SW AT, 16(SP)
9D0077C0  F7B300F0   SDC1 F19, 240(SP)
9D0077C4  F7B200E8   SDC1 F18, 232(SP)
9D0077C8  F7B100E0   SDC1 F17, 224(SP)
9D0077CC  F7B000D8   SDC1 F16, 216(SP)
9D0077D0  F7AF00D0   SDC1 F15, 208(SP)
9D0077D4  F7AE00C8   SDC1 F14, 200(SP)
9D0077D8  F7AD00C0   SDC1 F13, 192(SP)
9D0077DC  F7AC00B8   SDC1 F12, 184(SP)
9D0077E0  F7AB00B0   SDC1 F11, 176(SP)
9D0077E4  F7AA00A8   SDC1 F10, 168(SP)
9D0077E8  F7A900A0   SDC1 F9, 160(SP)
9D0077EC  F7A80098   SDC1 F8, 152(SP)
9D0077F0  F7A70090   SDC1 F7, 144(SP)
9D0077F4  F7A60088   SDC1 F6, 136(SP)
9D0077F8  F7A50080   SDC1 F5, 128(SP)
9D0077FC  F7A40078   SDC1 F4, 120(SP)
9D007800  F7A30070   SDC1 F3, 112(SP)
9D007804  F7A20068   SDC1 F2, 104(SP)
9D007808  F7A10060   SDC1 F1, 96(SP)
9D00780C  F7A00058   SDC1 F0, 88(SP)
9D007810  00001012   MFLO V0
9D007814  AFA2011C   SW V0, 284(SP)
9D007818  00001810   MFHI V1
9D00781C  AFA30118   SW V1, 280(SP)
9D007820  00201012   MFLO V0
9D007824  AFA20114   SW V0, 276(SP)
9D007828  00201810   MFHI V1
9D00782C  AFA30110   SW V1, 272(SP)
9D007830  00401012   MFLO V0
9D007834  AFA2010C   SW V0, 268(SP)
9D007838  00401810   MFHI V1
9D00783C  AFA30108   SW V1, 264(SP)
9D007840  00601012   MFLO V0
9D007844  AFA20104   SW V0, 260(SP)
9D007848  00601810   MFHI V1
9D00784C  AFA30100   SW V1, 256(SP)
9D007850  7C3F1CB8   RDDSP V1, 0x3F
9D007854  AFA3000C   SW V1, 12(SP)
9D007858  4442F800   CFC1 V0, F31
9D00785C  AFA200FC   SW V0, 252(SP)
100:                     DRV_USART_TasksError(sysObj.drvUsart1);
9D007860  3C028000   LUI V0, -32768
9D007864  0F402B4F   JAL DRV_USART_TasksError
9D007868  8C444B30   LW A0, 19248(V0)
101:                 }
9D00786C  8FA200FC   LW V0, 252(SP)
102:                  
103:                  
104:                 
105:                  
106:                 void __ISR(_UART3_TX_VECTOR, ipl1AUTO) _IntHandlerDrvUsartTransmitInstance2(void)
107:                 {
9D007990  415DE800   RDPGPR SP, SP
9D007994  401B7000   MFC0 K1, EPC
9D007998  401A6002   MFC0 K0, SRSCtl
9D00799C  27BDFED0   ADDIU SP, SP, -304
9D0079A0  AFBB012C   SW K1, 300(SP)
9D0079A4  401B6000   MFC0 K1, Status
9D0079A8  AFBA0124   SW K0, 292(SP)
9D0079AC  AFBB0128   SW K1, 296(SP)
9D0079B0  7C1B7844   INS K1, ZERO, 1, 15
9D0079B4  377B0400   ORI K1, K1, 1024
9D0079B8  409B6000   MTC0 K1, Status
9D0079BC  AFA30018   SW V1, 24(SP)
9D0079C0  AFA20014   SW V0, 20(SP)
9D0079C4  8FA30124   LW V1, 292(SP)
9D0079C8  3063000F   ANDI V1, V1, 15
9D0079CC  14600011   BNE V1, ZERO, 0x9D007A14
9D0079D0  00000000   NOP
9D0079D4  AFBF0054   SW RA, 84(SP)
9D0079D8  AFB90050   SW T9, 80(SP)
9D0079DC  AFB8004C   SW T8, 76(SP)
9D0079E0  AFAF0048   SW T7, 72(SP)
9D0079E4  AFAE0044   SW T6, 68(SP)
9D0079E8  AFAD0040   SW T5, 64(SP)
9D0079EC  AFAC003C   SW T4, 60(SP)
9D0079F0  AFAB0038   SW T3, 56(SP)
9D0079F4  AFAA0034   SW T2, 52(SP)
9D0079F8  AFA90030   SW T1, 48(SP)
9D0079FC  AFA8002C   SW T0, 44(SP)
9D007A00  AFA70028   SW A3, 40(SP)
9D007A04  AFA60024   SW A2, 36(SP)
9D007A08  AFA50020   SW A1, 32(SP)
9D007A0C  AFA4001C   SW A0, 28(SP)
9D007A10  AFA10010   SW AT, 16(SP)
9D007A14  F7B300F0   SDC1 F19, 240(SP)
9D007A18  F7B200E8   SDC1 F18, 232(SP)
9D007A1C  F7B100E0   SDC1 F17, 224(SP)
9D007A20  F7B000D8   SDC1 F16, 216(SP)
9D007A24  F7AF00D0   SDC1 F15, 208(SP)
9D007A28  F7AE00C8   SDC1 F14, 200(SP)
9D007A2C  F7AD00C0   SDC1 F13, 192(SP)
9D007A30  F7AC00B8   SDC1 F12, 184(SP)
9D007A34  F7AB00B0   SDC1 F11, 176(SP)
9D007A38  F7AA00A8   SDC1 F10, 168(SP)
9D007A3C  F7A900A0   SDC1 F9, 160(SP)
9D007A40  F7A80098   SDC1 F8, 152(SP)
9D007A44  F7A70090   SDC1 F7, 144(SP)
9D007A48  F7A60088   SDC1 F6, 136(SP)
9D007A4C  F7A50080   SDC1 F5, 128(SP)
9D007A50  F7A40078   SDC1 F4, 120(SP)
9D007A54  F7A30070   SDC1 F3, 112(SP)
9D007A58  F7A20068   SDC1 F2, 104(SP)
9D007A5C  F7A10060   SDC1 F1, 96(SP)
9D007A60  F7A00058   SDC1 F0, 88(SP)
9D007A64  00001012   MFLO V0
9D007A68  AFA2011C   SW V0, 284(SP)
9D007A6C  00001810   MFHI V1
9D007A70  AFA30118   SW V1, 280(SP)
9D007A74  00201012   MFLO V0
9D007A78  AFA20114   SW V0, 276(SP)
9D007A7C  00201810   MFHI V1
9D007A80  AFA30110   SW V1, 272(SP)
9D007A84  00401012   MFLO V0
9D007A88  AFA2010C   SW V0, 268(SP)
9D007A8C  00401810   MFHI V1
9D007A90  AFA30108   SW V1, 264(SP)
9D007A94  00601012   MFLO V0
9D007A98  AFA20104   SW V0, 260(SP)
9D007A9C  00601810   MFHI V1
9D007AA0  AFA30100   SW V1, 256(SP)
9D007AA4  7C3F1CB8   RDDSP V1, 0x3F
9D007AA8  AFA3000C   SW V1, 12(SP)
9D007AAC  4442F800   CFC1 V0, F31
9D007AB0  AFA200FC   SW V0, 252(SP)
108:                     DRV_USART_TasksTransmit(sysObj.drvUsart2);
9D007AB4  3C028000   LUI V0, -32768
9D007AB8  0F402AFF   JAL DRV_USART_TasksTransmit
9D007ABC  8C444B34   LW A0, 19252(V0)
109:                 }
9D007AC0  8FA200FC   LW V0, 252(SP)
110:                 void __ISR(_UART3_RX_VECTOR, ipl4AUTO) _IntHandlerDrvUsartReceiveInstance2(void)
111:                 {
9D007BE4  415DE800   RDPGPR SP, SP
9D007BE8  401B7000   MFC0 K1, EPC
9D007BEC  401A6002   MFC0 K0, SRSCtl
9D007BF0  27BDFED0   ADDIU SP, SP, -304
9D007BF4  AFBB012C   SW K1, 300(SP)
9D007BF8  401B6000   MFC0 K1, Status
9D007BFC  AFBA0124   SW K0, 292(SP)
9D007C00  AFBB0128   SW K1, 296(SP)
9D007C04  7C1B7844   INS K1, ZERO, 1, 15
9D007C08  377B1000   ORI K1, K1, 4096
9D007C0C  409B6000   MTC0 K1, Status
9D007C10  AFA30018   SW V1, 24(SP)
9D007C14  AFA20014   SW V0, 20(SP)
9D007C18  8FA30124   LW V1, 292(SP)
9D007C1C  3063000F   ANDI V1, V1, 15
9D007C20  14600011   BNE V1, ZERO, 0x9D007C68
9D007C24  00000000   NOP
9D007C28  AFBF0054   SW RA, 84(SP)
9D007C2C  AFB90050   SW T9, 80(SP)
9D007C30  AFB8004C   SW T8, 76(SP)
9D007C34  AFAF0048   SW T7, 72(SP)
9D007C38  AFAE0044   SW T6, 68(SP)
9D007C3C  AFAD0040   SW T5, 64(SP)
9D007C40  AFAC003C   SW T4, 60(SP)
9D007C44  AFAB0038   SW T3, 56(SP)
9D007C48  AFAA0034   SW T2, 52(SP)
9D007C4C  AFA90030   SW T1, 48(SP)
9D007C50  AFA8002C   SW T0, 44(SP)
9D007C54  AFA70028   SW A3, 40(SP)
9D007C58  AFA60024   SW A2, 36(SP)
9D007C5C  AFA50020   SW A1, 32(SP)
9D007C60  AFA4001C   SW A0, 28(SP)
9D007C64  AFA10010   SW AT, 16(SP)
9D007C68  F7B300F0   SDC1 F19, 240(SP)
9D007C6C  F7B200E8   SDC1 F18, 232(SP)
9D007C70  F7B100E0   SDC1 F17, 224(SP)
9D007C74  F7B000D8   SDC1 F16, 216(SP)
9D007C78  F7AF00D0   SDC1 F15, 208(SP)
9D007C7C  F7AE00C8   SDC1 F14, 200(SP)
9D007C80  F7AD00C0   SDC1 F13, 192(SP)
9D007C84  F7AC00B8   SDC1 F12, 184(SP)
9D007C88  F7AB00B0   SDC1 F11, 176(SP)
9D007C8C  F7AA00A8   SDC1 F10, 168(SP)
9D007C90  F7A900A0   SDC1 F9, 160(SP)
9D007C94  F7A80098   SDC1 F8, 152(SP)
9D007C98  F7A70090   SDC1 F7, 144(SP)
9D007C9C  F7A60088   SDC1 F6, 136(SP)
9D007CA0  F7A50080   SDC1 F5, 128(SP)
9D007CA4  F7A40078   SDC1 F4, 120(SP)
9D007CA8  F7A30070   SDC1 F3, 112(SP)
9D007CAC  F7A20068   SDC1 F2, 104(SP)
9D007CB0  F7A10060   SDC1 F1, 96(SP)
9D007CB4  F7A00058   SDC1 F0, 88(SP)
9D007CB8  00001012   MFLO V0
9D007CBC  AFA2011C   SW V0, 284(SP)
9D007CC0  00001810   MFHI V1
9D007CC4  AFA30118   SW V1, 280(SP)
9D007CC8  00201012   MFLO V0
9D007CCC  AFA20114   SW V0, 276(SP)
9D007CD0  00201810   MFHI V1
9D007CD4  AFA30110   SW V1, 272(SP)
9D007CD8  00401012   MFLO V0
9D007CDC  AFA2010C   SW V0, 268(SP)
9D007CE0  00401810   MFHI V1
9D007CE4  AFA30108   SW V1, 264(SP)
9D007CE8  00601012   MFLO V0
9D007CEC  AFA20104   SW V0, 260(SP)
9D007CF0  00601810   MFHI V1
9D007CF4  AFA30100   SW V1, 256(SP)
9D007CF8  7C3F1CB8   RDDSP V1, 0x3F
9D007CFC  AFA3000C   SW V1, 12(SP)
9D007D00  4442F800   CFC1 V0, F31
9D007D04  AFA200FC   SW V0, 252(SP)
112:                     DRV_USART_TasksReceive(sysObj.drvUsart2);
9D007D08  3C028000   LUI V0, -32768
9D007D0C  0F402B27   JAL DRV_USART_TasksReceive
9D007D10  8C444B34   LW A0, 19252(V0)
113:                 }
9D007D14  8FA200FC   LW V0, 252(SP)
114:                 void __ISR(_UART3_FAULT_VECTOR, ipl4AUTO) _IntHandlerDrvUsartErrorInstance2(void)
115:                 {
9D007E38  415DE800   RDPGPR SP, SP
9D007E3C  401B7000   MFC0 K1, EPC
9D007E40  401A6002   MFC0 K0, SRSCtl
9D007E44  27BDFED0   ADDIU SP, SP, -304
9D007E48  AFBB012C   SW K1, 300(SP)
9D007E4C  401B6000   MFC0 K1, Status
9D007E50  AFBA0124   SW K0, 292(SP)
9D007E54  AFBB0128   SW K1, 296(SP)
9D007E58  7C1B7844   INS K1, ZERO, 1, 15
9D007E5C  377B1000   ORI K1, K1, 4096
9D007E60  409B6000   MTC0 K1, Status
9D007E64  AFA30018   SW V1, 24(SP)
9D007E68  AFA20014   SW V0, 20(SP)
9D007E6C  8FA30124   LW V1, 292(SP)
9D007E70  3063000F   ANDI V1, V1, 15
9D007E74  14600011   BNE V1, ZERO, 0x9D007EBC
9D007E78  00000000   NOP
9D007E7C  AFBF0054   SW RA, 84(SP)
9D007E80  AFB90050   SW T9, 80(SP)
9D007E84  AFB8004C   SW T8, 76(SP)
9D007E88  AFAF0048   SW T7, 72(SP)
9D007E8C  AFAE0044   SW T6, 68(SP)
9D007E90  AFAD0040   SW T5, 64(SP)
9D007E94  AFAC003C   SW T4, 60(SP)
9D007E98  AFAB0038   SW T3, 56(SP)
9D007E9C  AFAA0034   SW T2, 52(SP)
9D007EA0  AFA90030   SW T1, 48(SP)
9D007EA4  AFA8002C   SW T0, 44(SP)
9D007EA8  AFA70028   SW A3, 40(SP)
9D007EAC  AFA60024   SW A2, 36(SP)
9D007EB0  AFA50020   SW A1, 32(SP)
9D007EB4  AFA4001C   SW A0, 28(SP)
9D007EB8  AFA10010   SW AT, 16(SP)
9D007EBC  F7B300F0   SDC1 F19, 240(SP)
9D007EC0  F7B200E8   SDC1 F18, 232(SP)
9D007EC4  F7B100E0   SDC1 F17, 224(SP)
9D007EC8  F7B000D8   SDC1 F16, 216(SP)
9D007ECC  F7AF00D0   SDC1 F15, 208(SP)
9D007ED0  F7AE00C8   SDC1 F14, 200(SP)
9D007ED4  F7AD00C0   SDC1 F13, 192(SP)
9D007ED8  F7AC00B8   SDC1 F12, 184(SP)
9D007EDC  F7AB00B0   SDC1 F11, 176(SP)
9D007EE0  F7AA00A8   SDC1 F10, 168(SP)
9D007EE4  F7A900A0   SDC1 F9, 160(SP)
9D007EE8  F7A80098   SDC1 F8, 152(SP)
9D007EEC  F7A70090   SDC1 F7, 144(SP)
9D007EF0  F7A60088   SDC1 F6, 136(SP)
9D007EF4  F7A50080   SDC1 F5, 128(SP)
9D007EF8  F7A40078   SDC1 F4, 120(SP)
9D007EFC  F7A30070   SDC1 F3, 112(SP)
9D007F00  F7A20068   SDC1 F2, 104(SP)
9D007F04  F7A10060   SDC1 F1, 96(SP)
9D007F08  F7A00058   SDC1 F0, 88(SP)
9D007F0C  00001012   MFLO V0
9D007F10  AFA2011C   SW V0, 284(SP)
9D007F14  00001810   MFHI V1
9D007F18  AFA30118   SW V1, 280(SP)
9D007F1C  00201012   MFLO V0
9D007F20  AFA20114   SW V0, 276(SP)
9D007F24  00201810   MFHI V1
9D007F28  AFA30110   SW V1, 272(SP)
9D007F2C  00401012   MFLO V0
9D007F30  AFA2010C   SW V0, 268(SP)
9D007F34  00401810   MFHI V1
9D007F38  AFA30108   SW V1, 264(SP)
9D007F3C  00601012   MFLO V0
9D007F40  AFA20104   SW V0, 260(SP)
9D007F44  00601810   MFHI V1
9D007F48  AFA30100   SW V1, 256(SP)
9D007F4C  7C3F1CB8   RDDSP V1, 0x3F
9D007F50  AFA3000C   SW V1, 12(SP)
9D007F54  4442F800   CFC1 V0, F31
9D007F58  AFA200FC   SW V0, 252(SP)
116:                     DRV_USART_TasksError(sysObj.drvUsart2);
9D007F5C  3C028000   LUI V0, -32768
9D007F60  0F402B4F   JAL DRV_USART_TasksError
9D007F64  8C444B34   LW A0, 19252(V0)
117:                 }
9D007F68  8FA200FC   LW V0, 252(SP)
118:                 
119:                  
120:                 
121:                  
122:                 
123:                  
124:                 
125:                  
126:                  void __ISR(_CHANGE_NOTICE_B_VECTOR, ipl1AUTO) _IntHandlerChangeNotification_PortB(void)
127:                 {
9D005370  415DE800   RDPGPR SP, SP
9D005374  401B7000   MFC0 K1, EPC
9D005378  401A6002   MFC0 K0, SRSCtl
9D00537C  27BDFED0   ADDIU SP, SP, -304
9D005380  AFBB012C   SW K1, 300(SP)
9D005384  401B6000   MFC0 K1, Status
9D005388  AFBA0124   SW K0, 292(SP)
9D00538C  AFBB0128   SW K1, 296(SP)
9D005390  7C1B7844   INS K1, ZERO, 1, 15
9D005394  377B0400   ORI K1, K1, 1024
9D005398  409B6000   MTC0 K1, Status
9D00539C  AFA30018   SW V1, 24(SP)
9D0053A0  AFA20014   SW V0, 20(SP)
9D0053A4  8FA30124   LW V1, 292(SP)
9D0053A8  3063000F   ANDI V1, V1, 15
9D0053AC  14600011   BNE V1, ZERO, 0x9D0053F4
9D0053B0  00000000   NOP
9D0053B4  AFBF0054   SW RA, 84(SP)
9D0053B8  AFB90050   SW T9, 80(SP)
9D0053BC  AFB8004C   SW T8, 76(SP)
9D0053C0  AFAF0048   SW T7, 72(SP)
9D0053C4  AFAE0044   SW T6, 68(SP)
9D0053C8  AFAD0040   SW T5, 64(SP)
9D0053CC  AFAC003C   SW T4, 60(SP)
9D0053D0  AFAB0038   SW T3, 56(SP)
9D0053D4  AFAA0034   SW T2, 52(SP)
9D0053D8  AFA90030   SW T1, 48(SP)
9D0053DC  AFA8002C   SW T0, 44(SP)
9D0053E0  AFA70028   SW A3, 40(SP)
9D0053E4  AFA60024   SW A2, 36(SP)
9D0053E8  AFA50020   SW A1, 32(SP)
9D0053EC  AFA4001C   SW A0, 28(SP)
9D0053F0  AFA10010   SW AT, 16(SP)
9D0053F4  F7B300F0   SDC1 F19, 240(SP)
9D0053F8  F7B200E8   SDC1 F18, 232(SP)
9D0053FC  F7B100E0   SDC1 F17, 224(SP)
9D005400  F7B000D8   SDC1 F16, 216(SP)
9D005404  F7AF00D0   SDC1 F15, 208(SP)
9D005408  F7AE00C8   SDC1 F14, 200(SP)
9D00540C  F7AD00C0   SDC1 F13, 192(SP)
9D005410  F7AC00B8   SDC1 F12, 184(SP)
9D005414  F7AB00B0   SDC1 F11, 176(SP)
9D005418  F7AA00A8   SDC1 F10, 168(SP)
9D00541C  F7A900A0   SDC1 F9, 160(SP)
9D005420  F7A80098   SDC1 F8, 152(SP)
9D005424  F7A70090   SDC1 F7, 144(SP)
9D005428  F7A60088   SDC1 F6, 136(SP)
9D00542C  F7A50080   SDC1 F5, 128(SP)
9D005430  F7A40078   SDC1 F4, 120(SP)
9D005434  F7A30070   SDC1 F3, 112(SP)
9D005438  F7A20068   SDC1 F2, 104(SP)
9D00543C  F7A10060   SDC1 F1, 96(SP)
9D005440  F7A00058   SDC1 F0, 88(SP)
9D005444  00001012   MFLO V0
9D005448  AFA2011C   SW V0, 284(SP)
9D00544C  00001810   MFHI V1
9D005450  AFA30118   SW V1, 280(SP)
9D005454  00201012   MFLO V0
9D005458  AFA20114   SW V0, 276(SP)
9D00545C  00201810   MFHI V1
9D005460  AFA30110   SW V1, 272(SP)
9D005464  00401012   MFLO V0
9D005468  AFA2010C   SW V0, 268(SP)
9D00546C  00401810   MFHI V1
9D005470  AFA30108   SW V1, 264(SP)
9D005474  00601012   MFLO V0
9D005478  AFA20104   SW V0, 260(SP)
9D00547C  00601810   MFHI V1
9D005480  AFA30100   SW V1, 256(SP)
9D005484  7C3F1CB8   RDDSP V1, 0x3F
9D005488  AFA3000C   SW V1, 12(SP)
9D00548C  4442F800   CFC1 V0, F31
9D005490  AFA200FC   SW V0, 252(SP)
128:                     if(getLoadedState())
9D005494  0F403327   JAL getLoadedState
9D005498  00000000   NOP
9D00549C  10400004   BEQ V0, ZERO, 0x9D0054B0
9D0054A0  3C02BF86   LUI V0, -16506
129:                     {
130:                        pinChangeNotified();
9D0054A4  0F402D35   JAL pinChangeNotified
9D0054A8  00000000   NOP
131:                     }
132:                     PORTB;
9D0054AC  3C02BF86   LUI V0, -16506
9D0054B0  8C420120   LW V0, 288(V0)
133:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_CHANGE_NOTICE_B);
134:                 }
9D0054C4  8FA200FC   LW V0, 252(SP)
135:                    void __ISR(_CHANGE_NOTICE_C_VECTOR, ipl1AUTO) _IntHandlerChangeNotification_PortC(void)
136:                 {
9D0055E8  415DE800   RDPGPR SP, SP
9D0055EC  401B7000   MFC0 K1, EPC
9D0055F0  401A6002   MFC0 K0, SRSCtl
9D0055F4  27BDFED0   ADDIU SP, SP, -304
9D0055F8  AFBB012C   SW K1, 300(SP)
9D0055FC  401B6000   MFC0 K1, Status
9D005600  AFBA0124   SW K0, 292(SP)
9D005604  AFBB0128   SW K1, 296(SP)
9D005608  7C1B7844   INS K1, ZERO, 1, 15
9D00560C  377B0400   ORI K1, K1, 1024
9D005610  409B6000   MTC0 K1, Status
9D005614  AFA30018   SW V1, 24(SP)
9D005618  AFA20014   SW V0, 20(SP)
9D00561C  8FA30124   LW V1, 292(SP)
9D005620  3063000F   ANDI V1, V1, 15
9D005624  14600011   BNE V1, ZERO, 0x9D00566C
9D005628  00000000   NOP
9D00562C  AFBF0054   SW RA, 84(SP)
9D005630  AFB90050   SW T9, 80(SP)
9D005634  AFB8004C   SW T8, 76(SP)
9D005638  AFAF0048   SW T7, 72(SP)
9D00563C  AFAE0044   SW T6, 68(SP)
9D005640  AFAD0040   SW T5, 64(SP)
9D005644  AFAC003C   SW T4, 60(SP)
9D005648  AFAB0038   SW T3, 56(SP)
9D00564C  AFAA0034   SW T2, 52(SP)
9D005650  AFA90030   SW T1, 48(SP)
9D005654  AFA8002C   SW T0, 44(SP)
9D005658  AFA70028   SW A3, 40(SP)
9D00565C  AFA60024   SW A2, 36(SP)
9D005660  AFA50020   SW A1, 32(SP)
9D005664  AFA4001C   SW A0, 28(SP)
9D005668  AFA10010   SW AT, 16(SP)
9D00566C  F7B300F0   SDC1 F19, 240(SP)
9D005670  F7B200E8   SDC1 F18, 232(SP)
9D005674  F7B100E0   SDC1 F17, 224(SP)
9D005678  F7B000D8   SDC1 F16, 216(SP)
9D00567C  F7AF00D0   SDC1 F15, 208(SP)
9D005680  F7AE00C8   SDC1 F14, 200(SP)
9D005684  F7AD00C0   SDC1 F13, 192(SP)
9D005688  F7AC00B8   SDC1 F12, 184(SP)
9D00568C  F7AB00B0   SDC1 F11, 176(SP)
9D005690  F7AA00A8   SDC1 F10, 168(SP)
9D005694  F7A900A0   SDC1 F9, 160(SP)
9D005698  F7A80098   SDC1 F8, 152(SP)
9D00569C  F7A70090   SDC1 F7, 144(SP)
9D0056A0  F7A60088   SDC1 F6, 136(SP)
9D0056A4  F7A50080   SDC1 F5, 128(SP)
9D0056A8  F7A40078   SDC1 F4, 120(SP)
9D0056AC  F7A30070   SDC1 F3, 112(SP)
9D0056B0  F7A20068   SDC1 F2, 104(SP)
9D0056B4  F7A10060   SDC1 F1, 96(SP)
9D0056B8  F7A00058   SDC1 F0, 88(SP)
9D0056BC  00001012   MFLO V0
9D0056C0  AFA2011C   SW V0, 284(SP)
9D0056C4  00001810   MFHI V1
9D0056C8  AFA30118   SW V1, 280(SP)
9D0056CC  00201012   MFLO V0
9D0056D0  AFA20114   SW V0, 276(SP)
9D0056D4  00201810   MFHI V1
9D0056D8  AFA30110   SW V1, 272(SP)
9D0056DC  00401012   MFLO V0
9D0056E0  AFA2010C   SW V0, 268(SP)
9D0056E4  00401810   MFHI V1
9D0056E8  AFA30108   SW V1, 264(SP)
9D0056EC  00601012   MFLO V0
9D0056F0  AFA20104   SW V0, 260(SP)
9D0056F4  00601810   MFHI V1
9D0056F8  AFA30100   SW V1, 256(SP)
9D0056FC  7C3F1CB8   RDDSP V1, 0x3F
9D005700  AFA3000C   SW V1, 12(SP)
9D005704  4442F800   CFC1 V0, F31
9D005708  AFA200FC   SW V0, 252(SP)
137:                     if(getLoadedState())
9D00570C  0F403327   JAL getLoadedState
9D005710  00000000   NOP
9D005714  10400004   BEQ V0, ZERO, 0x9D005728
9D005718  3C02BF86   LUI V0, -16506
138:                     {
139:                        pinChangeNotified();
9D00571C  0F402D35   JAL pinChangeNotified
9D005720  00000000   NOP
140:                     }
141:                     PORTC;
9D005724  3C02BF86   LUI V0, -16506
9D005728  8C420220   LW V0, 544(V0)
142:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_CHANGE_NOTICE_C);
143:                 }
9D00573C  8FA200FC   LW V0, 252(SP)
144:                    void __ISR(_CHANGE_NOTICE_D_VECTOR, ipl1AUTO) _IntHandlerChangeNotification_PortD(void)
145:                 {
9D005860  415DE800   RDPGPR SP, SP
9D005864  401B7000   MFC0 K1, EPC
9D005868  401A6002   MFC0 K0, SRSCtl
9D00586C  27BDFED0   ADDIU SP, SP, -304
9D005870  AFBB012C   SW K1, 300(SP)
9D005874  401B6000   MFC0 K1, Status
9D005878  AFBA0124   SW K0, 292(SP)
9D00587C  AFBB0128   SW K1, 296(SP)
9D005880  7C1B7844   INS K1, ZERO, 1, 15
9D005884  377B0400   ORI K1, K1, 1024
9D005888  409B6000   MTC0 K1, Status
9D00588C  AFA30018   SW V1, 24(SP)
9D005890  AFA20014   SW V0, 20(SP)
9D005894  8FA30124   LW V1, 292(SP)
9D005898  3063000F   ANDI V1, V1, 15
9D00589C  14600011   BNE V1, ZERO, 0x9D0058E4
9D0058A0  00000000   NOP
9D0058A4  AFBF0054   SW RA, 84(SP)
9D0058A8  AFB90050   SW T9, 80(SP)
9D0058AC  AFB8004C   SW T8, 76(SP)
9D0058B0  AFAF0048   SW T7, 72(SP)
9D0058B4  AFAE0044   SW T6, 68(SP)
9D0058B8  AFAD0040   SW T5, 64(SP)
9D0058BC  AFAC003C   SW T4, 60(SP)
9D0058C0  AFAB0038   SW T3, 56(SP)
9D0058C4  AFAA0034   SW T2, 52(SP)
9D0058C8  AFA90030   SW T1, 48(SP)
9D0058CC  AFA8002C   SW T0, 44(SP)
9D0058D0  AFA70028   SW A3, 40(SP)
9D0058D4  AFA60024   SW A2, 36(SP)
9D0058D8  AFA50020   SW A1, 32(SP)
9D0058DC  AFA4001C   SW A0, 28(SP)
9D0058E0  AFA10010   SW AT, 16(SP)
9D0058E4  F7B300F0   SDC1 F19, 240(SP)
9D0058E8  F7B200E8   SDC1 F18, 232(SP)
9D0058EC  F7B100E0   SDC1 F17, 224(SP)
9D0058F0  F7B000D8   SDC1 F16, 216(SP)
9D0058F4  F7AF00D0   SDC1 F15, 208(SP)
9D0058F8  F7AE00C8   SDC1 F14, 200(SP)
9D0058FC  F7AD00C0   SDC1 F13, 192(SP)
9D005900  F7AC00B8   SDC1 F12, 184(SP)
9D005904  F7AB00B0   SDC1 F11, 176(SP)
9D005908  F7AA00A8   SDC1 F10, 168(SP)
9D00590C  F7A900A0   SDC1 F9, 160(SP)
9D005910  F7A80098   SDC1 F8, 152(SP)
9D005914  F7A70090   SDC1 F7, 144(SP)
9D005918  F7A60088   SDC1 F6, 136(SP)
9D00591C  F7A50080   SDC1 F5, 128(SP)
9D005920  F7A40078   SDC1 F4, 120(SP)
9D005924  F7A30070   SDC1 F3, 112(SP)
9D005928  F7A20068   SDC1 F2, 104(SP)
9D00592C  F7A10060   SDC1 F1, 96(SP)
9D005930  F7A00058   SDC1 F0, 88(SP)
9D005934  00001012   MFLO V0
9D005938  AFA2011C   SW V0, 284(SP)
9D00593C  00001810   MFHI V1
9D005940  AFA30118   SW V1, 280(SP)
9D005944  00201012   MFLO V0
9D005948  AFA20114   SW V0, 276(SP)
9D00594C  00201810   MFHI V1
9D005950  AFA30110   SW V1, 272(SP)
9D005954  00401012   MFLO V0
9D005958  AFA2010C   SW V0, 268(SP)
9D00595C  00401810   MFHI V1
9D005960  AFA30108   SW V1, 264(SP)
9D005964  00601012   MFLO V0
9D005968  AFA20104   SW V0, 260(SP)
9D00596C  00601810   MFHI V1
9D005970  AFA30100   SW V1, 256(SP)
9D005974  7C3F1CB8   RDDSP V1, 0x3F
9D005978  AFA3000C   SW V1, 12(SP)
9D00597C  4442F800   CFC1 V0, F31
9D005980  AFA200FC   SW V0, 252(SP)
146:                     if(getLoadedState())
9D005984  0F403327   JAL getLoadedState
9D005988  00000000   NOP
9D00598C  10400004   BEQ V0, ZERO, 0x9D0059A0
9D005990  3C02BF86   LUI V0, -16506
147:                     {
148:                        pinChangeNotified();
9D005994  0F402D35   JAL pinChangeNotified
9D005998  00000000   NOP
149:                     }
150:                     PORTD;
9D00599C  3C02BF86   LUI V0, -16506
9D0059A0  8C420320   LW V0, 800(V0)
151:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_CHANGE_NOTICE_D);
152:                 }
9D0059B4  8FA200FC   LW V0, 252(SP)
153:                 
154:                  
155:                 
156:                 void __ISR(_TIMER_1_VECTOR, ipl6AUTO) IntHandlerDrvTmrInstance0(void)
157:                 {
9D006224  415DE800   RDPGPR SP, SP
9D006228  401B7000   MFC0 K1, EPC
9D00622C  401A6002   MFC0 K0, SRSCtl
9D006230  27BDFED0   ADDIU SP, SP, -304
9D006234  AFBB012C   SW K1, 300(SP)
9D006238  401B6000   MFC0 K1, Status
9D00623C  AFBA0124   SW K0, 292(SP)
9D006240  AFBB0128   SW K1, 296(SP)
9D006244  7C1B7844   INS K1, ZERO, 1, 15
9D006248  377B1800   ORI K1, K1, 6144
9D00624C  409B6000   MTC0 K1, Status
9D006250  AFA30018   SW V1, 24(SP)
9D006254  AFA20014   SW V0, 20(SP)
9D006258  8FA30124   LW V1, 292(SP)
9D00625C  3063000F   ANDI V1, V1, 15
9D006260  14600011   BNE V1, ZERO, 0x9D0062A8
9D006264  00000000   NOP
9D006268  AFBF0054   SW RA, 84(SP)
9D00626C  AFB90050   SW T9, 80(SP)
9D006270  AFB8004C   SW T8, 76(SP)
9D006274  AFAF0048   SW T7, 72(SP)
9D006278  AFAE0044   SW T6, 68(SP)
9D00627C  AFAD0040   SW T5, 64(SP)
9D006280  AFAC003C   SW T4, 60(SP)
9D006284  AFAB0038   SW T3, 56(SP)
9D006288  AFAA0034   SW T2, 52(SP)
9D00628C  AFA90030   SW T1, 48(SP)
9D006290  AFA8002C   SW T0, 44(SP)
9D006294  AFA70028   SW A3, 40(SP)
9D006298  AFA60024   SW A2, 36(SP)
9D00629C  AFA50020   SW A1, 32(SP)
9D0062A0  AFA4001C   SW A0, 28(SP)
9D0062A4  AFA10010   SW AT, 16(SP)
9D0062A8  F7B300F0   SDC1 F19, 240(SP)
9D0062AC  F7B200E8   SDC1 F18, 232(SP)
9D0062B0  F7B100E0   SDC1 F17, 224(SP)
9D0062B4  F7B000D8   SDC1 F16, 216(SP)
9D0062B8  F7AF00D0   SDC1 F15, 208(SP)
9D0062BC  F7AE00C8   SDC1 F14, 200(SP)
9D0062C0  F7AD00C0   SDC1 F13, 192(SP)
9D0062C4  F7AC00B8   SDC1 F12, 184(SP)
9D0062C8  F7AB00B0   SDC1 F11, 176(SP)
9D0062CC  F7AA00A8   SDC1 F10, 168(SP)
9D0062D0  F7A900A0   SDC1 F9, 160(SP)
9D0062D4  F7A80098   SDC1 F8, 152(SP)
9D0062D8  F7A70090   SDC1 F7, 144(SP)
9D0062DC  F7A60088   SDC1 F6, 136(SP)
9D0062E0  F7A50080   SDC1 F5, 128(SP)
9D0062E4  F7A40078   SDC1 F4, 120(SP)
9D0062E8  F7A30070   SDC1 F3, 112(SP)
9D0062EC  F7A20068   SDC1 F2, 104(SP)
9D0062F0  F7A10060   SDC1 F1, 96(SP)
9D0062F4  F7A00058   SDC1 F0, 88(SP)
9D0062F8  00001012   MFLO V0
9D0062FC  AFA2011C   SW V0, 284(SP)
9D006300  00001810   MFHI V1
9D006304  AFA30118   SW V1, 280(SP)
9D006308  00201012   MFLO V0
9D00630C  AFA20114   SW V0, 276(SP)
9D006310  00201810   MFHI V1
9D006314  AFA30110   SW V1, 272(SP)
9D006318  00401012   MFLO V0
9D00631C  AFA2010C   SW V0, 268(SP)
9D006320  00401810   MFHI V1
9D006324  AFA30108   SW V1, 264(SP)
9D006328  00601012   MFLO V0
9D00632C  AFA20104   SW V0, 260(SP)
9D006330  00601810   MFHI V1
9D006334  AFA30100   SW V1, 256(SP)
9D006338  7C3F1CB8   RDDSP V1, 0x3F
9D00633C  AFA3000C   SW V1, 12(SP)
9D006340  4442F800   CFC1 V0, F31
9D006344  AFA200FC   SW V0, 252(SP)
158:                     globalTimerTracker( );
9D006348  0F403314   JAL globalTimerTracker
9D00634C  00000000   NOP
159:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_1);
160:                 }
9D006360  8FA200FC   LW V0, 252(SP)
161:                  
162:                 void __ISR(_CAN1_VECTOR, IPL6AUTO) _IntHandlerDrvCANInstance0(void)
163:                 {
9D006484  415DE800   RDPGPR SP, SP
9D006488  401B7000   MFC0 K1, EPC
9D00648C  401A6002   MFC0 K0, SRSCtl
9D006490  27BDFED0   ADDIU SP, SP, -304
9D006494  AFBB012C   SW K1, 300(SP)
9D006498  401B6000   MFC0 K1, Status
9D00649C  AFBA0124   SW K0, 292(SP)
9D0064A0  AFBB0128   SW K1, 296(SP)
9D0064A4  7C1B7844   INS K1, ZERO, 1, 15
9D0064A8  377B1800   ORI K1, K1, 6144
9D0064AC  409B6000   MTC0 K1, Status
9D0064B0  AFA30018   SW V1, 24(SP)
9D0064B4  AFA20014   SW V0, 20(SP)
9D0064B8  8FA30124   LW V1, 292(SP)
9D0064BC  3063000F   ANDI V1, V1, 15
9D0064C0  14600011   BNE V1, ZERO, 0x9D006508
9D0064C4  00000000   NOP
9D0064C8  AFBF0054   SW RA, 84(SP)
9D0064CC  AFB90050   SW T9, 80(SP)
9D0064D0  AFB8004C   SW T8, 76(SP)
9D0064D4  AFAF0048   SW T7, 72(SP)
9D0064D8  AFAE0044   SW T6, 68(SP)
9D0064DC  AFAD0040   SW T5, 64(SP)
9D0064E0  AFAC003C   SW T4, 60(SP)
9D0064E4  AFAB0038   SW T3, 56(SP)
9D0064E8  AFAA0034   SW T2, 52(SP)
9D0064EC  AFA90030   SW T1, 48(SP)
9D0064F0  AFA8002C   SW T0, 44(SP)
9D0064F4  AFA70028   SW A3, 40(SP)
9D0064F8  AFA60024   SW A2, 36(SP)
9D0064FC  AFA50020   SW A1, 32(SP)
9D006500  AFA4001C   SW A0, 28(SP)
9D006504  AFA10010   SW AT, 16(SP)
9D006508  F7B300F0   SDC1 F19, 240(SP)
9D00650C  F7B200E8   SDC1 F18, 232(SP)
9D006510  F7B100E0   SDC1 F17, 224(SP)
9D006514  F7B000D8   SDC1 F16, 216(SP)
9D006518  F7AF00D0   SDC1 F15, 208(SP)
9D00651C  F7AE00C8   SDC1 F14, 200(SP)
9D006520  F7AD00C0   SDC1 F13, 192(SP)
9D006524  F7AC00B8   SDC1 F12, 184(SP)
9D006528  F7AB00B0   SDC1 F11, 176(SP)
9D00652C  F7AA00A8   SDC1 F10, 168(SP)
9D006530  F7A900A0   SDC1 F9, 160(SP)
9D006534  F7A80098   SDC1 F8, 152(SP)
9D006538  F7A70090   SDC1 F7, 144(SP)
9D00653C  F7A60088   SDC1 F6, 136(SP)
9D006540  F7A50080   SDC1 F5, 128(SP)
9D006544  F7A40078   SDC1 F4, 120(SP)
9D006548  F7A30070   SDC1 F3, 112(SP)
9D00654C  F7A20068   SDC1 F2, 104(SP)
9D006550  F7A10060   SDC1 F1, 96(SP)
9D006554  F7A00058   SDC1 F0, 88(SP)
9D006558  00001012   MFLO V0
9D00655C  AFA2011C   SW V0, 284(SP)
9D006560  00001810   MFHI V1
9D006564  AFA30118   SW V1, 280(SP)
9D006568  00201012   MFLO V0
9D00656C  AFA20114   SW V0, 276(SP)
9D006570  00201810   MFHI V1
9D006574  AFA30110   SW V1, 272(SP)
9D006578  00401012   MFLO V0
9D00657C  AFA2010C   SW V0, 268(SP)
9D006580  00401810   MFHI V1
9D006584  AFA30108   SW V1, 264(SP)
9D006588  00601012   MFLO V0
9D00658C  AFA20104   SW V0, 260(SP)
9D006590  00601810   MFHI V1
9D006594  AFA30100   SW V1, 256(SP)
9D006598  7C3F1CB8   RDDSP V1, 0x3F
9D00659C  AFA3000C   SW V1, 12(SP)
9D0065A0  4442F800   CFC1 V0, F31
9D0065A4  AFA200FC   SW V0, 252(SP)
164:                     CAN_ISR_CALLBACK();
9D0065A8  0F400E46   JAL CAN_ISR_CALLBACK
9D0065AC  00000000   NOP
165:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_CAN_1);
166:                 }
9D0065C0  8FA200FC   LW V0, 252(SP)
167:                 
168:                 
169:                 
170:                 /*******************************************************************************
171:                  End of File
172:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources, such as the
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      OFF
63:                  #pragma config JTAGEN =     OFF
64:                  #pragma config ICESEL =     ICS_PGx1
65:                  #pragma config TRCEN =      OFF
66:                  #pragma config BOOTISA =    MIPS32
67:                  #pragma config FECCCON =    OFF_UNLOCKED
68:                  #pragma config FSLEEP =     OFF
69:                  #pragma config DBGPER =     PG_ALL
70:                  #pragma config SMCLR =      MCLR_NORM
71:                  #pragma config SOSCGAIN =   GAIN_LEVEL_3
72:                  #pragma config SOSCBOOST =  ON
73:                  #pragma config POSCGAIN =   GAIN_LEVEL_3
74:                  #pragma config POSCBOOST =  ON
75:                  #pragma config EJTAGBEN =   NORMAL
76:                  #pragma config CP =         OFF
77:                  
78:                  /*** DEVCFG1 ***/
79:                  
80:                  #pragma config FNOSC =      SPLL
81:                  #pragma config DMTINTV =    WIN_127_128
82:                  #pragma config FSOSCEN =    OFF
83:                  #pragma config IESO =       OFF
84:                  #pragma config POSCMOD =    EC
85:                  #pragma config OSCIOFNC =   OFF
86:                  #pragma config FCKSM =      CSECME
87:                  #pragma config WDTPS =      PS1048576
88:                  #pragma config WDTSPGM =    STOP
89:                  #pragma config FWDTEN =     OFF
90:                  #pragma config WINDIS =     NORMAL
91:                  #pragma config FWDTWINSZ =  WINSZ_25
92:                  #pragma config DMTCNT =     DMT31
93:                  #pragma config FDMTEN =     OFF
94:                  /*** DEVCFG2 ***/
95:                  
96:                  #pragma config FPLLIDIV =   DIV_1
97:                  #pragma config FPLLRNG =    RANGE_5_10_MHZ
98:                  #pragma config FPLLICLK =   PLL_FRC
99:                  #pragma config FPLLMULT =   MUL_50
100:                 #pragma config FPLLODIV =   DIV_2
101:                 #pragma config UPLLFSEL =   FREQ_24MHZ
102:                 /*** DEVCFG3 ***/
103:                 
104:                 #pragma config USERID =     0xffff
105:                 #pragma config FMIIEN =     ON
106:                 #pragma config FETHIO =     ON
107:                 #pragma config PGL1WAY =    ON
108:                 #pragma config PMDL1WAY =   ON
109:                 #pragma config IOL1WAY =    ON
110:                 #pragma config FUSBIDIO =   ON
111:                 
112:                 /*** BF1SEQ0 ***/
113:                 
114:                 #pragma config TSEQ =       0x0000
115:                 #pragma config CSEQ =       0xffff
116:                 // </editor-fold>
117:                 
118:                 // *****************************************************************************
119:                 // *****************************************************************************
120:                 // Section: Driver Initialization Data
121:                 // *****************************************************************************
122:                 // *****************************************************************************
123:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
124:                 // </editor-fold>
125:                 // <editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
126:                 
127:                 const DRV_USART_INIT drvUsart0InitData =
128:                 {
129:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX0,
130:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX0, 
131:                     .mode = DRV_USART_OPER_MODE_IDX0,
132:                     .flags = DRV_USART_INIT_FLAGS_IDX0,
133:                     .brgClock = DRV_USART_BRG_CLOCK_IDX0,
134:                     .lineControl = DRV_USART_LINE_CNTRL_IDX0,
135:                     .baud = DRV_USART_BAUD_RATE_IDX0,
136:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX0,
137:                     .linesEnable = DRV_USART_LINES_ENABLE_IDX0,
138:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,
139:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX0,
140:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX0,
141:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
142:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,    
143:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
144:                     .dmaInterruptReceive = DRV_USART_RCV_INT_SRC_IDX0,    
145:                 };
146:                 
147:                 const DRV_USART_INIT drvUsart1InitData =
148:                 {
149:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX1,
150:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX1, 
151:                     .mode = DRV_USART_OPER_MODE_IDX1,
152:                     .flags = DRV_USART_INIT_FLAGS_IDX1,
153:                     .brgClock = DRV_USART_BRG_CLOCK_IDX1,
154:                     .lineControl = DRV_USART_LINE_CNTRL_IDX1,
155:                     .baud = DRV_USART_BAUD_RATE_IDX1,
156:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX1,
157:                     .linesEnable = DRV_USART_LINES_ENABLE_IDX1,
158:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX1,
159:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX1,
160:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX1,
161:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
162:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX1,
163:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
164:                     .dmaInterruptReceive= DRV_USART_RCV_INT_SRC_IDX1,
165:                 };
166:                 
167:                 const DRV_USART_INIT drvUsart2InitData =
168:                 {
169:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX2,
170:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX2, 
171:                     .mode = DRV_USART_OPER_MODE_IDX2,
172:                     .flags = DRV_USART_INIT_FLAGS_IDX2,
173:                     .brgClock = DRV_USART_BRG_CLOCK_IDX2,
174:                     .lineControl = DRV_USART_LINE_CNTRL_IDX2,
175:                     .baud = DRV_USART_BAUD_RATE_IDX2,
176:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX2,
177:                     .linesEnable = DRV_USART_LINES_ENABLE_IDX2,
178:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX2,
179:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX2,
180:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX2,
181:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
182:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX2,
183:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
184:                     .dmaInterruptReceive = DRV_USART_RCV_INT_SRC_IDX2,
185:                 };
186:                 // </editor-fold>
187:                 
188:                 // *****************************************************************************
189:                 // *****************************************************************************
190:                 // Section: System Data
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 
194:                 /* Structure to hold the object handles for the modules in the system. */
195:                 SYSTEM_OBJECTS sysObj;
196:                 
197:                 // *****************************************************************************
198:                 // *****************************************************************************
199:                 // Section: Module Initialization Data
200:                 // *****************************************************************************
201:                 // *****************************************************************************
202:                 
203:                 // *****************************************************************************
204:                 // *****************************************************************************
205:                 // Section: Library/Stack Initialization Data
206:                 // *****************************************************************************
207:                 // *****************************************************************************
208:                 
209:                 // *****************************************************************************
210:                 // *****************************************************************************
211:                 // Section: System Initialization
212:                 // *****************************************************************************
213:                 // *****************************************************************************
214:                 
215:                 /*******************************************************************************
216:                   Function:
217:                     void SYS_Initialize ( void *data )
218:                 
219:                   Summary:
220:                     Initializes the board, services, drivers, application and other modules.
221:                 
222:                   Remarks:
223:                     See prototype in system/common/sys_module.h.
224:                  */
225:                 
226:                 void SYS_Initialize ( void* data )
227:                 {
9D005D4C  27BDFFE8   ADDIU SP, SP, -24
9D005D50  AFBF0014   SW RA, 20(SP)
9D005D54  AFB00010   SW S0, 16(SP)
228:                     /* Core Processor Initialization */
229:                     SYS_CLK_Initialize( NULL );
9D005D58  0F4027DD   JAL SYS_CLK_Initialize
9D005D5C  00002021   ADDU A0, ZERO, ZERO
230:                     SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)NULL);
9D005D60  00002021   ADDU A0, ZERO, ZERO
9D005D64  0F403301   JAL SYS_DEVCON_Initialize
9D005D68  00002821   ADDU A1, ZERO, ZERO
231:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D005D6C  0F40331C   JAL SYS_CLK_SystemFrequencyGet
9D005D70  3C108000   LUI S0, -32768
9D005D74  0F40271C   JAL SYS_DEVCON_PerformanceConfig
9D005D78  00402021   ADDU A0, V0, ZERO
232:                     SYS_PORTS_Initialize();
9D005D7C  0F4016B6   JAL SYS_PORTS_Initialize
9D005D80  26104B28   ADDIU S0, S0, 19240
233:                 
234:                     /* Initialize Drivers */
235:                     /* Initialize CAN Driver 0 */
236:                     DRV_CAN0_Initialize();
9D005D84  0F401253   JAL DRV_CAN0_Initialize
9D005D88  00000000   NOP
237:                 
238:                     /*Initialize TMR0 */
239:                     DRV_TMR0_Initialize();
9D005D8C  0F402E18   JAL DRV_TMR0_Initialize
9D005D90  00000000   NOP
240:                  
241:                      sysObj.drvUsart0 = DRV_USART_Initialize(DRV_USART_INDEX_0, (SYS_MODULE_INIT *)&drvUsart0InitData);
9D005D94  00002021   ADDU A0, ZERO, ZERO
9D005D98  3C059D00   LUI A1, -25344
9D005D9C  0F40213A   JAL DRV_USART_Initialize
9D005DA0  24A500A8   ADDIU A1, A1, 168
9D005DA4  AE020004   SW V0, 4(S0)
242:                     sysObj.drvUsart1 = DRV_USART_Initialize(DRV_USART_INDEX_1, (SYS_MODULE_INIT *)&drvUsart1InitData);
9D005DA8  24040001   ADDIU A0, ZERO, 1
9D005DAC  3C059D00   LUI A1, -25344
9D005DB0  0F40213A   JAL DRV_USART_Initialize
9D005DB4  24A5005C   ADDIU A1, A1, 92
9D005DB8  AE020008   SW V0, 8(S0)
243:                     sysObj.drvUsart2 = DRV_USART_Initialize(DRV_USART_INDEX_2, (SYS_MODULE_INIT *)&drvUsart2InitData);
9D005DBC  24040002   ADDIU A0, ZERO, 2
9D005DC0  3C059D00   LUI A1, -25344
9D005DC4  0F40213A   JAL DRV_USART_Initialize
9D005DC8  24A50010   ADDIU A1, A1, 16
9D005DCC  AE02000C   SW V0, 12(S0)
244:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART2_TX, INT_PRIORITY_LEVEL5);
245:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART2_TX, INT_SUBPRIORITY_LEVEL0);
246:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART2_RX, INT_PRIORITY_LEVEL1);
247:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART2_RX, INT_SUBPRIORITY_LEVEL0);
248:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART2_FAULT, INT_PRIORITY_LEVEL1);
249:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART2_FAULT, INT_SUBPRIORITY_LEVEL0);
250:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART4_TX, INT_PRIORITY_LEVEL5);
251:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART4_TX, INT_SUBPRIORITY_LEVEL2);
252:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART4_RX, INT_PRIORITY_LEVEL5);
253:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART4_RX, INT_SUBPRIORITY_LEVEL1);
254:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART4_FAULT, INT_PRIORITY_LEVEL5);
255:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART4_FAULT, INT_SUBPRIORITY_LEVEL1);
256:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART3_TX, INT_PRIORITY_LEVEL1);
257:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART3_TX, INT_SUBPRIORITY_LEVEL0);
258:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART3_RX, INT_PRIORITY_LEVEL4);
259:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART3_RX, INT_SUBPRIORITY_LEVEL0);
260:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART3_FAULT, INT_PRIORITY_LEVEL4);
261:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART3_FAULT, INT_SUBPRIORITY_LEVEL0);
262:                 
263:                     /* Initialize System Services */
264:                 
265:                     /*** Interrupt Service Initialization Code ***/
266:                     SYS_INT_Initialize();
9D005F8C  0F40330B   JAL SYS_INT_Initialize
9D005F90  00000000   NOP
267:                 
268:                     /* Initialize Middleware */
269:                 
270:                     /* Enable Global Interrupts */
271:                     SYS_INT_Enable();
9D005F94  40026000   MFC0 V0, Status
9D005F98  34420001   ORI V0, V0, 1
9D005F9C  40826000   MTC0 V0, Status
9D005FA0  000000C0   EHB
272:                 
273:                     /* Initialize the Application */
274:                     APP_Initialize();
9D005FA4  0F4020B4   JAL APP_Initialize
9D005FA8  00000000   NOP
275:                 }
9D005FAC  8FBF0014   LW RA, 20(SP)
276:                 
277:                 
278:                 /*******************************************************************************
279:                  End of File
280:                 */
281:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2017 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special function registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                  
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                  
62:                    Remarks:
63:                      These global static items are used instead of local variables in the
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] =
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                 
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 
125:                 void _general_exception_handler ( void )
126:                 {
9D00C390  27BDFFF8   ADDIU SP, SP, -8
9D00C394  AFBF0004   SW RA, 4(SP)
127:                     /* Mask off Mask of the ExcCode Field from the Cause Register
128:                     Refer to the MIPs Software User's manual */
129:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D00C398  40026800   MFC0 V0, Cause
9D00C39C  7C422080   EXT V0, V0, 2, 5
9D00C3A0  AF82807C   SW V0, -32644(GP)
130:                     _excep_addr = _CP0_GET_EPC();
9D00C3A4  40027000   MFC0 V0, EPC
9D00C3A8  AF828078   SW V0, -32648(GP)
131:                     _cause_str  = cause[_excep_code];
9D00C3AC  8F82807C   LW V0, -32644(GP)
9D00C3B0  00021080   SLL V0, V0, 2
9D00C3B4  3C039D01   LUI V1, -25343
9D00C3B8  246399EC   ADDIU V1, V1, -26132
9D00C3BC  7C62100A   LWX V0, V0(V1)
9D00C3C0  AF828074   SW V0, -32652(GP)
132:                     SYS_DEBUG_PRINT(SYS_ERROR_FATAL, "\n\rGeneral Exception %s (cause=%d, addr=%x).\n\r",
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D00C3C4  7000003F   SDBBP 0
138:                     }
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
73:                  
74:                      
75:                      /* PORT B Initialization */
76:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
77:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
78:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
79:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
80:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
81:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
82:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
83:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
84:                      PLIB_PORTS_Read(PORTS_ID_0, PORT_CHANNEL_B);    
85:                      PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_CHANGE_NOTICE_B);         
86:                      PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_CHANGE_NOTICE_B);
87:                      PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_CHANGE_NOTICE_B, INT_PRIORITY_LEVEL1);
88:                      PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_CHANGE_NOTICE_B, INT_SUBPRIORITY_LEVEL0);
89:                      
90:                      /* PORT C Initialization */
91:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ODC);
92:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_LAT);
93:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_TRIS ^ 0xFFFF);
94:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_C);
95:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
96:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNEN);
97:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPU);
98:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPD);
99:                      
100:                     /* PORT D Initialization */
101:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ODC);
102:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_LAT);
103:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_TRIS ^ 0xFFFF);
104:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_D);
105:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
106:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNEN);
107:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPU);
108:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPD);
109:                     PLIB_PORTS_Read(PORTS_ID_0, PORT_CHANNEL_D);    
110:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_CHANGE_NOTICE_D);         
111:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_CHANGE_NOTICE_D);
112:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_CHANGE_NOTICE_D, INT_PRIORITY_LEVEL1);
113:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_CHANGE_NOTICE_D, INT_SUBPRIORITY_LEVEL0);
114:                     
115:                     /* PORT E Initialization */
116:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ODC);
117:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_LAT);
118:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_TRIS ^ 0xFFFF);
119:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_E);
120:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
121:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNEN);
122:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPU);
123:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPD);
124:                     
125:                     /* PORT F Initialization */
126:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ODC);
127:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_LAT);
128:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_TRIS ^ 0xFFFF);
129:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_F);
130:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
131:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNEN);
132:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPU);
133:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPD);
134:                     
135:                     /* PORT G Initialization */
136:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_ODC);
137:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_LAT);
138:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_TRIS ^ 0xFFFF);
139:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_G);
140:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
141:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNEN);
142:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNPU);
143:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNPD);
144:                 
145:                 
146:                     /* PPS Input Remapping */
147:                     PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U2RX, INPUT_PIN_RPD4 );
148:                     PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_C1RX, INPUT_PIN_RPF5 );
149:                     PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U4RX, INPUT_PIN_RPB6 );
150:                     PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U3RX, INPUT_PIN_RPD11 );
151:                 
152:                     /* PPS Output Remapping */
153:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U2TX, OUTPUT_PIN_RPD5 );
154:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_C1TX, OUTPUT_PIN_RPF4 );
155:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U4TX, OUTPUT_PIN_RPB7 );
156:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U3TX, OUTPUT_PIN_RPD10 );
157:                 
158:                     
159:                 }
160:                 
161:                 /******************************************************************************
162:                   Function:
163:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
164:                 
165:                   Summary:
166:                     Reads the data from the I/O port.
167:                 
168:                   Description:
169:                     This function reads the data from the I/O port.
170:                 
171:                   Remarks:
172:                     None.
173:                 */
174:                 
175:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
176:                 {
177:                     return PLIB_PORTS_Read( index, channel );
178:                 }
00000010  00000000   NOP
179:                 
180:                 
181:                 /******************************************************************************
182:                   Function:
183:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
184:                                       		PORTS_DATA_TYPE value )
185:                 
186:                   Summary:
187:                     Writes the data from the I/O port.
188:                 
189:                   Description:
190:                     This function writes the data to the I/O port.
191:                 
192:                   Remarks:
193:                     None.
194:                 */
195:                 
196:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
197:                                       PORTS_CHANNEL channel,
198:                                       PORTS_DATA_TYPE value )
199:                 {
200:                     PLIB_PORTS_Write( index, channel, value );
201:                 }
202:                 
203:                 /******************************************************************************
204:                   Function:
205:                     PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
206:                 
207:                   Summary:
208:                     Reads the data driven on the I/O port.
209:                 
210:                   Description:
211:                     This function reads the data driven on the I/O port.
212:                 
213:                   Remarks:
214:                     None.
215:                 */
216:                 
217:                 PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
218:                 {
219:                     SYS_ASSERT(false, "This API is not supported on this device");
220:                     /* TODO: Call corresponding PLIB API */
221:                     return 0;
222:                 }
223:                 
224:                 /******************************************************************************
225:                   Function:
226:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
227:                 	                         PORTS_DATA_TYPE value,
228:                                          PORTS_DATA_MASK mask )
229:                 
230:                   Summary:
231:                     Sets the selected digital port/latch based on the mask.
232:                 
233:                   Description:
234:                     This function sets the selected digital port/latch relative to the mask.
235:                 
236:                   Remarks:
237:                     None.
238:                 */
239:                 
240:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
241:                                     PORTS_DATA_TYPE value,
242:                                     PORTS_DATA_MASK mask )
243:                 {
244:                     PLIB_PORTS_Set( index, channel, value, mask );
245:                 }
246:                 
247:                 
248:                 /******************************************************************************
249:                   Function:
250:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
251:                                            PORTS_DATA_MASK clearMask )
252:                 
253:                   Summary:
254:                     Clears the selected digital port.
255:                 
256:                   Description:
257:                     This function clears the selected digital port.
258:                 
259:                   Remarks:
260:                     None.
261:                 */
262:                 
263:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
264:                                            PORTS_DATA_MASK clearMask )
265:                 {
266:                     PLIB_PORTS_Clear ( index, channel, clearMask );
267:                 }
268:                 
269:                 
270:                 /******************************************************************************
271:                   Function:
272:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
273:                 								SYS_PORTS_PIN_DIRECTION pinDir,
274:                 								PORTS_CHANNEL channel,
275:                 								PORTS_DATA_MASK mask )
276:                   Summary:
277:                     Enables the direction for the selected port.
278:                 
279:                   Description:
280:                     This function enables the direction for the selected port.
281:                 
282:                   Remarks:
283:                     None.
284:                 */
285:                 
286:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
287:                                              SYS_PORTS_PIN_DIRECTION pinDir,
288:                                              PORTS_CHANNEL channel,
289:                                              PORTS_DATA_MASK mask )
290:                 {
291:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000000  00000000   NOP
292:                     {
293:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
294:                     }
295:                     else
296:                     {
297:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
298:                     }
299:                 }
300:                 
301:                 
302:                 /******************************************************************************
303:                   Function:
304:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
305:                                                             PORTS_CHANNEL channel )
306:                 
307:                   Summary:
308:                     Reads the port direction for the selected port.
309:                 
310:                   Description:
311:                     This function reads the port direction for the selected port.
312:                 
313:                   Remarks:
314:                     None.
315:                 */
316:                 
317:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
318:                 {
319:                     return PLIB_PORTS_DirectionGet( index, channel );
320:                 }
0000001C  00000000   NOP
321:                 
322:                 
323:                 /******************************************************************************
324:                   Function:
325:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
326:                                            PORTS_DATA_MASK toggleMask )
327:                 
328:                   Summary:
329:                     Toggles the selected digital port pins.
330:                 
331:                   Description:
332:                     This function toggles the selected digital port pins.
333:                 
334:                   Remarks:
335:                     None.
336:                 */
337:                 
338:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
339:                                        PORTS_DATA_MASK toggleMask )
340:                 {
341:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
342:                 }
343:                 
344:                 
345:                 /******************************************************************************
346:                   Function:
347:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
348:                                                      PORTS_DATA_MASK mask )
349:                 
350:                   Summary:
351:                     Enables the open drain functionality for the selected port.
352:                 
353:                   Description:
354:                     This function enables the open drain functionality for the selected port.
355:                 
356:                   Remarks:
357:                     None.
358:                 */
359:                 
360:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
361:                                                 PORTS_DATA_MASK mask )
362:                 {
363:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
364:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
365:                     {
366:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
367:                     }
368:                 #endif
369:                 }
370:                 
371:                 
372:                 /******************************************************************************
373:                   Function:
374:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
375:                                                      PORTS_DATA_MASK mask )
376:                 
377:                   Summary:
378:                     Disables the open drain functionality for the selected port.
379:                 
380:                   Description:
381:                     This function disables the open drain functionality for the selected port.
382:                 
383:                   Remarks:
384:                     None.
385:                 */
386:                 
387:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
388:                                                  PORTS_DATA_MASK mask )
389:                 {
390:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
391:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
392:                     {
393:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
394:                     }
395:                 #endif
396:                 }
397:                 
398:                 // *****************************************************************************
399:                 /* Function:
400:                     PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
401:                     ( 
402:                         PORTS_MODULE_ID index, 
403:                         PORTS_CHANNEL channel 
404:                     )
405:                 
406:                   Summary:
407:                     Reads the data from the I/O port.
408:                 	<p><b>Implementation:</b> Dynamic</p>
409:                 
410:                   Description:
411:                     This function reads the data from the I/O port.
412:                 
413:                 */
414:                 
415:                 PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
416:                 ( 
417:                     PORTS_MODULE_ID index, 
418:                     PORTS_CHANNEL channel 
419:                 )
420:                 {
421:                     SYS_ASSERT(false, "This API is not supported on this device");
422:                     return 0;
423:                 }
424:                 
425:                 // *****************************************************************************
426:                 // *****************************************************************************
427:                 // Section: SYS Change Notification Pins Routines
428:                 // *****************************************************************************
429:                 // *****************************************************************************
430:                 
431:                 /******************************************************************************
432:                   Function:
433:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
434:                 
435:                   Summary:
436:                     Globally enables the change notification.
437:                 
438:                   Description:
439:                     This function globally enables the change notification.
440:                 
441:                   Remarks:
442:                     None.
443:                 */
444:                 
445:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
446:                 {
447:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
448:                     if(PLIB_PORTS_ExistsChangeNotice(index))
449:                     {
450:                         PLIB_PORTS_ChangeNoticeEnable( index );
451:                     }
452:                 #endif
453:                 }
454:                 
455:                 /******************************************************************************
456:                   Function:
457:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
458:                 
459:                   Summary:
460:                     Globally disables the change notification.
461:                 
462:                   Description:
463:                     This function globally disables the change notification.
464:                 
465:                   Remarks:
466:                     None.
467:                 */
468:                 
469:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
470:                 {
471:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
472:                     if(PLIB_PORTS_ExistsChangeNotice(index))
473:                     {
474:                         PLIB_PORTS_ChangeNoticeDisable( index );
475:                     }
476:                 #endif
477:                 }
478:                 
479:                 /******************************************************************************
480:                   Function:
481:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
482:                 
483:                   Summary:
484:                     Globally disables the change notification for the selected port.
485:                 
486:                   Description:
487:                     This function globally disables the change notification for the selected port.
488:                 
489:                   Remarks:
490:                     None.
491:                 */
492:                 
493:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
494:                 {
495:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
496:                     if(PLIB_PORTS_ExistsChangeNotice(index))
497:                     {
498:                         PLIB_PORTS_ChangeNoticeDisable( index );
499:                     }
500:                 #endif
501:                 }
502:                 
503:                 
504:                 /******************************************************************************
505:                   Function:
506:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
507:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
508:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
509:                 
510:                   Summary:
511:                     Enables the change notification for the selected port.
512:                 
513:                   Description:
514:                     This function enables the change notification for the selected port.
515:                 
516:                   Remarks:
517:                     None.
518:                 */
519:                 
520:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
521:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
522:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
523:                 {
524:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
525:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
526:                     {
527:                         switch(value)
528:                         {
529:                             case SYS_PORTS_PULLUP_DISABLE:
530:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
531:                                 break;
532:                             case SYS_PORTS_PULLUP_ENABLE:
533:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
534:                                 break;
535:                         }
536:                     }
537:                 #endif
538:                 
539:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
540:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
541:                     {
542:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
543:                     }
544:                 #endif
545:                 }
546:                 
547:                 
548:                 /******************************************************************************
549:                   Function:
550:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
551:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
552:                 
553:                   Summary:
554:                     Disables the change notification for the selected port.
555:                 
556:                   Description:
557:                     This function disables the change notification for the selected port.
558:                 
559:                   Remarks:
560:                     None.
561:                 */
562:                 
563:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
564:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
565:                 {
566:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
567:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
568:                     {
569:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
570:                     }
571:                 #endif
572:                 }
573:                 
574:                 
575:                 /******************************************************************************
576:                   Function:
577:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
578:                 
579:                   Summary:
580:                     Enables the change notification for the selected port in Sleep or Idle mode.
581:                 
582:                   Description:
583:                     This function enables the change notification for the selected port in Sleep
584:                     or Idle mode.
585:                 
586:                   Remarks:
587:                     None.
588:                 */
589:                 
590:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
591:                 {
592:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
593:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
594:                     {
595:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
596:                     }
597:                 #endif
598:                 }
599:                 
600:                 
601:                 // *****************************************************************************
602:                 /* Function:
603:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
604:                 
605:                   Summary:
606:                     Disables the change notification for the selected port in Sleep or Idle mode.
607:                 
608:                   Description:
609:                     This function disables the change notification for the selected port in Sleep
610:                     or Idle mode.
611:                 
612:                   Remarks:
613:                     None.
614:                 */
615:                 
616:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
617:                 {
618:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
619:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
620:                     {
621:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
622:                     }
623:                 #endif
624:                 }
625:                 
626:                 
627:                 // *****************************************************************************
628:                 /* Function:
629:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
630:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
631:                 
632:                   Summary:
633:                     Enables weak pull-up on change notification pin.
634:                 
635:                   Description:
636:                     This function enables weak pull-up on change notification pin.
637:                 
638:                   Remarks:
639:                     None.
640:                 */
641:                 
642:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
643:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
644:                 {
645:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
646:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
647:                     {
648:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
649:                     }
650:                 #endif
651:                 }
652:                 
653:                 
654:                 // *****************************************************************************
655:                 /* Function:
656:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
657:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
658:                 
659:                   Summary:
660:                     Disables pull-up on input change.
661:                 
662:                   Description:
663:                     This function disables pull-up on input change.
664:                 
665:                   Remarks:
666:                     None.
667:                 */
668:                 
669:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
670:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
671:                 {
672:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
673:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
674:                     {
675:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
676:                     }
677:                 #endif
678:                 }
679:                 
680:                 
681:                 // *****************************************************************************
682:                 // *****************************************************************************
683:                 // Section: SYS PORT PINS Control Routines
684:                 // *****************************************************************************
685:                 // *****************************************************************************
686:                 
687:                 // *****************************************************************************
688:                 /* Function:
689:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
690:                     								PORTS_PIN_MODE mode)
691:                 
692:                   Summary:
693:                     Enables the selected pin as analog or digital.
694:                 
695:                   Description:
696:                     This function enables the selected pin as analog or digital.
697:                 
698:                  Remarks:
699:                     None.
700:                 */
701:                 
702:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
703:                 								PORTS_PIN_MODE mode)
704:                 {
705:                 #if defined(PLIB_PORTS_ExistsPinMode)
706:                     if(PLIB_PORTS_ExistsPinMode(index))
707:                     {
708:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
709:                     }
710:                 #endif
711:                 }
712:                 
713:                 
714:                 // *****************************************************************************
715:                 /* Function:
716:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
717:                                               PORTS_CHANNEL channel,
718:                                               PORTS_BIT_POS bitPos
719:                                               bool value )
720:                   Summary:
721:                     Writes the selected digital pin.
722:                 
723:                   Description:
724:                     This function writes the selected digital pin.
725:                 
726:                   Remarks:
727:                     None.
728:                 */
729:                 
730:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
731:                                           PORTS_CHANNEL channel,
732:                                           PORTS_BIT_POS bitPos,
733:                                           bool value )
734:                 {
735:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
736:                 }
737:                 
738:                 
739:                 // *****************************************************************************
740:                 /* Function:
741:                     bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
742:                                              PORTS_CHANNEL channel,
743:                                              PORTS_BIT_POS bitPos )
744:                 
745:                   Summary:
746:                     Reads the data driven on selected digital pin.
747:                 
748:                   Description:
749:                     This function reads the driven data on selected digital pin.
750:                 
751:                   Remarks:
752:                     None.
753:                 */
754:                 
755:                 bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
756:                                          PORTS_CHANNEL channel,
757:                                          PORTS_BIT_POS bitPos )
758:                 {
759:                     SYS_ASSERT(false, "This API is not supported on this device");
760:                     /* TODO: Call corresponding PLIB API */
761:                     return false;
762:                 }
00000000  00000000   NOP
763:                 
764:                 
765:                 // *****************************************************************************
766:                 /* Function:
767:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
768:                                              PORTS_CHANNEL channel,
769:                                              PORTS_BIT_POS bitPos )
770:                 
771:                   Summary:
772:                     Reads the selected digital pin.
773:                 
774:                   Description:
775:                     This function reads the selected digital pin.
776:                 
777:                   Remarks:
778:                     None.
779:                 */
780:                 
781:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
782:                                          PORTS_CHANNEL channel,
783:                                          PORTS_BIT_POS bitPos )
784:                 {
785:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
786:                 }
00000020  00000000   NOP
787:                 
788:                 
789:                 // *****************************************************************************
790:                 /* Function:
791:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
792:                                                PORTS_CHANNEL channel,
793:                                                PORTS_BIT_POS bitPos )
794:                 
795:                   Summary:
796:                     Toggles the selected digital pin.
797:                 
798:                   Description:
799:                     This function toggles the selected digital pin.
800:                 
801:                   Remarks:
802:                     None.
803:                 */
804:                 
805:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
806:                                            PORTS_CHANNEL channel,
807:                                            PORTS_BIT_POS bitPos )
808:                 {
809:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
810:                 }
811:                 
812:                 
813:                 // *****************************************************************************
814:                 /* Function:
815:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
816:                                            PORTS_CHANNEL channel,
817:                                            PORTS_BIT_POS bitPos )
818:                 
819:                   Summary:
820:                     Sets the selected digital pin/latch.
821:                 
822:                   Description:
823:                     This function sets the selected digital pin/latch.
824:                 
825:                   Remarks:
826:                     None.
827:                 */
828:                 
829:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
830:                                        PORTS_CHANNEL channel,
831:                                        PORTS_BIT_POS bitPos )
832:                 {
833:                     PLIB_PORTS_PinSet( index, channel, bitPos );
834:                 }
835:                 
836:                 
837:                 // *****************************************************************************
838:                 /* Function:
839:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
840:                                               PORTS_CHANNEL channel,
841:                                               PORTS_BIT_POS bitPos )
842:                 
843:                   Summary:
844:                     Clears the selected digital pin.
845:                 
846:                   Description:
847:                     This function clears the selected digital pin.
848:                 
849:                   Remarks:
850:                     None.
851:                 */
852:                 
853:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
854:                                           PORTS_CHANNEL channel,
855:                                           PORTS_BIT_POS bitPos )
856:                 {
857:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
858:                 }
859:                 
860:                 
861:                 // *****************************************************************************
862:                 /* Function:
863:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
864:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
865:                                                      PORTS_CHANNEL channel,
866:                                                      PORTS_BIT_POS bitPos )
867:                   Summary:
868:                     Enables the direction for the selected pin.
869:                 
870:                   Description:
871:                     This function enables the direction for the selected pin.
872:                 
873:                   Remarks:
874:                     None.
875:                 */
876:                 
877:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
878:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
879:                                                  PORTS_CHANNEL channel,
880:                                                  PORTS_BIT_POS bitPos )
881:                 {
882:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
883:                     {
884:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
885:                     }
886:                     else
887:                     {
888:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
889:                     }
890:                 }
891:                 
892:                 
893:                 // *****************************************************************************
894:                 /* Function:
895:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
896:                                                         PORTS_CHANNEL channel,
897:                                                         PORTS_BIT_POS bitPos )
898:                 
899:                   Summary:
900:                     Enables the open-drain functionality for the selected pin.
901:                 
902:                   Description:
903:                     This function enables the open-drain functionality for the selected pin.
904:                 
905:                   Remarks:
906:                     None.
907:                 */
908:                 
909:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
910:                                                     PORTS_CHANNEL channel,
911:                                                     PORTS_BIT_POS bitPos )
912:                 {
913:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
914:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
915:                     {
916:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
917:                     }
918:                 #endif
919:                 }
920:                 
921:                 
922:                 // *****************************************************************************
923:                 /* Function:
924:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
925:                                                          PORTS_CHANNEL channel,
926:                                                          PORTS_BIT_POS bitPos )
927:                 
928:                   Summary:
929:                     Disables the open-drain functionality for the selected pin.
930:                 
931:                   Description:
932:                     This function disables the open-drain functionality for the selected pin.
933:                 
934:                   Remarks:
935:                     None.
936:                 */
937:                 
938:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
939:                                                      PORTS_CHANNEL channel,
940:                                                      PORTS_BIT_POS bitPos )
941:                 {
942:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
943:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
944:                     {
945:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
946:                     }
947:                 #endif
948:                 }
949:                 
950:                 
951:                 // *****************************************************************************
952:                 /* Function:
953:                     void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
954:                                                         PORTS_CHANNEL channel,
955:                                                         PORTS_BIT_POS bitPos )
956:                 
957:                   Summary:
958:                     Enables the pull-up functionality for the selected pin.
959:                 	<p><b>Implementation:</b> Dynamic</p>
960:                 
961:                   Description:
962:                     This function enables the pull-up functionality for the selected pin.
963:                 
964:                   Remarks:
965:                     Not all features are available on all devices. Refer to the specific device
966:                     data sheet for availability.
967:                 */
968:                 
969:                 void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
970:                                                     PORTS_CHANNEL channel,
971:                                                     PORTS_BIT_POS bitPos )
972:                 {
973:                     SYS_ASSERT(false, "This API is not supported on this device");
974:                     return;
975:                 }
976:                 
977:                 
978:                 // *****************************************************************************
979:                 /* Function:
980:                     void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
981:                                                          PORTS_CHANNEL channel,
982:                                                          PORTS_BIT_POS bitPos )
983:                 
984:                   Summary:
985:                     Disables the pull-up functionality for the selected pin.
986:                 	<p><b>Implementation:</b> Dynamic</p>
987:                 
988:                   Description:
989:                     This function disables the pull-up functionality for the selected pin.
990:                 
991:                   Remarks:
992:                     Not all features are available on all devices. Refer to the specific device
993:                     data sheet for availability.
994:                 */
995:                 
996:                 void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
997:                                                      PORTS_CHANNEL channel,
998:                                                      PORTS_BIT_POS bitPos )
999:                 {
1000:                    SYS_ASSERT(false, "This API is not supported on this device");
1001:                    return;
1002:                }
1003:                
1004:                
1005:                // *****************************************************************************
1006:                /* Function:
1007:                    void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
1008:                                                        PORTS_CHANNEL channel,
1009:                                                        PORTS_BIT_POS bitPos )
1010:                
1011:                  Summary:
1012:                    Enables the pull-down functionality for the selected pin.
1013:                	<p><b>Implementation:</b> Dynamic</p>
1014:                
1015:                  Description:
1016:                    This function enables the pull-down functionality for the selected pin.
1017:                
1018:                  Remarks:
1019:                    Not all features are available on all devices. Refer to the specific device
1020:                    data sheet for availability.
1021:                */
1022:                
1023:                void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
1024:                                                    PORTS_CHANNEL channel,
1025:                                                    PORTS_BIT_POS bitPos )
1026:                {
1027:                    SYS_ASSERT(false, "This API is not supported on this device");
1028:                    return;
1029:                }
1030:                
1031:                
1032:                // *****************************************************************************
1033:                /* Function:
1034:                    void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
1035:                                                         PORTS_CHANNEL channel,
1036:                                                         PORTS_BIT_POS bitPos )
1037:                
1038:                  Summary:
1039:                    Disables the pull-down functionality for the selected pin.
1040:                	<p><b>Implementation:</b> Dynamic</p>
1041:                
1042:                  Description:
1043:                    This function disables the pull-down functionality for the selected pin.
1044:                
1045:                  Remarks:
1046:                    Not all features are available on all devices. Refer to the specific device
1047:                    data sheet for availability.
1048:                */
1049:                
1050:                void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
1051:                                                     PORTS_CHANNEL channel,
1052:                                                     PORTS_BIT_POS bitPos )
1053:                {
1054:                    SYS_ASSERT(false, "This API is not supported on this device");
1055:                    return;
1056:                }
1057:                                                     
1058:                                                     
1059:                /******************************************************************************
1060:                  Function:
1061:                    void SYS_PORTS_InterruptEnable
1062:                    (
1063:                        PORTS_MODULE_ID index,
1064:                        PORTS_CHANNEL channel,
1065:                        PORTS_BIT_POS bitPos,
1066:                        PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1067:                    )
1068:                
1069:                  Summary:
1070:                    Enables the change notification interrupt for the selected port pin.
1071:                
1072:                  Description:
1073:                    This function enables the change notification interrupt of selected type
1074:                    for the selected port pin.
1075:                
1076:                  Remarks:
1077:                    None.
1078:                */
1079:                void SYS_PORTS_InterruptEnable
1080:                (
1081:                    PORTS_MODULE_ID index,
1082:                    PORTS_CHANNEL channel,
1083:                    PORTS_BIT_POS bitPos,
1084:                    PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1085:                )
1086:                {
00000000  00000000   NOP
1087:                    SYS_ASSERT(false, "This API is not supported on this device");
1088:                    return;
1089:                }
1090:                
1091:                
1092:                // *****************************************************************************
1093:                /* Function:
1094:                    void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1095:                							  PORTS_REMAP_INPUT_FUNCTION function,
1096:                							  PORTS_REMAP_INPUT_PIN      remapPin )
1097:                
1098:                  Summary:
1099:                    Input/Output (I/O) function remapping.
1100:                
1101:                  Description:
1102:                    This function controls the I/O function remapping.
1103:                
1104:                  Precondition:
1105:                    None.
1106:                */	
1107:                void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1108:                						   PORTS_REMAP_INPUT_FUNCTION function,
1109:                						   PORTS_REMAP_INPUT_PIN      remapPin )
1110:                {
1111:                #if defined(PLIB_PORTS_ExistsRemapInput)
1112:                    if(PLIB_PORTS_ExistsRemapInput(index))
1113:                    {
1114:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1115:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1116:                        PLIB_PORTS_RemapInput( index, function, remapPin);
1117:                    }
1118:                #endif
1119:                }
1120:                
1121:                // *****************************************************************************
1122:                /* Function:
1123:                    void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1124:                                                      PORTS_REMAP_OUTPUT_FUNCTION function,
1125:                                                      PORTS_REMAP_OUTPUT_PIN      remapPin )
1126:                
1127:                  Summary:
1128:                    Input/Output (I/O) function remapping.
1129:                
1130:                  Description:
1131:                    This function controls the I/O function remapping.
1132:                
1133:                  Precondition:
1134:                    None.
1135:                */
1136:                void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1137:                						    PORTS_REMAP_OUTPUT_FUNCTION function,
1138:                						    PORTS_REMAP_OUTPUT_PIN      remapPin )
1139:                {
1140:                #if defined(PLIB_PORTS_ExistsRemapOutput)
1141:                    if(PLIB_PORTS_ExistsRemapOutput(index))
1142:                    {
1143:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
1144:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
1145:                        PLIB_PORTS_RemapOutput( index, function, remapPin);
1146:                    }
1147:                #endif
1148:                }
1149:                
1150:                /*******************************************************************************
1151:                 End of File
1152:                */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon_pic32mz.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include <xc.h>
53:                  #include <cp0defs.h>
54:                  #include "sys_devcon_local.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  #include "peripheral/pcache/plib_pcache.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  // Section: SYS DEVCON Client Setup Routines
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  
76:                  
77:                  // *****************************************************************************
78:                  /* Function:
79:                      void SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
80:                  
81:                    Summary:
82:                      Configures the PFM wait states and prefetch (cache) module for maximum 
83:                      performance.
84:                  
85:                    Description:
86:                      This function configures the PFM wait states and prefetch (cache) module 
87:                      for maximum performance.
88:                  
89:                    Remarks:
90:                      None.
91:                  */
92:                  
93:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
94:                  {
9D009C70  27BDFFF8   ADDIU SP, SP, -8
9D009C74  AFBF0004   SW RA, 4(SP)
95:                      bool int_flag = false;
96:                      bool ecc;
97:                  
98:                      /* Set the PFM wait states based on the system clock and ECC setting */
99:                      #if defined(PLIB_PCACHE_ExistsWaitState)    
100:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
101:                     {
102:                         int ws; /* number of wait states */
103:                 
104:                         /* Is ECC enabled? */
105:                         /* TODO: replace register read with plib when available */
106:                         ecc = (((CFGCON & 0x00000030) >> 4) < 2) ? true : false;
9D009C78  3C02BF80   LUI V0, -16512
9D009C7C  8C420000   LW V0, 0(V0)
9D009C80  7C420900   EXT V0, V0, 4, 2
107:                         if (sysclk <= (ecc ? 60000000 : 74000000))
9D009C84  2C420002   SLTIU V0, V0, 2
9D009C88  5440002A   BNEL V0, ZERO, .LVL12, .LBB62
9D009C8C  3C020393   LUI V0, 915
9D009C90  0B402754   J .LBB63
9D009C94  3C020469   LUI V0, 1129
9D009D34  34428701   ORI V0, V0, -30975
9D009D38  0082102B   SLTU V0, A0, V0
9D009D3C  1440FFE0   BNE V0, ZERO, .LVL4, .LBB44, .LBB45
9D009D40  00003021   ADDU A2, ZERO, ZERO
9D009D50  24422681   ADDIU V0, V0, 9857
9D009D54  0082102B   SLTU V0, A0, V0
9D009D58  1440FFD9   BNE V0, ZERO, .LVL4, .LBB44, .LBB45
9D009D5C  00003021   ADDU A2, ZERO, ZERO
108:                             ws = 0;
109:                         else if (sysclk <= (ecc ? 120000000 : 140000000))
9D009C98  0044102B   SLTU V0, V0, A0
9D009C9C  10400008   BEQ V0, ZERO, .LVL4, .LBB44, .LBB45
9D009CA0  24060001   ADDIU A2, ZERO, 1
9D009D44  3C020727   LUI V0, 1831
9D009D48  0B402726   J 0x9D009C98
9D009D4C  24420E00   ADDIU V0, V0, 3584
9D009D60  3C020858   LUI V0, 2136
9D009D64  0B402726   J 0x9D009C98
9D009D68  24423B00   ADDIU V0, V0, 15104
110:                             ws = 1;
111:                         else if (sysclk <= 200000000)
9D009CA4  3C060BEB   LUI A2, 3051
9D009CA8  34C6C201   ORI A2, A2, -15871
9D009CAC  0086302B   SLTU A2, A0, A2
112:                             ws = 2;
9D009CB0  24020002   ADDIU V0, ZERO, 2
9D009CB4  24030004   ADDIU V1, ZERO, 4
9D009CB8  0066100A   MOVZ V0, V1, A2
9D009CBC  00403021   ADDU A2, V0, ZERO
113:                         else
114:                             ws = 4;
115:                 
116:                         /* Interrupts must be disabled when changing wait states */
117:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D009CD8  30A50001   ANDI A1, A1, 1
118:                 
119:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
120:                 
121:                         if (int_flag)
9D009CDC  10A00005   BEQ A1, ZERO, .LVL8, .LBE51, .LBE50, .LBE43, .LBB53, .LBB54
9D009CE0  00000000   NOP
122:                         {
123:                             PLIB_INT_Enable(INT_ID_0);
124:                             int_flag = false;
125:                         }
126:                     }
127:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
128:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
129:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D009D10  30820001   ANDI V0, A0, 1
130:                 
131:                     /* Enable Prefetch Cache Module */
132:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
133:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
134:                     {
135:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
136:                     }
137:                     #endif
138:                     
139:                     if (int_flag)
9D009D14  50400015   BEQL V0, ZERO, .LVL13
9D009D18  8FBF0004   LW RA, 4(SP)
140:                     {
141:                         PLIB_INT_Enable(INT_ID_0);
142:                     }
143:                 }
9D009D2C  0B40275B   J .LVL13
9D009D30  8FBF0004   LW RA, 4(SP)
9D009D6C  03E00008   JR RA
144:                 
145:                 
146:                 // *****************************************************************************
147:                 /* Function:
148:                     void SYS_DEVCON_CacheInit(SYS_CACHE_COHERENCY cacheCoherency)
149:                 
150:                   Summary:
151:                     Initializes the L1 cache. 
152:                 
153:                   Description:
154:                     Initializes both instruction and data caches. Invalidates all entries and
155:                     zeroes all tags. Sets coherency attribute for kseg0.
156:                 
157:                   Remarks:
158:                     Use with caution. Invalidates all cache lines without writing data
159:                     back to memory. Any dirty data in the cache will be lost.
160:                 */
161:                 
162:                 void SYS_DEVCON_CacheInit(SYS_CACHE_COHERENCY cacheCoherency)
163:                 {
00000000  00000000   NOP
164:                     _pic32_init_cache(cacheCoherency);
00000008  00000000   NOP
165:                 }
00000018  00000000   NOP
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     void SYS_DEVCON_CacheFlush(void)
171:                 
172:                   Summary:
173:                     Flushes the L1 cache. 
174:                 
175:                   Description:
176:                     Flushes both instruction and data caches. Invalidate entire instruction
177:                     cache; write back and invalidate entire data cache.
178:                 
179:                   Remarks:
180:                     Simplest way to sychnronize caches with memory, but not necessarily
181:                     the most efficient.
182:                 */
183:                 
184:                 void SYS_DEVCON_CacheFlush(void)
185:                 {
00000000  00000000   NOP
186:                     _pic32_flush_cache();
00000008  00000000   NOP
187:                 }
00000018  00000000   NOP
188:                 
189:                 
190:                 // *****************************************************************************
191:                 /* Function:
192:                     void SYS_DEVCON_DataCacheFlush(void)
193:                 
194:                   Summary:
195:                     Flushes the L1 data cache. 
196:                 
197:                   Description:
198:                     Write back and invalidate the entire data cache.
199:                 
200:                   Remarks:
201:                     None.
202:                 */
203:                 
204:                 void SYS_DEVCON_DataCacheFlush(void)
205:                 {
00000000  00000000   NOP
206:                     _pic32_flush_dcache();
00000008  00000000   NOP
207:                 }
00000018  00000000   NOP
208:                 
209:                 
210:                 // *****************************************************************************
211:                 /* Function:
212:                     void SYS_DEVCON_InstructionCacheFlush(void)
213:                 
214:                   Summary:
215:                     Flushes (invalidates) the L1 instruction cache.
216:                 
217:                   Description:
218:                     Invalidate entire instruction cache.
219:                 
220:                   Remarks:
221:                     None.
222:                 */
223:                 
224:                 void SYS_DEVCON_InstructionCacheFlush(void)
225:                 {
00000000  00000000   NOP
226:                     _pic32_flush_icache();
00000008  00000000   NOP
227:                 }
00000018  00000000   NOP
228:                 
229:                 
230:                 // *****************************************************************************
231:                 /* Function:
232:                     void SYS_DEVCON_CacheClean(uint32_t addr, size_t len)
233:                 
234:                   Summary:
235:                     Write back and invalidate an address range in either cache.
236:                 
237:                   Description:
238:                     Write back (data) and invalidate (data and address) an address range 
239:                     in either cache.
240:                 
241:                   Remarks:
242:                     None.
243:                 */
244:                 
245:                 void SYS_DEVCON_CacheClean(uint32_t addr, size_t len)
246:                 {
00000000  00000000   NOP
247:                     _pic32_clean_cache(addr, len);
00000008  00000000   NOP
248:                 }
00000018  00000000   NOP
249:                 
250:                 
251:                 // *****************************************************************************
252:                 /* Function:
253:                     void SYS_DEVCON_DataCacheClean(uint32_t addr, size_t len)
254:                 
255:                   Summary:
256:                     Write back and invalidate an address range in the data cache.
257:                 
258:                   Description:
259:                     Write back and invalidate an address range in the data cache.
260:                 
261:                   Remarks:
262:                     None.
263:                 */
264:                 
265:                 void SYS_DEVCON_DataCacheClean(uint32_t addr, size_t len)
266:                 {
00000000  00000000   NOP
267:                     _pic32_clean_dcache(addr, len);
00000008  00000000   NOP
268:                 }
00000018  00000000   NOP
269:                 
270:                 
271:                 // *****************************************************************************
272:                 /* Function:
273:                     void SYS_DEVCON_DataCacheInvalidate(uint32_t addr, size_t len)
274:                 
275:                   Summary:
276:                     Invalidate an address range in the data cache.
277:                 
278:                   Description:
279:                     Invalidate an address range in the data cache.
280:                 
281:                   Remarks:
282:                     None.
283:                 */
284:                 
285:                 void SYS_DEVCON_DataCacheInvalidate(uint32_t addr, size_t len)
286:                 {
00000000  00000000   NOP
287:                     _pic32_clean_dcache_nowrite(addr, len);
00000008  00000000   NOP
288:                 }
00000018  00000000   NOP
289:                 
290:                 
291:                 // *****************************************************************************
292:                 /* Function:
293:                     void SYS_DEVCON_InstructionCacheInvalidate(uint32_t addr, size_t len)
294:                 
295:                   Summary:
296:                     Invalidate an address range in the instruction cache.
297:                 
298:                   Description:
299:                     Invalidate an address range in the instruction cache.
300:                 
301:                   Remarks:
302:                     None.
303:                 */
304:                 
305:                 void SYS_DEVCON_InstructionCacheInvalidate(uint32_t addr, size_t len)
306:                 {
00000000  00000000   NOP
307:                     _pic32_clean_icache(addr, len);
00000008  00000000   NOP
308:                 }
00000018  00000000   NOP
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* Function:
313:                     void SYS_DEVCON_InstructionCacheLock(uint32_t addr, size_t len)
314:                 
315:                   Summary:
316:                     Fetch and lock a block of instructions in the instruction cache.
317:                 
318:                   Description:
319:                     Fetch and lock a block of instructions in the instruction cache.
320:                 
321:                   Remarks:
322:                     Global flush functions will invalidate and unlock any cache lines
323:                     locked with this function.
324:                 */
325:                 
326:                 void SYS_DEVCON_InstructionCacheLock(uint32_t addr, size_t len)
327:                 {
00000000  00000000   NOP
328:                     _pic32_lock_icache(addr, len);
00000008  00000000   NOP
329:                 }
00000018  00000000   NOP
330:                 
331:                 
332:                 // *****************************************************************************
333:                 /* Function:
334:                     void SYS_DEVCON_DataCacheLock(uint32_t addr, size_t len)
335:                 
336:                   Summary:
337:                     Fetch and lock a block of data in the data cache.
338:                 
339:                   Description:
340:                     Fetch and lock a block of data in the data cache.
341:                 
342:                   Remarks:
343:                     Global flush functions will invalidate and unlock any cache lines
344:                     locked with this function.
345:                 */
346:                 
347:                 void SYS_DEVCON_DataCacheLock(uint32_t addr, size_t len)
348:                 {
00000000  00000000   NOP
349:                     _pic32_lock_dcache(addr, len);
00000008  00000000   NOP
350:                 }
00000018  00000000   NOP
351:                 
352:                 
353:                 // *****************************************************************************
354:                 /* Function:
355:                     void SYS_DEVCON_CacheSync(uint32_t addr, size_t len)
356:                 
357:                   Summary:
358:                     Synchronize the instruction and data caches.
359:                 
360:                   Description:
361:                     Synchronize the instruction and data caches. Used when modifying
362:                     the instruction stream (breakpoints, self-modifying code, relocating
363:                     executable code to RAM). Flushes an address range from the data cache 
364:                     and invalidates that same range from the instruction cache.
365:                 
366:                   Remarks:
367:                     None.
368:                 */
369:                 
370:                 void SYS_DEVCON_CacheSync(uint32_t addr, size_t len)
371:                 {
00000000  00000000   NOP
372:                     _pic32_sync_icache(addr, len);
00000008  00000000   NOP
373:                 }
00000018  00000000   NOP
374:                 
375:                 
376:                 // *****************************************************************************
377:                 /* Function:
378:                     void SYS_DEVCON_CacheCoherencySet(SYS_CACHE_COHERENCY cacheCoherency)
379:                 
380:                   Summary:
381:                     Set the cache coherency attribute for kseg0.
382:                 
383:                   Description:
384:                     Set the cache coherency attribute for kseg0.
385:                 
386:                   Remarks:
387:                     Use with caution. May cause unpredictable behavior in a running
388:                     system.
389:                 */
390:                 
391:                 void SYS_DEVCON_CacheCoherencySet(SYS_CACHE_COHERENCY cacheCoherency)
392:                 {
00000000  00000000   NOP
393:                     uint32_t cp0;
394:                     /*LDRA_INSPECTED 496 S */ /*Deviation Reference: MH-4490*/
395:                     cp0 = _mfc0(16, 0);
00000008  00000000   NOP
396:                     cp0 &= ~0x07;
0000000C  00000000   NOP
397:                     cp0 |= cacheCoherency;
00000010  00000000   NOP
398:                     /*LDRA_INSPECTED 496 S */ /*Deviation Reference: MH-4491*/
399:                     _mtc0(16, 0, cp0);
00000014  00000000   NOP
400:                 }
0000001C  00000000   NOP
401:                 
402:                 
403:                 // *****************************************************************************
404:                 /* Function:
405:                     SYS_CACHE_COHERENCY SYS_DEVCON_CacheCoherencyGet(void)
406:                 
407:                   Summary:
408:                     Returns the current cache coherency attribute for kseg0.
409:                 
410:                   Description:
411:                     Returns the current cache coherency attribute for kseg0.
412:                 
413:                   Remarks:
414:                     None.
415:                 */
416:                 
417:                 SYS_CACHE_COHERENCY SYS_DEVCON_CacheCoherencyGet(void)
418:                 {
00000000  00000000   NOP
419:                     /*LDRA_INSPECTED 496 S */ /*Deviation Reference: MH-4492*/
420:                     return _mfc0(16, 0) & 0x03;
00000008  00000000   NOP
421:                 }
0000000C  00000000   NOP
422:                 
423:                 
424:                 // *****************************************************************************
425:                 /* Function:
426:                     size_t SYS_DEVCON_DataCacheAssociativityGet(void)
427:                 
428:                   Summary:
429:                     Returns the number of ways in the data cache.
430:                 
431:                   Description:
432:                     Returns the number of ways in the data cache.
433:                 
434:                   Remarks:
435:                     None.
436:                 */
437:                 
438:                 size_t SYS_DEVCON_DataCacheAssociativityGet(void)
439:                 {
00000000  00000000   NOP
440:                     return _pic32_get_dcache_associativity();
00000008  00000000   NOP
441:                 }
00000018  00000000   NOP
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* Function:
446:                     size_t SYS_DEVCON_InstructionCacheAssociativityGet(void)
447:                 
448:                   Summary:
449:                     Returns the number of ways in the instruction cache.
450:                 
451:                   Description:
452:                     Returns the number of ways in the instruction cache.
453:                 
454:                   Remarks:
455:                     None.
456:                 */
457:                 
458:                 size_t SYS_DEVCON_InstructionCacheAssociativityGet(void)
459:                 {
00000000  00000000   NOP
460:                     return _pic32_get_icache_associativity();
00000008  00000000   NOP
461:                 }
00000018  00000000   NOP
462:                 
463:                 
464:                 // *****************************************************************************
465:                 /* Function:
466:                     size_t SYS_DEVCON_DataCacheLineSizeGet(void)
467:                 
468:                   Summary:
469:                     Returns the data cache line size.
470:                 
471:                   Description:
472:                     Returns the data cache line size.
473:                 
474:                   Remarks:
475:                     None.
476:                 */
477:                 
478:                 size_t SYS_DEVCON_DataCacheLineSizeGet(void)
479:                 {
00000000  00000000   NOP
480:                     return _pic32_get_dcache_linesize();
00000008  00000000   NOP
481:                 }
00000018  00000000   NOP
482:                 
483:                 
484:                 // *****************************************************************************
485:                 /* Function:
486:                     size_t SYS_DEVCON_InstructionCacheLineSizeGet(void)
487:                 
488:                   Summary:
489:                     Returns the instruction cache line size.
490:                 
491:                   Description:
492:                     Returns the instruction cache line size.
493:                 
494:                   Remarks:
495:                     None.
496:                 */
497:                 
498:                 size_t SYS_DEVCON_InstructionCacheLineSizeGet(void)
499:                 {
00000000  00000000   NOP
500:                     return _pic32_get_icache_linesize();
00000008  00000000   NOP
501:                 }
00000018  00000000   NOP
502:                 
503:                 
504:                 // *****************************************************************************
505:                 /* Function:
506:                     size_t SYS_DEVCON_DataCacheLinesPerWayGet(void)
507:                 
508:                   Summary:
509:                     Returns the number of lines per way in the data cache.
510:                 
511:                   Description:
512:                     Returns the number of lines per way in the data cache.
513:                 
514:                   Remarks:
515:                     None.
516:                 */
517:                 
518:                 size_t SYS_DEVCON_DataCacheLinesPerWayGet(void)
519:                 {
00000000  00000000   NOP
520:                     return _pic32_get_dcache_lines_per_way();
00000008  00000000   NOP
521:                 }
00000018  00000000   NOP
522:                 
523:                 
524:                 // *****************************************************************************
525:                 /* Function:
526:                     size_t SYS_DEVCON_InstructionCacheLinesPerWayGet(void)
527:                 
528:                   Summary:
529:                     Returns the number of lines per way in the instruction cache.
530:                 
531:                   Description:
532:                     Returns the number of lines per way in the instruction cache.
533:                 
534:                   Remarks:
535:                     None.
536:                 */
537:                 
538:                 size_t SYS_DEVCON_InstructionCacheLinesPerWayGet(void)
539:                 {
00000000  00000000   NOP
540:                     return _pic32_get_icache_lines_per_way();
00000008  00000000   NOP
541:                 }
00000018  00000000   NOP
542:                 
543:                 
544:                 // *****************************************************************************
545:                 /* Function:
546:                     size_t SYS_DEVCON_DataCacheSizeGet(void)
547:                 
548:                   Summary:
549:                     Returns the total number of bytes in the data cache.
550:                 
551:                   Description:
552:                     Returns the total number of bytes in the data cache.
553:                 
554:                   Remarks:
555:                     None.
556:                 */
557:                 
558:                 size_t SYS_DEVCON_DataCacheSizeGet(void)
559:                 {
00000000  00000000   NOP
560:                     return _pic32_get_dcache_size();
00000008  00000000   NOP
561:                 }
00000018  00000000   NOP
562:                 
563:                 
564:                 // *****************************************************************************
565:                 /* Function:
566:                     size_t SYS_DEVCON_InstructionCacheSizeGet(void)
567:                 
568:                   Summary:
569:                     Returns the total number of bytes in the instruction cache.
570:                 
571:                   Description:
572:                     Returns the total number of bytes in the instruction cache.
573:                 
574:                   Remarks:
575:                     None.
576:                 */
577:                 
578:                 size_t SYS_DEVCON_InstructionCacheSizeGet(void)
579:                 {
00000000  00000000   NOP
580:                     return _pic32_get_icache_size();
00000008  00000000   NOP
581:                 }
00000018  00000000   NOP
582:                 
583:                 /*******************************************************************************
584:                  End of File
585:                 */
586:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on PIC32M Microchip microcontrollers. This file Implements 
16:                      the core interface routines for the Device Control system service.  While 
17:                      building the system service from source, ALWAYS include this file in the 
18:                      build for PIC32M devices.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "system/devcon/src/sys_devcon_local.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  #include "peripheral/devcon/plib_devcon.h"
56:                  #include "peripheral/osc/plib_osc.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D00CC04  24020002   ADDIU V0, ZERO, 2
9D00CC08  AF8280F8   SW V0, -32520(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D00CC0C  AF8080F4   SW ZERO, -32524(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
109:                 }
9D00CC10  03E00008   JR RA
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
138:                     sysDevconObj.status = SYS_STATUS_READY;
00000000  00000000   NOP
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
00000008  00000000   NOP
141:                 }
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
165:                 }
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
184:                     return sysDevconObj.status; 
185:                 }
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
00000000  00000000   NOP
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
213:                     }
214:                 }
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D00BDD0  27BDFFF8   ADDIU SP, SP, -8
9D00BDD4  AFBF0004   SW RA, 4(SP)
241:                     bool int_flag = false;
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00BE00  30620001   ANDI V0, V1, 1
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
246:                 
247:                     if (int_flag)
9D00BE04  10400006   BEQ V0, ZERO, 0x9D00BE20
9D00BE08  8FBF0004   LW RA, 4(SP)
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
250:                     }
251:                 }
9D00BE1C  8FBF0004   LW RA, 4(SP)
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D00C114  27BDFFF8   ADDIU SP, SP, -8
9D00C118  AFBF0004   SW RA, 4(SP)
272:                     bool int_flag = false;
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00C134  30420001   ANDI V0, V0, 1
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
277:                 
278:                     if (int_flag)
9D00C138  10400006   BEQ V0, ZERO, 0x9D00C154
9D00C13C  8FBF0004   LW RA, 4(SP)
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
281:                     }
282:                 }
9D00C150  8FBF0004   LW RA, 4(SP)
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
302:                 }
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
322:                 }
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
341:                     #if defined PLIB_DEVCON_ExistsTraceOutput
342:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
343:                         {
344:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
345:                         }
346:                     #endif
347:                 }
348:                 
349:                 
350:                 // *****************************************************************************
351:                 /* Function:
352:                     void SYS_DEVCON_TraceDisable( void )
353:                 
354:                   Summary:
355:                     Disables the Trace output port on the device.
356:                 
357:                   Description:
358:                     Disables the Trace output port on the device.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void SYS_DEVCON_TraceDisable( void )
365:                 {
366:                     #if defined PLIB_DEVCON_ExistsTraceOutput
367:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
368:                     {
369:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
370:                     }
371:                     #endif
372:                 }
373:                 
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
378:                 
379:                   Summary:
380:                     Puts the device in a low-power state.
381:                 
382:                   Description:
383:                     This function puts the device in a low-power state.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
390:                 {
00000000  00000000   NOP
391:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
0000000C  00000000   NOP
392:                 
393:                     switch (pwrMode)
394:                     {
395:                         case SYS_POWER_MODE_IDLE:
396:                             op = OSC_ON_WAIT_IDLE;
397:                             break;
398:                         case SYS_POWER_MODE_SLEEP:
399:                             op = OSC_ON_WAIT_SLEEP;
400:                             break;
401:                         default:
402:                             break;
403:                     }
404:                 
405:                     
406:                     #if defined PLIB_OSC_ExistsOnWaitAction
407:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
408:                     {
409:                         SYS_DEVCON_SystemUnlock();
00000010  00000000   NOP
410:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
411:                         SYS_DEVCON_SystemLock();
00000028  00000000   NOP
412:                     }
413:                     #endif
414:                     asm volatile ( "wait" );
00000030  00000000   NOP
415:                 }
00000034  00000000   NOP
416:                 
417:                 
418:                 /*******************************************************************************
419:                  End of File
420:                 */
421:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/system/clk/src/sys_clk_pic32mz.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D009F74  27BDFFE8   ADDIU SP, SP, -24
9D009F78  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D009F7C  0F402F74   JAL SYS_DEVCON_SystemUnlock
9D009F80  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_1);
95:                  
96:                      /* Enable Peripheral Bus 1 */
97:                      PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 3 );
98:                      PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 0 );
99:                  
100:                     /* Enable Peripheral Bus 2 */
101:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 1, 3 );
102:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 1 );
103:                     /* Enable Peripheral Bus 3 */
104:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 2, 3 );
105:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 2 );
106:                     /* Enable Peripheral Bus 4 */
107:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 3, 2 );
108:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 3 );
109:                     /* Enable Peripheral Bus 5 */
110:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 4, 8 );
111:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 4 );
112:                     /* Enable Peripheral Bus 7 */
113:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 6, 1 );
114:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 6 );
115:                     /* Enable Peripheral Bus 8 */
116:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 7, 3 );
117:                     PLIB_OSC_PBOutputClockEnable (OSC_ID_0, 7 );
118:                   
119:                  
120:                 
121:                     /* Disable REFCLKO1*/
122:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_1 );
123:                     /* Disable REFCLK1_OE*/
124:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_1 );
125:                     /* Disable REFCLKO2*/
126:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_2 );
127:                     /* Disable REFCLK2_OE*/
128:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_2 );
129:                     /* Disable REFCLKO3*/
130:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_3 );
131:                     /* Disable REFCLK3_OE*/
132:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_3 );
133:                     /* Disable REFCLKO4*/
134:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_4 );
135:                     /* Disable REFCLK4_OE*/
136:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_4 );
137:                 
138:                     SYS_DEVCON_SystemLock ( );
9D00A058  0F403045   JAL SYS_DEVCON_SystemLock
9D00A05C  00000000   NOP
139:                 }
9D00A060  8FBF0014   LW RA, 20(SP)
140:                 
141:                 //******************************************************************************
142:                 /* Function:
143:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
144:                 
145:                   Summary:
146:                     Gets the system clock frequency in Hertz.
147:                 
148:                   Description:
149:                     This function gets the System clock frequency in Hertz.
150:                 
151:                   Precondition:
152:                     None.
153:                 
154:                   Parameters:
155:                     None.
156:                 
157:                   Returns:
158:                     System clock frequency in Hertz.
159:                 
160:                   Example:
161:                     <code>
162:                     uint32_t sysClockHz;
163:                 
164:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
165:                     </code>
166:                 
167:                   Remarks:
168:                  */
169:                 
170:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
171:                 {
172:                     return SYS_CLK_FREQ;
173:                 }
9D00CC70  3C020BEB   LUI V0, 3051
174:                 
175:                 //******************************************************************************
176:                 /* Function:
177:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
178:                 
179:                   Summary:
180:                     Gets the selected clock peripheral bus frequency in Hertz.
181:                 
182:                   Description:
183:                     This function gets the selected peripheral bus clock frequency in Hertz.
184:                 
185:                   Precondition:
186:                     None.
187:                 
188:                   Parameters:
189:                 	peripheralBus - Reference clock bus selection. One of the possible value from
190:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
191:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
192:                 				the selection.
193:                 
194:                   Returns:
195:                     Clock frequency in Hertz.
196:                 
197:                   Example:
198:                     <code>
199:                     unsigned long peripheralClockHz;
200:                 
201:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
202:                     </code>
203:                 
204:                   Remarks:
205:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
206:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
207:                  */
208:                 
209:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
210:                 {
211:                        uint32_t freq = 0;
00000040  00000000   NOP
212:                 
213:                     switch (peripheralBus)
00000000  00000000   NOP
214:                     {
215:                         case CLK_BUS_PERIPHERAL_1:
216:                                 freq = SYS_CLK_BUS_PERIPHERAL_1;
0000006C  00000000   NOP
217:                             break;
218:                         case CLK_BUS_PERIPHERAL_2:
219:                                 freq = SYS_CLK_BUS_PERIPHERAL_2;
220:                             break;
221:                         case CLK_BUS_PERIPHERAL_3:
222:                                 freq = SYS_CLK_BUS_PERIPHERAL_3;
223:                             break;
224:                         case CLK_BUS_PERIPHERAL_4:
225:                                 freq = SYS_CLK_BUS_PERIPHERAL_4;
00000048  00000000   NOP
226:                             break;
0000004C  00000000   NOP
227:                         case CLK_BUS_PERIPHERAL_5:
228:                                 freq = SYS_CLK_BUS_PERIPHERAL_5;
00000054  00000000   NOP
229:                             break;
00000058  00000000   NOP
230:                         case CLK_BUS_PERIPHERAL_6:
231:                             break;
232:                         case CLK_BUS_PERIPHERAL_7:
233:                                 freq = SYS_CLK_BUS_PERIPHERAL_7;
00000060  00000000   NOP
234:                             break;
00000064  00000000   NOP
235:                         case CLK_BUS_PERIPHERAL_8:
236:                                 freq = SYS_CLK_BUS_PERIPHERAL_8;
237:                             break;
238:                         default:
239:                             break;
240:                     }
241:                     
242:                     return freq;
243:                 }
00000070  00000000   NOP
244:                 
245:                 
246:                 //******************************************************************************
247:                 /* Function:
248:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
249:                 
250:                   Summary:
251:                     Gets the selected Reference clock bus frequency in Hertz.
252:                 
253:                   Description:
254:                     This function gets frequency of the selected Reference clock bus in Hertz.
255:                 
256:                   Precondition:
257:                     None.
258:                 
259:                   Parameters:
260:                 	peripheralBus - Reference clock bus selection. One of the possible value from
261:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
262:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
263:                 				the selection.
264:                 
265:                   Returns:
266:                     Clock frequency in Hz.
267:                 
268:                   Example:
269:                     <code>
270:                     unsigned long sysClockOutputHz;
271:                 
272:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
273:                     </code>
274:                 
275:                   Remarks:
276:                     None.
277:                  */
278:                 
279:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
280:                 {
281:                        uint32_t freq = 0;
282:                 
283:                     switch (referenceBus)
284:                     {
285:                         case CLK_BUS_REFERENCE_1:
286:                             break;
287:                         case CLK_BUS_REFERENCE_2:
288:                             break;
289:                         case CLK_BUS_REFERENCE_3:
290:                             break;
291:                         case CLK_BUS_REFERENCE_4:
292:                             break;
293:                         case CLK_BUS_REFERENCE_5:
294:                             break;
295:                         default:
296:                             break;
297:                     }
298:                     
299:                     return freq;
300:                 }
00000000  00000000   NOP
301:                 
302:                 /******************************************************************************
303:                   Function:
304:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
305:                 
306:                   Summary:
307:                     Enables the secondary oscillator.
308:                 
309:                   Description:
310:                     This function enables the secondary oscillator.
311:                 
312:                   Remarks:
313:                     For more details refer sys_clk.h.
314:                 */
315:                 
316:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
317:                 {
00000014  00000000   NOP
318:                     /* Check for secondary oscillator status */
319:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
320:                     {    
321:                         /* Unlock and enable secondary oscillator */
322:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
323:                         
324:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
325:                         
326:                         SYS_DEVCON_SystemLock();
00000030  00000000   NOP
327:                     }
328:                 }
00000038  00000000   NOP
329:                 
330:                 /******************************************************************************
331:                   Function:
332:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
333:                 
334:                   Summary:
335:                     Disables the secondary oscillator.
336:                 
337:                   Description:
338:                     This function disables the secondary oscillator.
339:                 
340:                   Remarks:
341:                     For more details refer sys_clk.h.
342:                 */
343:                 
344:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
345:                 {
00000014  00000000   NOP
346:                     /* Check for secondary oscillator status */
347:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
348:                     {    
349:                         /* Unlock and disable secondary oscillator*/
350:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
351:                         
352:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
353:                         
354:                         SYS_DEVCON_SystemLock();
00000030  00000000   NOP
355:                     }
356:                 }
00000038  00000000   NOP
357:                 
358:                 /******************************************************************************
359:                   Function:
360:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
361:                 
362:                   Summary:
363:                     Identifies whether secondary oscillator is enabled or disabled.
364:                 
365:                   Description:
366:                     This function identifies whether the secondary oscillator is enabled or 
367:                     disabled.
368:                     
369:                   Remarks:
370:                     For more details refer sys_clk.h.
371:                 */
372:                 
373:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
374:                 {
375:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
376:                 }
00000008  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.   
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "driver/tmr/drv_tmr_static.h"
50:                  #include "driver/tmr/src/drv_tmr_variant_mapping.h"
51:                  
52:                  typedef struct
53:                  {
54:                      DRV_TMR_CALLBACK alarmFunc;  // For alarm registering
55:                      uint32_t alarmCount;    // For AlarmHasElapsed function
56:                      bool    alarmEnabled;   // For Enable/Disable function
57:                      bool    alarmPeriodic;      // Keep Alarm enabled or disable it
58:                      uintptr_t   alarmContext;   // For Alarm Callback
59:                      uint32_t    alarmPeriod;    // For Period Set/Get
60:                  } DRV_TMR_ALARM_OBJ;
61:                  
62:                  static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
63:                  {
64:                      bool clockSet = true;
65:                      /* Clock Source Selection */
66:                      if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
0000002C  00000000   NOP
67:                      {
68:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
69:                          {               
70:                              PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
71:                          }
72:                          else
73:                          {
74:                              /* If clock source feature doesn't exist for any specific timer module instance,
75:                              then by default internal peripheral clock is considered as timer source, so do nothing */ 
76:                          }
77:                      }
78:                      /* External Synchronous Clock Source Selection */
79:                      else if(!(clockSource & 0x10))
0000004C  00000000   NOP
80:                      {
81:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
82:                          {               
83:                              if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
84:                              {
85:                                  PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );                
86:                                  PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
87:                              }
88:                              /* If Synchronization feature doesn't exist for any specific timer module 
89:                              instance with external clock source then it is synchronous by default */
90:                              else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
91:                              {
92:                                  PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
93:                              }
94:                              else
95:                              {
96:                                  clockSet = false;
97:                              }  
98:                          }
99:                          else
100:                         {
101:                             clockSet = false;
102:                         }        
103:                     }
104:                     /* External Asynchronous Clock Source Selection */
105:                     else if(clockSource & 0x10)
106:                     {
107:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
108:                         {
109:                             PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );
110:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
111:                         }
112:                         else
113:                         {
114:                             clockSet = false;
115:                         }        
116:                     }
117:                     
118:                     return clockSet;
119:                 }
120:                 
121:                 // Prescaler selection
122:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
123:                 {
124:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
125:                     {
126:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
127:                         return true;
128:                     }
129:                     return false;
130:                 }
131:                 
132:                 
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 // Section: Instance 0 static driver data
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 
139:                 static bool                   DRV_TMR0_Running;
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Instance 0 static driver functions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 void DRV_TMR0_Initialize(void)
147:                 {   
148:                     /* Initialize Timer Instance0 */
149:                     /* Disable Timer */
150:                     PLIB_TMR_Stop(TMR_ID_1);
151:                     /* Select clock source */
152:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_1, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
153:                     /* Select prescalar value */
154:                     PLIB_TMR_PrescaleSelect(TMR_ID_1, TMR_PRESCALE_VALUE_64);
155:                     /* Enable 16 bit mode */
156:                     PLIB_TMR_Mode16BitEnable(TMR_ID_1);
157:                     /* Clear counter */ 
158:                     PLIB_TMR_Counter16BitClear(TMR_ID_1);
159:                     /*Set period */ 
160:                     PLIB_TMR_Period16BitSet(TMR_ID_1, 1250);
161:                     /* Setup Interrupt */   
162:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T1, INT_PRIORITY_LEVEL6);
163:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T1, INT_SUBPRIORITY_LEVEL3);          
164:                 }
165:                 
166:                 static void _DRV_TMR0_Resume(bool resume)
167:                 {
168:                     if (resume)
0000011C  00000000   NOP
169:                     {
170:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_1);
171:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_1);
172:                         PLIB_TMR_Start(TMR_ID_1);
173:                     }
174:                 }
175:                 
176:                 bool DRV_TMR0_Start(void)
177:                 {
178:                     /* Start Timer*/
179:                     _DRV_TMR0_Resume(true);
180:                     DRV_TMR0_Running = true;
9D00C650  24020001   ADDIU V0, ZERO, 1
9D00C654  A3828070   SB V0, -32656(GP)
181:                     
182:                     return true;
183:                 }
9D00C658  03E00008   JR RA
184:                 
185:                 static bool _DRV_TMR0_Suspend(void)
186:                 {
187:                     if (DRV_TMR0_Running)
00000000  00000000   NOP
188:                     {
189:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_1);
190:                         PLIB_TMR_Stop(TMR_ID_1);
191:                         return (true);
00000028  00000000   NOP
192:                     }
193:                     
194:                     return (false);
195:                 }
196:                 
197:                 void DRV_TMR0_Stop(void)
198:                 {
199:                     _DRV_TMR0_Suspend();
200:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_1);
201:                     DRV_TMR0_Running = false;
00000034  00000000   NOP
202:                 }
203:                 
204:                 DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void )
205:                 {
206:                     if (DRV_TMR0_Running)
00000000  00000000   NOP
207:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
208:                     else
209:                         return DRV_TMR_CLIENT_STATUS_READY;
210:                 }
00000004  00000000   NOP
211:                 
212:                 void DRV_TMR0_CounterValueSet(uint32_t value)
213:                 {
214:                     /* Set 16-bit counter value*/
215:                     PLIB_TMR_Counter16BitSet(TMR_ID_1, (uint16_t)value);
216:                 }
217:                 
218:                 uint32_t DRV_TMR0_CounterValueGet(void)
219:                 {
220:                     /* Get 16-bit counter value*/
221:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_1);
222:                 }
00000008  00000000   NOP
223:                 
224:                 void DRV_TMR0_CounterClear(void)
225:                 {
226:                     /* Clear 16-bit counter value*/
227:                     PLIB_TMR_Counter16BitClear(TMR_ID_1);
228:                 }
229:                 
230:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
231:                 (
232:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
233:                 )
234:                 {
235:                 	if(pDivRange)
00000000  00000000   NOP
236:                 	{
237:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
00000008  00000000   NOP
238:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
00000010  00000000   NOP
239:                 		pDivRange->dividerStep = 1;
00000018  00000000   NOP
240:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
0000001C  00000000   NOP
241:                 	}
242:                 	return DRV_TMR_OPERATION_MODE_NONE;
243:                 }
00000024  00000000   NOP
244:                 
245:                 uint32_t DRV_TMR0_CounterFrequencyGet(void)
246:                 {
00000000  00000000   NOP
247:                     uint32_t prescale, tmrBaseFreq;
248:                     
249:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
00000008  00000000   NOP
250:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_1);
251:                     return ( tmrBaseFreq / prescale );
252:                 }
00000054  00000000   NOP
253:                 
254:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void)
255:                 {
256:                     uint16_t prescale_value;
257:                     /* Call the PLIB directly */
258:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_1);
259:                     
260:                     switch(prescale_value)
261:                     {
262:                         case 1: return TMR_PRESCALE_VALUE_1;
00000020  00000000   NOP
263:                         case 2: return TMR_PRESCALE_VALUE_2;
264:                         case 4: return TMR_PRESCALE_VALUE_4;
265:                         case 8: return TMR_PRESCALE_VALUE_8;
266:                         case 16: return TMR_PRESCALE_VALUE_16;
267:                         case 32: return TMR_PRESCALE_VALUE_32;
268:                         case 64: return TMR_PRESCALE_VALUE_64;
00000030  00000000   NOP
269:                         case 256: return TMR_PRESCALE_VALUE_256;
270:                         default: return TMR_PRESCALE_VALUE_1;
271:                     }
272:                 }
00000038  00000000   NOP
273:                 
274:                 void DRV_TMR0_PeriodValueSet(uint32_t value)
275:                 {
276:                     /* Set 16-bit counter value*/
277:                     PLIB_TMR_Period16BitSet(TMR_ID_1, (uint16_t)value);
278:                 }
279:                 
280:                 uint32_t DRV_TMR0_PeriodValueGet(void)
281:                 {
282:                     /* Get 16-bit counter value*/
283:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_1);
284:                 }
00000008  00000000   NOP
285:                 
286:                 void DRV_TMR0_StopInIdleDisable(void)
287:                 {
288:                     PLIB_TMR_StopInIdleDisable(TMR_ID_1);
289:                 }
290:                 
291:                 void DRV_TMR0_StopInIdleEnable(void)
292:                 {
293:                     PLIB_TMR_StopInIdleDisable(TMR_ID_1);
294:                 }
295:                 
296:                 bool DRV_TMR0_ClockSet
297:                 (
298:                     DRV_TMR_CLK_SOURCES clockSource,
299:                     TMR_PRESCALE        preScale
300:                 )
301:                 {
302:                     bool success = false;
303:                     bool resume = _DRV_TMR0_Suspend();
304:                     
305:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_1, clockSource) &&
306:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_1, preScale))
307:                     {
308:                         success = true;
309:                     }
310:                     
311:                     _DRV_TMR0_Resume(resume);
312:                     return success;
313:                 }
00000148  00000000   NOP
314:                 
315:                  
316:                  
317:                 /*******************************************************************************
318:                  End of File
319:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_mapping.c
1:                   /*******************************************************************************
2:                     Timer Driver Interface Mapping Dynamic APIs to Static APIs           
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_mapping.h
9:                   
10:                    Summary:
11:                      This file allows maintaining a single set of APIs for all Timer transactions  
12:                      by making the type of implementation transparent to the application. In case
13:                      where static implementation of Timer driver is selected, this file maps the 
14:                      API functions to a particular driver instance-specific static implementation
15:                      function, eliminating unnecessary dynamic parameters. 
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/tmr/drv_tmr.h"
44:                  #include "driver/tmr/drv_tmr_static.h"
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Driver System Interface Function Definitions
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  // *****************************************************************************
53:                  /* Function:
54:                      SYS_MODULE_OBJ DRV_TMR_Initialize 
55:                      ( 
56:                          const SYS_MODULE_INDEX drvIndex,
57:                          const SYS_MODULE_INIT * const init 
58:                      )
59:                  
60:                    Summary:
61:                      Initializes the Timer driver.
62:                  
63:                    Description:
64:                      This function initializes the Timer driver, making it ready for clients to
65:                      open and use it.
66:                  
67:                    Remarks:
68:                      Refer to drv_tmr.h for usage information.
69:                  */
70:                  
71:                  SYS_MODULE_OBJ DRV_TMR_Initialize 
72:                  ( 
73:                      const SYS_MODULE_INDEX drvIndex,
74:                      const SYS_MODULE_INIT  * const init 
75:                  )
76:                  {
00000008  00000000   NOP
77:                  	SYS_MODULE_OBJ sysObj;
78:                  	
79:                  	switch (drvIndex)
00000000  00000000   NOP
80:                      {
81:                                  case DRV_TMR_INDEX_0:
82:                          {
83:                              DRV_TMR0_Initialize();
00000010  00000000   NOP
84:                  			sysObj = (SYS_MODULE_OBJ)DRV_TMR_INDEX_0;
85:                              break;
00000018  00000000   NOP
86:                          }
87:                          default:
88:                          {
89:                  			sysObj = SYS_MODULE_OBJ_INVALID;
00000020  00000000   NOP
90:                              break;
91:                          }
92:                      }
93:                  	return sysObj;
94:                  }
00000028  00000000   NOP
95:                  
96:                  // *****************************************************************************
97:                  /* Function:
98:                      void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
99:                  
100:                   Summary:
101:                     Deinitializes the specified instance of the Timer driver.
102:                 
103:                   Description:
104:                     Deinitializes the specified instance of the Timer driver, disabling
105:                     its operation (and any hardware). All internal data is invalidated.
106:                 
107:                   Remarks:
108:                     Refer to drv_tmr.h for usage information.
109:                 */
110:                 
111:                 void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
112:                 {
00000008  00000000   NOP
113:                 	switch (object)
00000000  00000000   NOP
114:                     {
115:                         case DRV_TMR_INDEX_0:
116:                         {
117:                             DRV_TMR0_DeInitialize();
118:                             break;
119:                         }
120:                         default:
121:                         {
122:                             break;
123:                         }
124:                     }
125:                 }
00000018  00000000   NOP
126:                 
127:                 // *****************************************************************************
128:                 /* Function:
129:                     SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
130:                 
131:                   Summary:
132:                     Provides the current status of the Timer driver.
133:                 
134:                   Description:
135:                     This function provides the current status of the Timer driver.
136:                 
137:                   Remarks:
138:                     Refer to drv_tmr.h for usage information.
139:                 */
140:                 
141:                 SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
142:                 {
143:                 	SYS_STATUS returnValue;
144:                 	
145:                 	switch (object)
146:                     {
147:                         case DRV_TMR_INDEX_0:
148:                         {
149:                             returnValue = DRV_TMR0_Status();
150:                             break;
151:                         }
152:                         default:
153:                         {
154:                             break;
155:                         }
156:                     }
157:                 	return returnValue;
158:                 }
159:                 
160:                 // *****************************************************************************
161:                 /* Function:
162:                     void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
163:                 
164:                   Summary:
165:                     Maintains the driver's state machine.
166:                 
167:                   Description:
168:                     This function is used to maintain the driver's internal state machine and
169:                     processes the timer events.
170:                 
171:                   Remarks:
172:                     Refer to drv_tmr.h for usage information.
173:                 */
174:                 
175:                 void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
176:                 {
177:                 	switch (object)
178:                     {
179:                         case DRV_TMR_INDEX_0:
180:                         {
181:                             DRV_TMR0_Tasks();
182:                             break;
183:                         }
184:                         default:
185:                         {
186:                             break;
187:                         }
188:                     }
189:                 }
190:                 
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 // Section: TMR Driver Client Functions
194:                 // *****************************************************************************
195:                 // *****************************************************************************
196:                 
197:                 // *****************************************************************************
198:                 /* Function:
199:                     DRV_HANDLE DRV_TMR_Open 
200:                     ( 
201:                         const SYS_MODULE_INDEX index,
202:                         const DRV_IO_INTENT    intent
203:                     )
204:                 
205:                   Summary:
206:                     Opens the specified Timer driver instance and returns a handle to it.
207:                   
208:                   Description:
209:                     This function opens the specified Timer driver instance and provides a
210:                     handle that must be provided to all other client-level operations to
211:                     identify the caller and the instance of the driver.  Timer driver does not
212:                     support multiple clients. If two tasks want to use the timer, one should
213:                     wait until the other one gets closed. 
214:                 
215:                   Remarks:
216:                     Refer to drv_tmr.h for usage information.
217:                 */
218:                 
219:                 DRV_HANDLE DRV_TMR_Open 
220:                 ( 
221:                     const SYS_MODULE_INDEX index, 
222:                     const DRV_IO_INTENT intent 
223:                 )
224:                 {
225:                     switch (index)
226:                     {
227:                         case DRV_TMR_INDEX_0:
228:                         {
229:                             return (DRV_HANDLE)DRV_TMR_INDEX_0;
230:                             break;
231:                         }
232:                         default:
233:                         {
234:                             break;
235:                         }
236:                     }
237:                     
238:                     return (DRV_HANDLE)NULL;
239:                 }
00000000  00000000   NOP
240:                 
241:                 // *****************************************************************************
242:                 /* Function:
243:                     void DRV_TMR_Close ( DRV_HANDLE handle )
244:                 
245:                   Summary:
246:                     Closes an opened instance of the Timer driver.
247:                 
248:                   Description:
249:                     This function closes an opened instance of the Timer driver, invalidating
250:                     the handle.
251:                   
252:                   Remarks:
253:                     Refer to drv_tmr.h for usage information.
254:                 */
255:                 
256:                 void DRV_TMR_Close ( DRV_HANDLE handle )
257:                 {
00000008  00000000   NOP
258:                     switch (handle)
00000000  00000000   NOP
259:                     {
260:                         case DRV_TMR_INDEX_0:
261:                         {
262:                             DRV_TMR0_Close();
263:                             break;
264:                         }
265:                         default:
266:                         {
267:                             break;
268:                         }
269:                     }
270:                 }
00000018  00000000   NOP
271:                 
272:                 // *****************************************************************************
273:                 /* Function:
274:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
275:                 
276:                   Summary:
277:                     Gets the status of the client operation.
278:                 
279:                   Description:
280:                     This function gets the status of the recently completed client level
281:                     operation.
282:                 
283:                   Remarks:
284:                     Refer to drv_tmr.h for usage information.
285:                 */
286:                 
287:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus 
288:                 ( DRV_HANDLE handle )
289:                 {
00000008  00000000   NOP
290:                     switch (handle)
00000000  00000000   NOP
291:                     {
292:                         case DRV_TMR_INDEX_0:
293:                         {
294:                             return DRV_TMR0_ClientStatus();
00000010  00000000   NOP
295:                             break;
296:                         }
297:                         default:
298:                         {
299:                             break;
300:                         }
301:                     }
302:                 
303:                     return DRV_TMR_CLIENT_STATUS_INVALID;
00000020  00000000   NOP
304:                 }
00000028  00000000   NOP
305:                 
306:                 // *****************************************************************************
307:                 // *****************************************************************************
308:                 // Section: TMR Driver Counter functions
309:                 // *****************************************************************************
310:                 // *****************************************************************************
311:                 
312:                 // *****************************************************************************
313:                 /* Function:
314:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
315:                 
316:                   Summary:
317:                     Updates the Timer's counter register.
318:                 
319:                   Description:
320:                     This function updates the Timer's value in the counter register.
321:                 
322:                   Remarks:
323:                     Refer to drv_tmr.h for usage information.
324:                 */
325:                 
326:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
327:                 {
00000008  00000000   NOP
328:                     switch (handle)
00000000  00000000   NOP
329:                     {
330:                         case DRV_TMR_INDEX_0:
331:                         {
332:                             DRV_TMR0_CounterValueSet(counterPeriod);
00000010  00000000   NOP
333:                             break;
334:                         }
335:                         default:
336:                         {
337:                             break;
338:                         }
339:                     }
340:                 }
00000018  00000000   NOP
341:                 
342:                 // *****************************************************************************
343:                 /* Function:
344:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
345:                 
346:                   Summary:
347:                     Reads the Timer's counter register.
348:                 
349:                   Description:
350:                     This function returns the Timer's value in the counter register.
351:                 
352:                   Remarks:
353:                     Refer to drv_tmr.h for usage information.
354:                 */
355:                 
356:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
357:                 {
00000008  00000000   NOP
358:                     switch (handle)
00000000  00000000   NOP
359:                     {
360:                         case DRV_TMR_INDEX_0:
361:                         {
362:                             return DRV_TMR0_CounterValueGet();
00000010  00000000   NOP
363:                             break;
364:                         }
365:                         default:
366:                         {
367:                             break;
368:                         }
369:                     }
370:                 
371:                     return 0;
00000020  00000000   NOP
372:                 }
00000028  00000000   NOP
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
377:                 
378:                   Summary:
379:                     Clears the Timer's counter register.
380:                 
381:                   Description:
382:                     This function clears the Timer's value in the counter register.
383:                 
384:                   Remarks:
385:                     Refer to drv_tmr.h for usage information.
386:                 */
387:                 
388:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
389:                 {
00000008  00000000   NOP
390:                     switch (handle)
00000000  00000000   NOP
391:                     {
392:                         case DRV_TMR_INDEX_0:
393:                         {
394:                             DRV_TMR0_CounterClear();
00000010  00000000   NOP
395:                             break;
396:                         }
397:                         default:
398:                         {
399:                             break;
400:                         }
401:                     }
402:                 }
00000018  00000000   NOP
403:                 
404:                 // *****************************************************************************
405:                 // *****************************************************************************
406:                 // Section: TMR Driver Alarm functions
407:                 // *****************************************************************************
408:                 // *****************************************************************************
409:                 
410:                 // *****************************************************************************
411:                 /* Function:
412:                     bool DRV_TMR_AlarmRegister 
413:                     ( 
414:                         DRV_HANDLE handle, 
415:                         uint32_t divider, 
416:                         bool isPeriodic, 
417:                         uintptr_t context, 
418:                         DRV_TMR_CALLBACK callBack 
419:                     )
420:                 
421:                   Summary:
422:                     Sets up an alarm.
423:                 
424:                   Description:
425:                     This function sets up an alarm, allowing the client to receive a callback
426:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
427:                     or periodic.  A periodic alarm will reload the timer and generate alarm
428:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
429:                     divider;
430:                 
431:                   Remarks:
432:                     Refer to drv_tmr.h for usage information.
433:                 */
434:                 
435:                 bool DRV_TMR_AlarmRegister 
436:                 (
437:                     DRV_HANDLE handle, 
438:                     uint32_t divider, 
439:                     bool isPeriodic, 
440:                     uintptr_t context, 
441:                     DRV_TMR_CALLBACK callBack 
442:                 )
443:                 {
444:                     switch (handle)
445:                     {
446:                         default:
447:                         {
448:                             break;
449:                         }
450:                     }
451:                 
452:                     return false;
453:                 }
454:                 
455:                 // *****************************************************************************
456:                 /* Function:
457:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
458:                 
459:                   Summary:
460:                     Disables an alarm signal.
461:                 
462:                   Description:
463:                     This function allows the client to disable an alarm generation.
464:                     Use DRV_TMR_AlarmEnable to re-enable.
465:                 
466:                   Remarks:
467:                     Refer to drv_tmr.h for usage information.
468:                 */
469:                 
470:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
471:                 {
472:                     switch (handle)
473:                     {
474:                         default:
475:                         {
476:                             break;
477:                         }
478:                     }
479:                 
480:                     return false;
481:                 }
482:                 
483:                 // *****************************************************************************
484:                 /* Function:
485:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
486:                 
487:                   Summary:
488:                     Re-enables an alarm signal.
489:                 
490:                   Description:
491:                     This function allows the client to re-enable an alarm after it has been
492:                     disabled by a DRV_TMR_AlarmDisable call.
493:                 
494:                   Remarks:
495:                     Refer to drv_tmr.h for usage information.
496:                 */
497:                 
498:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
499:                 {
500:                     switch (handle)
501:                     {
502:                         default:
503:                         {
504:                             break;
505:                         }
506:                     }
507:                 }
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
512:                 
513:                   Summary:
514:                     Updates the Timer's period.
515:                 
516:                   Description:
517:                     This function updates the Timer's period.
518:                 
519:                   Remarks:
520:                     Refer to drv_tmr.h for usage information.
521:                 */
522:                 
523:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
524:                 {
525:                     switch (handle)
526:                     {
527:                         default:
528:                         {
529:                             break;
530:                         }
531:                     }
532:                 }
533:                 
534:                 // *****************************************************************************
535:                 /* Function:
536:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
537:                 
538:                   Summary:
539:                     Provides the Timer's period.
540:                 
541:                   Description:
542:                     This function gets the Timer's period.
543:                 
544:                   Remarks:
545:                     Refer to drv_tmr.h for usage information.
546:                 */
547:                 
548:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
549:                 {
550:                     switch (handle)
551:                     {
552:                         default:
553:                         {
554:                             break;
555:                         }
556:                     }
557:                 
558:                     return 0;
559:                 }
560:                 
561:                 // *****************************************************************************
562:                 /* Function:
563:                     void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
564:                 
565:                   Summary:
566:                     Removes a previously set alarm.
567:                 
568:                   Description:
569:                     This function removes a previously set alarm.
570:                 
571:                   Remarks:
572:                     Refer to drv_tmr.h for usage information.
573:                 */
574:                 
575:                 void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
576:                 {
00000000  00000000   NOP
577:                     switch (handle)
578:                     {
579:                         default:
580:                         {
581:                             break;
582:                         }
583:                     }
584:                 }
585:                 
586:                 // *****************************************************************************
587:                 // *****************************************************************************
588:                 // Section: TMR Driver Operation Control functions
589:                 // *****************************************************************************
590:                 // *****************************************************************************
591:                 
592:                 // *****************************************************************************
593:                 /* Function:
594:                     bool DRV_TMR_Start ( DRV_HANDLE handle )
595:                 
596:                   Summary:
597:                     Starts the Timer counting.
598:                 
599:                   Description:
600:                     This function starts the Timer counting.
601:                 
602:                   Remarks:
603:                     Refer to drv_tmr.h for usage information.
604:                 */
605:                 
606:                 bool DRV_TMR_Start ( DRV_HANDLE handle )
607:                 {
00000008  00000000   NOP
608:                     switch (handle)
00000000  00000000   NOP
609:                     {
610:                         case DRV_TMR_INDEX_0:
611:                         {
612:                             return DRV_TMR0_Start();
00000010  00000000   NOP
613:                             break;
614:                         }
615:                         default:
616:                         {
617:                             break;
618:                         }
619:                     }
620:                 
621:                     return false;
00000020  00000000   NOP
622:                 }
00000028  00000000   NOP
623:                 
624:                 // *****************************************************************************
625:                 /* Function:
626:                     void DRV_TMR_Stop ( DRV_HANDLE handle )
627:                 
628:                   Summary:
629:                     Stops the Timer from counting.
630:                 
631:                   Description:
632:                     This function stops the running Timer from counting.
633:                 
634:                   Remarks:
635:                     Refer to drv_tmr.h for usage information.
636:                 */
637:                 
638:                 void DRV_TMR_Stop ( DRV_HANDLE handle )
639:                 {
00000008  00000000   NOP
640:                     switch (handle)
00000000  00000000   NOP
641:                     {
642:                         case DRV_TMR_INDEX_0:
643:                         {
644:                             DRV_TMR0_Stop();
00000010  00000000   NOP
645:                             break;
646:                         }
647:                         default:
648:                         {
649:                             break;
650:                         }
651:                     }
652:                 }
00000018  00000000   NOP
653:                 
654:                 // *****************************************************************************
655:                 /* Function:
656:                     uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
657:                 
658:                   Summary:
659:                     Provides the status of Timer's period elapse.
660:                 
661:                   Description:
662:                     This function returns the number of times Timer's period has elapsed since
663:                     last call to this API has made. On calling this API, the internally
664:                     maintained counter will be cleared and count will be started again from next
665:                     elapse.
666:                 
667:                   Remarks:
668:                     Refer to drv_tmr.h for usage information.
669:                 */
670:                 
671:                 uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
672:                 {
673:                     switch (handle)
674:                     {
675:                         default:
676:                         {
677:                             break;
678:                         }
679:                     }
680:                 
681:                     return 0;
682:                 }
683:                 
684:                 // *****************************************************************************
685:                 /* Function:
686:                     DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
687:                 
688:                   Summary:
689:                     This function gets the currently selected operation mode.
690:                 
691:                   Description:
692:                     This function gets the currently selected 16/32 bit operation mode.
693:                 
694:                   Remarks:
695:                     Refer to drv_tmr.h for usage information.
696:                 */
697:                 
698:                 DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
699:                 {
700:                     switch (handle)
701:                     {
702:                         case DRV_TMR_INDEX_0:
703:                         {
704:                             return DRV_TMR0_OperationModeGet();
705:                             break;
706:                         }
707:                         default:
708:                         {
709:                             break;
710:                         }
711:                     }
712:                 
713:                     return DRV_TMR_OPERATION_MODE_NONE;
714:                 }
00000000  00000000   NOP
715:                 
716:                 // *****************************************************************************
717:                 // *****************************************************************************
718:                 // Section: TMR Driver Miscellaneous information functions
719:                 // *****************************************************************************
720:                 // *****************************************************************************
721:                 
722:                 // *****************************************************************************
723:                 /* Function:
724:                     bool DRV_TMR_ClockSet 
725:                     ( 
726:                         DRV_HANDLE handle, 
727:                         DRV_TMR_CLK_SOURCES clockSource, 
728:                         TMR_PRESCALE  preScale 
729:                     )
730:                 
731:                   Summary:
732:                     Sets the timers clock by selecting the source and prescaler.
733:                 
734:                   Description:
735:                     This function sets the timers clock by selecting the source and prescaler.
736:                 
737:                   Remarks:
738:                     Refer to drv_tmr.h for usage information.
739:                 */
740:                 
741:                 bool DRV_TMR_ClockSet 
742:                 ( 
743:                     DRV_HANDLE handle, 
744:                     DRV_TMR_CLK_SOURCES clockSource, 
745:                     TMR_PRESCALE  preScale 
746:                 )
747:                 {
00000008  00000000   NOP
748:                     switch (handle)
00000000  00000000   NOP
749:                     {
750:                         case DRV_TMR_INDEX_0:
751:                         {
752:                             return DRV_TMR0_ClockSet(clockSource, preScale);
00000010  00000000   NOP
753:                             break;
754:                         }
755:                         default:
756:                         {
757:                             break;
758:                         }
759:                     }
760:                 
761:                     return false;
00000020  00000000   NOP
762:                 }
00000028  00000000   NOP
763:                 
764:                 // *****************************************************************************
765:                 /* Function:
766:                     TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
767:                 
768:                   Summary:
769:                     This function gets the currently selected prescaler.
770:                 
771:                   Description:
772:                     This function gets the currently selected prescaler.
773:                 
774:                   Remarks:
775:                     Refer to drv_tmr.h for usage information.
776:                 */
777:                 
778:                 TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
779:                 {
00000008  00000000   NOP
780:                     switch (handle)
00000000  00000000   NOP
781:                     {
782:                         case DRV_TMR_INDEX_0:
783:                         {
784:                             return DRV_TMR0_PrescalerGet();
00000010  00000000   NOP
785:                             break;
786:                         }
787:                         default:
788:                         {
789:                             break;
790:                         }
791:                     }
792:                 
793:                     return -1;
00000020  00000000   NOP
794:                 }
00000028  00000000   NOP
795:                 
796:                 // *****************************************************************************
797:                 /* Function:
798:                     bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
799:                 
800:                   Summary:
801:                     Enables the Gate mode.
802:                 
803:                   Description:
804:                     This function enables the Gated mode of Timer. User can measure the duration
805:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
806:                     will start on the raising edge of the external signal. It will keep counting
807:                     until the next falling edge. 
808:                 
809:                   Remarks:
810:                     Refer to drv_tmr.h for usage information.
811:                 */
812:                 
813:                 bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
814:                 {
815:                     switch (handle)
816:                     {
817:                         default:
818:                         {
819:                             break;
820:                         }
821:                     }
822:                 
823:                     return false;
824:                 }
825:                 
826:                 // *****************************************************************************
827:                 /* Function:
828:                     bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
829:                 
830:                   Summary:
831:                     Enables the Gate mode.
832:                 
833:                   Description:
834:                     This function enables the Gated mode of Timer. User can measure the duration
835:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
836:                     will start on the raising edge of the external signal. It will keep counting
837:                     until the next falling edge. 
838:                 
839:                   Remarks:
840:                     Refer to drv_tmr.h for usage information.
841:                 */
842:                 
843:                 bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
844:                 {
845:                     switch (handle)
846:                     {
847:                         default:
848:                         {
849:                             break;
850:                         }
851:                     }
852:                 
853:                     return false;
854:                 }
00000000  00000000   NOP
855:                 
856:                 // *****************************************************************************
857:                 /* Function:
858:                     uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
859:                 
860:                   Summary:
861:                     Provides the Timer input frequency.
862:                 
863:                   Description:
864:                     This function provides the Timer input frequency. Input frequency is the
865:                     clock to the Timer register and it is considering the prescaler divisor. 
866:                 
867:                   Remarks:
868:                     Refer to drv_tmr.h for usage information.
869:                 */
870:                 
871:                 uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
872:                 {
00000008  00000000   NOP
873:                     switch (handle)
00000000  00000000   NOP
874:                     {
875:                         case DRV_TMR_INDEX_0:
876:                         {
877:                             return DRV_TMR0_CounterFrequencyGet();
00000010  00000000   NOP
878:                             break;
879:                         }
880:                         default:
881:                         {
882:                             break;
883:                         }
884:                     }
885:                 
886:                     return 0;
00000020  00000000   NOP
887:                 }
00000028  00000000   NOP
888:                 
889:                 // *****************************************************************************
890:                 /* Function:
891:                     DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
892:                     ( 
893:                         DRV_HANDLE handle, 
894:                         DRV_TMR_DIVIDER_RANGE* pDivRange
895:                     )
896:                 
897:                   Summary:
898:                     Returns the Timer divider values.
899:                 
900:                   Description:
901:                     This function provides the Timer operating mode and divider range.
902:                 
903:                   Remarks:
904:                     Refer to drv_tmr.h for usage information.
905:                 */
906:                 
907:                 DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
908:                 ( 
909:                     DRV_HANDLE handle,
910:                     DRV_TMR_DIVIDER_RANGE* pDivRange
911:                 )
912:                 {
00000008  00000000   NOP
913:                     switch (handle)
00000000  00000000   NOP
914:                     {
915:                         case DRV_TMR_INDEX_0:
916:                         {
917:                             return DRV_TMR0_DividerRangeGet(pDivRange);
00000010  00000000   NOP
918:                             break;
919:                         }
920:                         default:
921:                         {
922:                             break;
923:                         }
924:                     }
925:                 
926:                     return DRV_TMR_OPERATION_MODE_NONE;
00000020  00000000   NOP
927:                 }
00000028  00000000   NOP
928:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/driver/tmr/drv_tmr_static.h
1:                   /*******************************************************************************
2:                     Timer Driver Interface Declarations for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_static.h
9:                   
10:                    Summary:
11:                      Timer driver interface declarations for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers. This file defines the interface
16:                      Declarations for the TMR driver.
17:                      
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                      
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
40:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _DRV_TMR_STATIC_H
51:                  #define _DRV_TMR_STATIC_H
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Headers
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  #include <stdint.h>
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "peripheral/tmr/plib_tmr.h"
60:                  #include "peripheral/int/plib_int.h"
61:                  
62:                  // maximum divider value for 32 bit operation mode
63:                  #define     DRV_TIMER_DIVIDER_MAX_32BIT     0xffffffff
64:                  
65:                  // minimum divider value for 32 bit operation mode
66:                  #define     DRV_TIMER_DIVIDER_MIN_32BIT     0x2
67:                  
68:                  // maximum divider value for 16 bit operation mode
69:                  #define     DRV_TIMER_DIVIDER_MAX_16BIT     0x10000
70:                  
71:                  // minimum divider value for 16 bit operation mode
72:                  #define     DRV_TIMER_DIVIDER_MIN_16BIT     0x2
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: Interface Headers for Instance 0 for the static driver
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  void DRV_TMR0_Initialize(void);
82:                  bool DRV_TMR0_Start(void);
83:                  void DRV_TMR0_Stop(void);
84:                  static inline void DRV_TMR0_DeInitialize(void)
85:                  {
86:                  	DRV_TMR0_Stop();
87:                  }
88:                  static inline SYS_STATUS DRV_TMR0_Status(void)
89:                  {
90:                  	/* Return the status as ready always */
91:                      return SYS_STATUS_READY; 
92:                  }
93:                  static inline void DRV_TMR0_Open(void) {}
94:                  DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void );
95:                  static inline DRV_TMR_OPERATION_MODE DRV_TMR0_OperationModeGet(void)
96:                  {
97:                      return DRV_TMR_OPERATION_MODE_16_BIT;
98:                  }
99:                  static inline void DRV_TMR0_Close(void) 
100:                 {
101:                     DRV_TMR0_Stop();
00000010  00000000   NOP
102:                 }
103:                 bool DRV_TMR0_ClockSet
104:                 (
105:                     DRV_TMR_CLK_SOURCES clockSource, 
106:                     TMR_PRESCALE  prescale 
107:                 );
108:                 void DRV_TMR0_CounterValueSet(uint32_t value);
109:                 uint32_t DRV_TMR0_CounterValueGet(void);
110:                 void DRV_TMR0_CounterClear(void);
111:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void);
112:                 void DRV_TMR0_PeriodValueSet(uint32_t value);
113:                 uint32_t DRV_TMR0_PeriodValueGet(void);
114:                 void DRV_TMR0_StopInIdleDisable(void);
115:                 void DRV_TMR0_StopInIdleEnable(void);
116:                 static inline void DRV_TMR0_Tasks(void) {}
117:                 uint32_t DRV_TMR0_CounterFrequencyGet(void);
118:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
119:                 (
120:                     DRV_TMR_DIVIDER_RANGE * pDivRange
121:                 );
122:                 #endif // #ifndef _DRV_TMR_STATIC_H
123:                 
124:                 /*******************************************************************************
125:                  End of File
126:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/driver/can/src/drv_can_static.c
1:                   /*******************************************************************************
2:                     CAN Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_can_static.c
9:                   
10:                    Summary:
11:                      CAN driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The CAN device driver provides a simple interface to manage the CAN
15:                      modules on Microchip microcontrollers.
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                      Static single-open interfaces also eliminate the need for the open handle.
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
38:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Header Includes
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "driver/can/drv_can.h"
54:                  
55:                  
56:                  static CAN_TX_MSG_BUFFER  *drv_Message0;
57:                  static CAN_TX_MSG_BUFFER __attribute__((coherent, aligned(16))) can_message_buffer0[5*2*16];
58:                  
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Instance 0 static driver functions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  void DRV_CAN0_Initialize(void)
66:                  {
67:                  
68:                      /* Switch the CAN module ON */
69:                      PLIB_CAN_Enable(CAN_ID_1);
70:                  
71:                      /* Switch the CAN module to Configuration mode. Wait until the switch is complete */
72:                      PLIB_CAN_OperationModeSelect(CAN_ID_1, CAN_CONFIGURATION_MODE);
73:                      while(PLIB_CAN_OperationModeGet(CAN_ID_1) != CAN_CONFIGURATION_MODE);
9D004974  24030004   ADDIU V1, ZERO, 4
9D004980  1443FFFD   BNE V0, V1, .LBB273
9D004984  3C02BF88   LUI V0, -16504
74:                  
75:                      PLIB_CAN_PhaseSegment2LengthFreelyProgrammableEnable(CAN_ID_1);
76:                  
77:                      //Set the Baud rate to 500 kbps
78:                      PLIB_CAN_PropagationTimeSegmentSet(CAN_ID_1, 8-1);
79:                      PLIB_CAN_PhaseSegment1LengthSet(CAN_ID_1, 8-1);
80:                      PLIB_CAN_PhaseSegment2LengthSet(CAN_ID_1, 8-1);
81:                      PLIB_CAN_SyncJumpWidthSet(CAN_ID_1, 1-1);
82:                      PLIB_CAN_BaudRatePrescaleSet(CAN_ID_1, 0); // set to 1 higher then ECAN tool
83:                  
84:                  
85:                      /* Assign the buffer area to the CAN module.
86:                        In this case assign enough memory for 2
87:                        channels, each with 8 message buffers.*/
88:                      PLIB_CAN_MemoryBufferAssign(CAN_ID_1, can_message_buffer0);
89:                  
90:                      /* Configure CAN_ID_1 Channel for CAN_TX_RTR_DISABLED operation. Allocate 32 message buffer, and assign low medium priority for transmissions. */
91:                      PLIB_CAN_ChannelForTransmitSet(CAN_ID_1, CAN_CHANNEL0, 32, CAN_TX_RTR_DISABLED, CAN_LOW_MEDIUM_PRIORITY);
92:                      /* Configure CAN_ID_1 Channel for CAN_RX_FULL_RECEIVE operation. Allocate 32 message buffer, and assign low medium priority for transmissions. */
93:                      PLIB_CAN_ChannelForReceiveSet(CAN_ID_1, CAN_CHANNEL1, 32, CAN_RX_FULL_RECEIVE);
94:                      PLIB_CAN_FilterToChannelLink(CAN_ID_1, CAN_FILTER0, CAN_FILTER_MASK0, CAN_CHANNEL1);
95:                      PLIB_CAN_ChannelEventEnable(CAN_ID_1, CAN_CHANNEL1, CAN_RX_CHANNEL_NOT_EMPTY);
96:                      /* Configure CAN_ID_1 Channel for CAN_TX_RTR_DISABLED operation. Allocate 32 message buffer, and assign low medium priority for transmissions. */
97:                      PLIB_CAN_ChannelForTransmitSet(CAN_ID_1, CAN_CHANNEL2, 32, CAN_TX_RTR_DISABLED, CAN_LOW_MEDIUM_PRIORITY);
98:                      /* Configure CAN_ID_1 Channel for CAN_RX_FULL_RECEIVE operation. Allocate 32 message buffer, and assign low medium priority for transmissions. */
99:                      PLIB_CAN_ChannelForReceiveSet(CAN_ID_1, CAN_CHANNEL3, 32, CAN_RX_FULL_RECEIVE);
100:                     PLIB_CAN_FilterToChannelLink(CAN_ID_1, CAN_FILTER1, CAN_FILTER_MASK1, CAN_CHANNEL3);
101:                     PLIB_CAN_ChannelEventEnable(CAN_ID_1, CAN_CHANNEL3, CAN_RX_CHANNEL_NOT_EMPTY);
102:                     /* Configure CAN_ID_1 Channel for CAN_RX_FULL_RECEIVE operation. Allocate 32 message buffer, and assign low medium priority for transmissions. */
103:                     PLIB_CAN_ChannelForReceiveSet(CAN_ID_1, CAN_CHANNEL4, 32, CAN_RX_FULL_RECEIVE);
104:                     PLIB_CAN_FilterToChannelLink(CAN_ID_1, CAN_FILTER2, CAN_FILTER_MASK2, CAN_CHANNEL4);
105:                     PLIB_CAN_ChannelEventEnable(CAN_ID_1, CAN_CHANNEL4, CAN_RX_CHANNEL_NOT_EMPTY);
106:                     PLIB_CAN_FilterConfigure(CAN_ID_1, CAN_FILTER0, 0x5F0, CAN_SID);
107:                     PLIB_CAN_FilterEnable(CAN_ID_1, CAN_FILTER0);
108:                     PLIB_CAN_FilterConfigure(CAN_ID_1, CAN_FILTER1, 0x144, CAN_SID);
109:                     PLIB_CAN_FilterEnable(CAN_ID_1, CAN_FILTER1);
110:                     PLIB_CAN_FilterConfigure(CAN_ID_1, CAN_FILTER2, 0x7c0, CAN_SID);
111:                     PLIB_CAN_FilterEnable(CAN_ID_1, CAN_FILTER2);
112:                 
113:                     PLIB_CAN_FilterMaskConfigure(CAN_ID_1, CAN_FILTER_MASK0, 0x7F0, CAN_SID, CAN_FILTER_MASK_IDE_TYPE);
114:                     PLIB_CAN_FilterMaskConfigure(CAN_ID_1, CAN_FILTER_MASK1, 0xFF0, CAN_SID, CAN_FILTER_MASK_IDE_TYPE);
115:                     PLIB_CAN_FilterMaskConfigure(CAN_ID_1, CAN_FILTER_MASK2, 0xFE0, CAN_SID, CAN_FILTER_MASK_IDE_TYPE);
116:                 
117:                     /* Switch the CAN module to Normal mode. Wait until the switch is complete */
118:                     PLIB_CAN_OperationModeSelect(CAN_ID_1, CAN_NORMAL_MODE);
119:                     while(PLIB_CAN_OperationModeGet(CAN_ID_1) != CAN_NORMAL_MODE);
9D004B70  1440FFFD   BNE V0, ZERO, 0x9D004B68
9D004B74  3C02BF88   LUI V0, -16504
120:                 
121:                     PLIB_CAN_ModuleEventEnable(CAN_ID_1 , 0);
122:                 
123:                 
124:                 
125:                 
126:                     /* Setup CAN_ID_1 Interrupt */
127:                     PLIB_INT_SourceEnable(INT_ID_0,INT_SOURCE_CAN_1);
128:                     PLIB_INT_VectorPrioritySet(INT_ID_0,INT_VECTOR_CAN1, INT_PRIORITY_LEVEL6);
129:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0,INT_VECTOR_CAN1, INT_SUBPRIORITY_LEVEL0);
130:                 }
131:                 
132:                 void DRV_CAN0_Deinitialize(void)
133:                 {
134:                 
135:                     /* Switch the CAN module to Disable mode. Wait until the switch is complete */
136:                     PLIB_CAN_OperationModeSelect(CAN_ID_1, CAN_DISABLE_MODE);
137:                     while(PLIB_CAN_OperationModeGet(CAN_ID_1) != CAN_DISABLE_MODE);
00000018  00000000   NOP
00000024  00000000   NOP
138:                 
139:                 }
0000002C  00000000   NOP
140:                 
141:                 void DRV_CAN0_Open(void)
142:                 {
143:                    /* Switch the CAN module ON */
144:                     PLIB_CAN_Enable(CAN_ID_1);
145:                 }
146:                 
147:                 void DRV_CAN0_Close(void)
148:                 {
149:                    /* Switch the CAN module OFF */
150:                     PLIB_CAN_Disable(CAN_ID_1);
151:                 }
152:                 
153:                 bool DRV_CAN0_ChannelMessageTransmit(CAN_CHANNEL channelNum, int address, uint8_t DLC, uint8_t* message)
154:                 {
155:                 
156:                     int count = 0;
9D009C24  00001021   ADDU V0, ZERO, ZERO
157:                     if ( (PLIB_CAN_ChannelEventGet(CAN_ID_1, channelNum) & CAN_TX_CHANNEL_NOT_FULL) == CAN_TX_CHANNEL_NOT_FULL)
9D009B70  30630400   ANDI V1, V1, 1024
9D009B74  1060003C   BEQ V1, ZERO, .LVL69
9D009B78  00001021   ADDU V0, ZERO, ZERO
158:                     {
159:                         //drv_Message0 = (CAN_TX_MSG_BUFFER *) &can_message_buffer0[channelNum];
160:                         drv_Message0 = PLIB_CAN_TransmitBufferGet(CAN_ID_1, channelNum);
161:                 
162:                         /* Check the address whether it falls under SID or EID,
163:                          * SID max limit is 0x7FF, so anything beyond that is EID */
164:                         if(address > 0x7FF)
9D009BAC  28A30800   SLTI V1, A1, 2048
9D009BB0  1460000B   BNE V1, ZERO, .LVL58
9D009BB4  AF82806C   SW V0, -32660(GP)
165:                         {
166:                             drv_Message0->msgSID.sid     = (address>>18);
9D009BB8  00054483   SRA T0, A1, 18
9D009BBC  8C430000   LW V1, 0(V0)
9D009BC0  7D035004   INS V1, T0, 0, 11
9D009BC4  AC430000   SW V1, 0(V0)
167:                             drv_Message0->msgEID.eid     = (0x3FFFF)&(address);
9D009BC8  8C430004   LW V1, 4(V0)
9D009BCC  7CA3DA84   INS V1, A1, 10, 18
168:                             drv_Message0->msgEID.ide     = 1;
9D009BD0  24050001   ADDIU A1, ZERO, 1
9D009BD4  7CA3E704   INS V1, A1, 28, 1
9D009BD8  0B4026FF   J .LVL59
9D009BDC  AC430004   SW V1, 4(V0)
169:                         }
170:                         else
171:                         {
172:                             drv_Message0->msgSID.sid     = address;
9D009BE0  8C430000   LW V1, 0(V0)
9D009BE4  7CA35004   INS V1, A1, 0, 11
9D009BE8  AC430000   SW V1, 0(V0)
173:                             drv_Message0->msgEID.eid     = 0;
9D009BEC  8C430004   LW V1, 4(V0)
174:                             drv_Message0->msgEID.ide     = 0;
9D009BF0  7C03DA84   INS V1, ZERO, 10, 18
9D009BF4  7C03E704   INS V1, ZERO, 28, 1
9D009BF8  AC430004   SW V1, 4(V0)
9D009BFC  00C04021   ADDU T0, A2, ZERO
9D009C00  2CC60009   SLTIU A2, A2, 9
9D009C04  50C00001   BEQL A2, ZERO, .LVL61
9D009C08  24080008   ADDIU T0, ZERO, 8
9D009C0C  310800FF   ANDI T0, T0, 255
175:                         }
176:                         if (DLC > 8)
177:                         {
178:                             DLC = 8;
179:                         }
180:                 
181:                         drv_Message0->msgEID.data_length_code     = DLC;
9D009C10  8F86806C   LW A2, -32660(GP)
9D009C14  8CC20004   LW V0, 4(A2)
9D009C18  7D021804   INS V0, T0, 0, 4
182:                         while(count < DLC)
9D009C1C  1900000A   BLEZ T0, .LVL66, .LBB403, .LBB404, .LBB405
9D009C20  ACC20004   SW V0, 4(A2)
9D009C3C  0048182A   SLT V1, V0, T0
9D009C40  5460FFFA   BNEL V1, ZERO, 0x9D009C2C
9D009C44  24420001   ADDIU V0, V0, 1
183:                         {
184:                             drv_Message0->data[count++] = *message++;
9D009C28  24420001   ADDIU V0, V0, 1
9D009C2C  24E70001   ADDIU A3, A3, 1
9D009C30  90E5FFFF   LBU A1, -1(A3)
9D009C34  00C21821   ADDU V1, A2, V0
9D009C38  A0650007   SB A1, 7(V1)
185:                         }
186:                 
187:                         //Update CAN module and then transmit data on the bus;
188:                        PLIB_CAN_ChannelUpdate(CAN_ID_1, channelNum);
189:                        PLIB_CAN_TransmitChannelFlush(CAN_ID_1, channelNum);
190:                         return(true);
9D009C64  24020001   ADDIU V0, ZERO, 1
191:                     }
192:                     return (false);
193:                 }
9D009C68  03E00008   JR RA
194:                 
195:                 bool DRV_CAN0_ChannelMessageReceive(CAN_CHANNEL channelNum, int address, uint8_t DLC, uint8_t* message)
196:                 {
197:                     int EchoDLC = 0;
198:                     CAN_RX_MSG_BUFFER *RxMessage;
199:                     uint32_t tempAddress;
200:                     bool readStatus;
201:                     CAN_CHANNEL_EVENT ChannelEvent;
202:                 
203:                     /* Get the channel RX status */
204:                     ChannelEvent = PLIB_CAN_ChannelEventGet( CAN_ID_1 , channelNum );
205:                 
206:                     /* Check if there is a message available to read. */
207:                     if( (ChannelEvent & CAN_RX_CHANNEL_NOT_EMPTY) == CAN_RX_CHANNEL_NOT_EMPTY )
00000010  00000000   NOP
208:                     {
209:                         /* There is a message available in the Channel FIFO. */
210:                 
211:                         /* Get a pointer to RX message buffer */
212:                         RxMessage = (CAN_RX_MSG_BUFFER *)PLIB_CAN_ReceivedMessageGet(CAN_ID_1, channelNum);
213:                 
214:                         /* Process the message fields */
215:                 
216:                         /* Check if it's a extended message type */
217:                         if(RxMessage->msgEID.ide)
0000004C  00000000   NOP
218:                         {
219:                             tempAddress = (RxMessage->msgSID.sid << 18);
0000005C  00000000   NOP
220:                             tempAddress |= ((0x3FFFF)&(RxMessage->msgEID.eid));
00000064  00000000   NOP
221:                         }
222:                         else
223:                         {
224:                             tempAddress = RxMessage->msgSID.sid;
00000074  00000000   NOP
225:                         }
226:                 
227:                 
228:                         if (RxMessage->msgEID.data_length_code > 0)
00000078  00000000   NOP
229:                         {
230:                 
231:                             if(tempAddress == address)
00000088  00000000   NOP
232:                             {
233:                                 while(EchoDLC < RxMessage->msgEID.data_length_code)
000000A8  00000000   NOP
234:                                 {
235:                                      *message++ = RxMessage->data[EchoDLC++];
00000094  00000000   NOP
236:                                 }
237:                             }
238:                         }
239:                 
240:                         /* Message processing is done, update the message buffer pointer. */
241:                         PLIB_CAN_ChannelUpdate(CAN_ID_1, channelNum);
242:                 
243:                         /* Message is processed successfully, so return true */
244:                         readStatus = true;
000000D0  00000000   NOP
245:                     }
246:                     else
247:                     {
248:                         /* There is no message to read ,so return false */
249:                         readStatus = false;
250:                     }
251:                 
252:                     return readStatus;
253:                 }
000000D4  00000000   NOP
254:                 
255:                 /*******************************************************************************
256:                  End of File
257:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/system_config/default/framework/driver/can/src/drv_can_mapping.c
1:                   /*******************************************************************************
2:                     CAN Driver Dynamic to Static mapping
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_can_mapping.c
9:                   
10:                    Summary:
11:                      Source code for the CAN driver dynamic APIs to static API mapping.
12:                  
13:                    Description:
14:                      This file contains code that maps dynamic APIs to static whenever
15:                      the static mode of the driver is selected..
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  SYS_MODULE_OBJ DRV_CAN_Initialize(const SYS_MODULE_INDEX index,
59:                          const SYS_MODULE_INIT * const init)
60:                  {
00000008  00000000   NOP
61:                      SYS_MODULE_OBJ returnValue;
62:                  
63:                      switch(index)
00000000  00000000   NOP
64:                      {
65:                          case DRV_CAN_INDEX_0:
66:                          {
67:                              returnValue = DRV_CAN_INDEX_0;
68:                              DRV_CAN0_Initialize();
00000010  00000000   NOP
69:                              break;
00000018  00000000   NOP
70:                          }
71:                          default:
72:                          {
73:                              returnValue = SYS_MODULE_OBJ_INVALID;
00000020  00000000   NOP
74:                              break;
75:                          }
76:                      }
77:                  
78:                      return returnValue;
79:                  }
00000028  00000000   NOP
80:                  
81:                  
82:                  
83:                  void DRV_CAN_Deinitialize(SYS_MODULE_OBJ object)
84:                  {
00000008  00000000   NOP
85:                      switch(object)
00000000  00000000   NOP
86:                      {
87:                          case DRV_CAN_INDEX_0:
88:                          {
89:                              DRV_CAN0_Deinitialize();
00000010  00000000   NOP
90:                              break;
91:                          }
92:                          default:
93:                          {
94:                              break;
95:                          }
96:                      }
97:                  }
00000018  00000000   NOP
98:                  
99:                  
100:                 
101:                 /* client interface */
102:                 DRV_HANDLE DRV_CAN_Open(const SYS_MODULE_INDEX index,
103:                         const DRV_IO_INTENT ioIntent)
104:                 {
00000008  00000000   NOP
105:                     DRV_HANDLE returnValue;
106:                 
107:                     switch(index)
00000000  00000000   NOP
108:                     {
109:                         case DRV_CAN_INDEX_0:
110:                         {
111:                             returnValue = DRV_CAN_INDEX_0;
112:                             DRV_CAN0_Open();
00000010  00000000   NOP
113:                             break;
00000018  00000000   NOP
114:                         }
115:                         default:
116:                         {
117:                             returnValue = DRV_HANDLE_INVALID;
00000020  00000000   NOP
118:                             break;
119:                         }
120:                     }
121:                 
122:                     return returnValue;
123:                 }
00000028  00000000   NOP
124:                 
125:                 
126:                 
127:                 void DRV_CAN_Close(const DRV_HANDLE handle)
128:                 {
00000008  00000000   NOP
129:                     switch(handle)
00000000  00000000   NOP
130:                     {
131:                         case DRV_CAN_INDEX_0:
132:                         {
133:                             DRV_CAN0_Close();
00000010  00000000   NOP
134:                             break;
135:                         }
136:                         default:
137:                         {
138:                             break;
139:                         }
140:                     }
141:                 }
00000018  00000000   NOP
142:                 
143:                 
144:                 
145:                 bool DRV_CAN_ChannelMessageTransmit(const DRV_HANDLE handle,
146:                         CAN_CHANNEL channelNum, int address, uint8_t DLC, uint8_t* message)
147:                 {
00000008  00000000   NOP
148:                     bool returnValue = false;
00000028  00000000   NOP
149:                 
150:                     switch(handle)
00000000  00000000   NOP
151:                     {
152:                         case DRV_CAN_INDEX_0:
153:                         {
154:                             returnValue = DRV_CAN0_ChannelMessageTransmit(channelNum, address,
00000010  00000000   NOP
155:                                     DLC, message);
156:                             break;
00000020  00000000   NOP
157:                         }
158:                         default:
159:                         {
160:                             break;
161:                         }
162:                     }
163:                 
164:                     return returnValue;
165:                 }
00000030  00000000   NOP
166:                 
167:                 
168:                 
169:                 bool DRV_CAN_ChannelMessageReceive(const DRV_HANDLE handle,
170:                         CAN_CHANNEL channelNum, int address, uint8_t DLC, uint8_t* message)
171:                 {
00000008  00000000   NOP
172:                     bool returnValue = false;
00000028  00000000   NOP
173:                 
174:                     switch(handle)
00000000  00000000   NOP
175:                     {
176:                         case DRV_CAN_INDEX_0:
177:                         {
178:                             returnValue = DRV_CAN0_ChannelMessageReceive(channelNum, address,
00000010  00000000   NOP
179:                                     DLC, message);
180:                             break;
00000020  00000000   NOP
181:                         }
182:                         default:
183:                         {
184:                             break;
185:                         }
186:                     }
187:                 
188:                     return returnValue;
189:                 }
00000030  00000000   NOP
190:                 
191:                 
192:                 
193:                 /*******************************************************************************
194:                  End of File
195:                 */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/rockdetection.c  --
1:                   #include "RockDetection.h"
2:                   #include "FastTransfer.h"
3:                   
4:                   /* [06][85][sender][receiver][msg length] [4] [lower byte] [upper byte] .... [CRC]*/
5:                   
6:                   #define MAX_NUM_OBJSCT 5
7:                   void getRockLocations()
8:                   {
9:                       int rockCount = PozyxFT.ReceivedData[4];
00000000  00000000   NOP
10:                      
11:                      int i;
12:                      for(i = 5;i < 5+rockCount*2;i+=2)
00000008  00000000   NOP
13:                      {
14:                         // addRock(PozyxFT.ReceivedData[i],PozyxFT.ReceivedData[i+1]);
15:                      }
16:                      
17:                  }
18:                  
19:                  
20:                  
21:                  
22:                  
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/pozyx.c  ----------
1:                   #include "Pozyx.h"
2:                   #include "FastTransfer.h"
3:                   #include <math.h>
4:                   #include <stdint.h>
5:                   
6:                   point_t WaypointStart = {0, 0};
7:                   
8:                   void InitPozyx() {
9D00BED8  27BDFFD8   ADDIU SP, SP, -40
9D00BEDC  AFBF0024   SW RA, 36(SP)
9:                       InitFastTransferModule(&PozyxFT, External_UART, MY_ADDRESS, Send_put, Buffer_Get, Buffer_Size, Buffer_Peek);
9D00BEE0  3C029D01   LUI V0, -25343
9D00BEE4  2442C4CC   ADDIU V0, V0, -15156
9D00BEE8  AFA20010   SW V0, 16(SP)
9D00BEEC  3C029D01   LUI V0, -25343
9D00BEF0  2442CC8C   ADDIU V0, V0, -13172
9D00BEF4  AFA20014   SW V0, 20(SP)
9D00BEF8  3C029D01   LUI V0, -25343
9D00BEFC  2442CC40   ADDIU V0, V0, -13248
9D00BF00  AFA20018   SW V0, 24(SP)
9D00BF04  3C048000   LUI A0, -32768
9D00BF08  248448DC   ADDIU A0, A0, 18652
9D00BF0C  24050002   ADDIU A1, ZERO, 2
9D00BF10  24060005   ADDIU A2, ZERO, 5
9D00BF14  3C079D01   LUI A3, -25343
9D00BF18  0F402DD9   JAL InitFastTransferModule
9D00BF1C  24E7BC6C   ADDIU A3, A3, -17300
10:                  }
9D00BF20  8FBF0024   LW RA, 36(SP)
11:                  void receivePozyx()
12:                  {
9D00CA84  27BDFFE8   ADDIU SP, SP, -24
9D00CA88  AFBF0014   SW RA, 20(SP)
13:                      receiveData(&PozyxFT);
9D00CA8C  3C048000   LUI A0, -32768
9D00CA90  0F4011AE   JAL receiveData
9D00CA94  248448DC   ADDIU A0, A0, 18652
14:                  }
9D00CA98  8FBF0014   LW RA, 20(SP)
15:                  point_t getHeadingWaypoint() {
00000000  00000000   NOP
16:                      return WaypointStart;
00000004  00000000   NOP
17:                  }
00000010  00000000   NOP
18:                  
19:                  point_t getLocation() {
00000000  00000000   NOP
20:                       // returning the pozyx data but first converting the data to cm scale
21:                      return (point_t) {(int16_t) (PozyxFT.ReceivedData[X] / 10), (int16_t) (PozyxFT.ReceivedData[Y] / 10)};
00000004  00000000   NOP
22:                  }
00000050  00000000   NOP
23:                  double getPozyxHeading() {
24:                  #ifdef USE_POZYX_HEADING 
25:                  //    if (PozyxFT.ReceivedData[Heading] > 180)
26:                  //        return ((double) PozyxFT.ReceivedData[Heading]) - 360;
27:                  //    else
28:                          return (double) PozyxFT.ReceivedData[Heading];
9D00CBF0  3C028000   LUI V0, -32768
9D00CBF4  844248EA   LH V0, 18666(V0)
29:                  #else
30:                      CalculateHeading(WaypointStart, getLocation());
31:                  #endif
32:                      }
9D00CBF8  44820800   MTC1 V0, F1
33:                  void setHeadingWaypoint(point_t _point) {
00000000  00000000   NOP
34:                      WaypointStart = _point;
00000008  00000000   NOP
35:                  }
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/pid.c  ------------
1:                   #include "PID.h"
2:                   
3:                   /******************************************************************
4:                   Declare all internal variables and methods that will only be called 
5:                   and used internally
6:                   ******************************************************************/
7:                   
8:                   
9:                   
10:                  void INIT_PID(PID_Struct_t *_this,float target, float kp, float ki, float kd)
11:                  {
00000000  00000000   NOP
12:                      _this->_target=target;
00000010  00000000   NOP
13:                      _this->_kp=kp;
00000014  00000000   NOP
14:                      _this->_ki=ki;
00000018  00000000   NOP
15:                      _this->_kd=kd;	
0000001C  00000000   NOP
16:                      _this->_past=millis();
00000020  00000000   NOP
17:                      _this->_prevError=0;
0000002C  00000000   NOP
18:                  }
00000030  00000000   NOP
19:                  
20:                  //External method
21:                  void setPropotionality(PID_Struct_t *_this, float kp, float ki, float kd)
22:                  {
23:                  	_this->_kp=kp;
00000000  00000000   NOP
24:                  	_this->_ki=ki;
00000004  00000000   NOP
25:                  	_this->_kd=kd;
00000008  00000000   NOP
26:                  }
27:                  float returnTarget(PID_Struct_t *_this)
28:                  {
29:                  	return _this->_target;
30:                  }
31:                  
32:                  void clearIntegral(PID_Struct_t *_this)
33:                  {
34:                       _this->_integral=0;
35:                  }
36:                  void updateTarget(PID_Struct_t *_this, float target)
37:                  {
38:                      _this->_target=target;
39:                  }
40:                  float readDerivative(PID_Struct_t *_this)
41:                  {
42:                  	return _this->_derivative;	
43:                  }
44:                  float readError(PID_Struct_t *_this)
45:                  {
46:                  	return _this->_error;
47:                  } 
48:                  float readIntegral(PID_Struct_t *_this)
49:                   {
50:                   	return _this->_integral;
51:                   }
52:                  
53:                  float readOutput(PID_Struct_t *_this)
54:                   { 	
55:                   	return _this->_output;
56:                   }
57:                   void clearSystem(PID_Struct_t *_this)
58:                   {
00000000  00000000   NOP
59:                   	_this->_error=0;
00000010  00000000   NOP
60:                   	_this->_prevError=0;
00000014  00000000   NOP
61:                   	_this->_derivative=0;
00000018  00000000   NOP
62:                   	_this->_integral=0;
0000001C  00000000   NOP
63:                   	_this->_output=0;
64:                   	_this->_past=millis(); 	
00000020  00000000   NOP
65:                   }
0000002C  00000000   NOP
66:                  //External method
67:                  int updateOutput(PID_Struct_t *_this, float sample)
68:                  {
00000000  00000000   NOP
69:                  	//update dt in seconds
70:                  	_this->_now=millis();
00000014  00000000   NOP
71:                  	_this->_dt=(_this->_now-_this->_past);
00000020  00000000   NOP
72:                  	_this->_past=_this->_now;
00000034  00000000   NOP
73:                  	
74:                  	//update error and dError
75:                  
76:                  	_this->_error = _this->_target - sample;	
00000038  00000000   NOP
77:                  	_this->_dError = _this->_error - _this->_prevError;
00000044  00000000   NOP
78:                      if(_this->_dt != 0)
0000004C  00000000   NOP
79:                      {
80:                          _this->_derivative = _this->_dError/_this->_dt;
0000005C  00000000   NOP
81:                  
82:                      }
83:                  	_this->_integral += _this->_error;  //*_dt;
00000064  00000000   NOP
84:                  	_this->_output=0;
00000070  00000000   NOP
85:                  	if(_this->_kp!=0)
00000074  00000000   NOP
86:                      {
87:                          _this->_output+=(_this->_error * _this->_kp);
00000088  00000000   NOP
88:                      }
89:                      if(_this->_kd != 0)
00000090  00000000   NOP
90:                      {    
91:                          _this->_output += (_this->_derivative * _this->_kd);
000000A4  00000000   NOP
92:                      }
93:                      if(_this->_ki != 0)
000000B4  00000000   NOP
94:                      {
95:                          _this->_output += (_this->_integral * _this->_ki);
000000C8  00000000   NOP
96:                      } 
97:                  
98:                      _this->_prevError = _this->_error;
000000D4  00000000   NOP
99:                      return _this->_output;
000000D8  00000000   NOP
100:                 }
000000DC  00000000   NOP
101:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/pathfollowing.c  --
1:                   #include "Map.h"
2:                   #include "Definitions.h"
3:                   
4:                   void InitializePathPlanning()
5:                   {
9D00CB00  27BDFFE8   ADDIU SP, SP, -24
9D00CB04  AFBF0014   SW RA, 20(SP)
6:                       ClearWorld();
9D00CB08  0F40326B   JAL ClearWorld
9D00CB0C  00000000   NOP
7:                       //generateObstacleBoarder(0);
8:                   }
9D00CB10  8FBF0014   LW RA, 20(SP)
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/motorhandler.c  ---
1:                   #include "motorHandler.h"
2:                   
3:                   
4:                   
5:                   void InitMotor(Motor_t* motor, char address, char statusBit,char mob, int maxRPM, int maxCurrent, LimitSwitch_t limitSwitch, bool brushless)
6:                   {
00000000  00000000   NOP
7:                       motor->ID = address;
0000002C  00000000   NOP
8:                   	motor->Status = statusBit;
00000030  00000000   NOP
9:                   	motor->MOB = mob;
00000034  00000000   NOP
10:                  	motor->MAX_RPM = maxRPM;
00000038  00000000   NOP
11:                  	motor->MAX_CURRENT = maxCurrent;
0000003C  00000000   NOP
12:                  	motor->LimitSwitch = limitSwitch;
00000040  00000000   NOP
13:                  	motor->isBrushless = brushless;
00000058  00000000   NOP
14:                      motor->Position = 0;
0000005C  00000000   NOP
15:                      
16:                      
17:                      sendMotorPacket(address,CLEAR_ERRORS);
00000060  00000000   NOP
18:                      sendMotorPacket(address,POWER_DISABLE);
00000078  00000000   NOP
19:                      if(brushless)
0000008C  00000000   NOP
20:                      {
21:                          sendMotorPacket(address,SET_FEEDBACK_ENCODER);
00000094  00000000   NOP
22:                      }else{
23:                          sendMotorPacket(address,SET_FEEDBACK_EMF);
000000E8  00000000   NOP
24:                      }
25:                      sendMotorPacket(address,SET_SVEL_FEEDBACK_ENCODER);
000000A4  00000000   NOP
000000F8  00000000   NOP
26:                      sendMotorPacket(address,SET_FEEDBACK_RESOLUTION);
000000B8  00000000   NOP
0000010C  00000000   NOP
27:                      if(brushless)
28:                      {
29:                          sendMotorPacket(address,SET_MOTOR_BRUSHLESS);
000000CC  00000000   NOP
30:                      }else{
31:                          sendMotorPacket(address, SET_MOTOR_BRUSHED);
00000120  00000000   NOP
32:                      }
33:                      sendMotorPacket(address,SSI_ENCODER_POSITION_RESET);
00000134  00000000   NOP
34:                      sendMotorPacket(address,SET_POLES);
00000148  00000000   NOP
35:                      // Limit Switches
36:                      sendMotorPacket(address,POSITIVE_LIMIT_SWITCH, motor->LimitSwitch.Pos);
0000015C  00000000   NOP
37:                      sendMotorPacket(address,POSITIVE_LIMIT_SWITCH, motor->LimitSwitch.Pos);
00000170  00000000   NOP
38:                      // Max Currents
39:                      sendMotorPacket(address,CURRENT_LIMIT_POS,maxCurrent);
00000184  00000000   NOP
40:                      sendMotorPacket(address,CURRENT_LIMIT_NEG,maxCurrent);
00000198  00000000   NOP
41:                      // Max RPMs
42:                      sendMotorPacket(address,VELOCITY_LIMIT_POS,maxRPM);
000001AC  00000000   NOP
43:                      sendMotorPacket(address,VELOCITY_LIMIT_NEG,maxRPM);
000001C0  00000000   NOP
44:                      // Direction of rotation
45:                      sendMotorPacket(address,MOTOR_POLARITY);
000001D4  00000000   NOP
46:                      // Enable Motor
47:                      sendMotorPacket(address,POWER_ENABLE);
000001E8  00000000   NOP
48:                      
49:                      
50:                  }
000001FC  00000000   NOP
51:                  
52:                  
53:                  //*******************************************************
54:                  //------------------------Setters------------------------
55:                  //*******************************************************
56:                  void setMotorControlMode(Motor_t *motor, unsigned char mode)
57:                  {
00000000  00000000   NOP
58:                  	switch(mode)
00000010  00000000   NOP
59:                  	{
60:                  		case Velocity:
61:                  		{
62:                              sendMotorPacket(motor->ID, MODE_VEL);
0000002C  00000000   NOP
63:                              // Setting acceleration and deceleration values
64:                              sendMotorPacket(motor->ID, VEL_ACC,(motor->isBrushless ? ACCEL_CONST: ACCEL_CONST_BRUSH));
00000040  00000000   NOP
65:                              sendMotorPacket(motor->ID, VEL_DEC,(motor->isBrushless ? ACCEL_CONST: ACCEL_CONST_BRUSH));
00000058  00000000   NOP
66:                  			break;
0000006C  00000000   NOP
67:                  		}
68:                  		case Position:
69:                  		{
70:                              sendMotorPacket(motor->ID, MODE_POS);
00000074  00000000   NOP
71:                              sendMotorPacket(motor->ID, POSITION_WINDOW);
00000084  00000000   NOP
72:                              sendMotorPacket(motor->ID, ZERO_VELOCITY);
00000098  00000000   NOP
73:                              sendMotorPacket(motor->ID, RESET_POSITION);
000000AC  00000000   NOP
74:                  			break;
75:                  		}
76:                  	}
77:                  }
00000024  00000000   NOP
000000C0  00000000   NOP
78:                  //void setMotorPos(Motor_t *motor, int pos)
79:                  //{
80:                  //
81:                  //
82:                  //}
83:                  void setMotorVel(Motor_t* motor, int Vel)
84:                  {
00000000  00000000   NOP
85:                  	if (Vel > motor->MAX_RPM)
00000008  00000000   NOP
86:                  	{
87:                  		Vel = motor->MAX_RPM;
88:                  	}
89:                  	if(Vel < -(motor->MAX_RPM))
00000018  00000000   NOP
90:                  	{
91:                  		Vel = -(motor->MAX_RPM);
92:                  	}
93:                      sendMotorPacket(motor->ID, DESIRED_VELOCITY, Vel);
00000020  00000000   NOP
94:                  	
95:                  }
00000038  00000000   NOP
96:                  
97:                  void setMotorCounts(Motor_t* motor, long counts)
98:                  {
00000000  00000000   NOP
99:                  	sendMotorPacket(motor->ID, MOTOR_COUNTS,counts);
0000000C  00000000   NOP
100:                 }
0000001C  00000000   NOP
101:                 
102:                 void SetMotorLimit(Motor_t *motor)
103:                 {
00000000  00000000   NOP
104:                     sendMotorPacket(motor->ID,POSITIVE_LIMIT_SWITCH, motor->LimitSwitch.Pos);	 //activates digital input 0 as positive limit switch high active
00000010  00000000   NOP
105:                     sendMotorPacket(motor->ID,POSITIVE_LIMIT_SWITCH, motor->LimitSwitch.Pos);	 //activates digital input 1 as negative limit switch high active
00000024  00000000   NOP
106:                 
107:                 	//SDO_packet HomeLimit = {motor->ID, 0x3056, 0x00, 0x132}; //activates digital input 2 as home limit switch high active
108:                 	//SDO_packet Home_Method = {BUCKETMOTORID, 0x37B2, 0x00, 2}; //homes by turning CW to positive limit, should be what we want.
109:                 }
00000038  00000000   NOP
110:                 
111:                 void storeMotorPosition(Motor_t * motor, long pos)
112:                 {
113:                     motor->Position = pos;
00000000  00000000   NOP
114:                 }
115:                 
116:                 //*********************************************************************************
117:                 //------------------------------------<Getters>------------------------------------
118:                 //*********************************************************************************
119:                 
120:                 //TODO: MAKE A CAN RECEIVE FUNCTION
121:                 /*
122:                 long getMotorPos(Motor_t *motor)
123:                 {
124:                 	char temp[8];
125:                 	SDO_packet ReadPosition ={motor->ID, 0x396A, 0x00, 0x00};// {RIGHTMOTORID, 0x396A, 0x00, 0x00};
126:                 
127:                 	if(ReadandVerify(ReadPosition, &motor->Motor_Buffer, motor->Status, temp))
128:                 	{
129:                 		long result = ArrayToLong(temp);
130:                 		return (result/4); //returns encoder counts
131:                 	}
132:                 	else
133:                 	{
134:                 		return 0;
135:                 	}
136:                 }
137:                 char getMotorVoltage(Motor_t *motor)
138:                 {
139:                 	char temp[8];
140:                 	SDO_packet ReadVoltage = {motor->ID, MOTOR_VOLTAGE};
141:                 
142:                 	if(ReadandVerify(ReadVoltage, &motor->Motor_Buffer, motor->Status, temp))
143:                 	{
144:                 		long result = ArrayToLong(temp);
145:                 		return (result/1000 +1); //get voltage in mV from controller, add 1v to compensate for suspected diode drop to input.
146:                 	}
147:                 	else
148:                 	{
149:                 		return 0;
150:                 	}
151:                 }
152:                 char getMotorTemp(Motor_t *motor)
153:                 {
154:                 	char temp[8];
155:                 	SDO_packet ReadTemperature = {motor->ID, MOTOR_TEMPERATURE};
156:                 
157:                 	if(ReadandVerify(ReadTemperature, &motor->Motor_Buffer, motor->Status, temp))
158:                 	{
159:                 		long result = ArrayToLong(temp);
160:                 		return result/10;
161:                 	}
162:                 	else
163:                 	{
164:                 		return 0;
165:                 	}
166:                 }
167:                 bool getMotorPosReached(Motor_t *motor)
168:                 {
169:                 	char temp[8];
170:                 	SDO_packet ReadPositionReached ={motor->ID, 0x3002, 0x00, 0x00};// {RIGHTMOTORID, 0x396A, 0x00, 0x00};
171:                 
172:                 	if(ReadandVerify(ReadPositionReached, &motor->Motor_Buffer, motor->Status, temp))
173:                 	{
174:                 		//long result = ArrayToLong(temp);
175:                 		return (temp[4]&0x10); //returns position Reached
176:                 	}
177:                 	else
178:                 	{
179:                 		return 0;
180:                 	}
181:                 }
182:                 //bool getMotorStatus(Motor_t *motor)
183:                 //{
184:                 //
185:                 //}
186:                 
187:                 
188:                 char getMotorDigital(Motor_t *motor)
189:                 {
190:                 	char temp[8];
191:                 	SDO_packet ReadPort0 = {motor->ID, 0x3120, 0x00, 0x00};
192:                 
193:                 	ReadandVerify(ReadPort0, &motor->Motor_Buffer, motor->Status, temp);
194:                 	long result = ArrayToLong(temp);
195:                 	return result;
196:                 }
197:                 */
1:                   #include "Motor.h"
2:                   #include "MotorDefinitions.h"
3:                   #include "CAN_Handler/CAN.h"
4:                   void initMotors()
5:                   {
00000000  00000000   NOP
6:                   	//WARNING!!! - Why is limit switch have 3 ints and we are passing only 2?
7:                   	//WARNING!!! - Why is limit switch have 3 ints and we are passing only 2?
8:                   	//WARNING!!! - Why is limit switch have 3 ints and we are passing only 2?
9:                   	#ifndef DISABLE_LEFT_MOTOR
10:                  
11:                  	//LeftMotor = (Motor_t){LEFTMOTORID,LEFTMOTOR_STATUS,LEFTMOTOR_MOB,MAXRPM,MAXCURRENTBG65,ACCEL_CONST,TRUE,(LimitSwitch_t){0,0},LeftMotor.Motor_Buffer};
12:                  	InitMotor(&LeftMotor, LEFTMOTORID, LEFTMOTOR_STATUS, LEFTMOTOR_MOB, MAXRPM, MAXCURRENTBG65,(LimitSwitch_t){0,0}, true);
00000018  00000000   NOP
13:                  	setMotorControlMode(&LeftMotor, Velocity);
00000054  00000000   NOP
14:                  	setMotorVel(&LeftMotor, 0);
00000060  00000000   NOP
15:                      
16:                  	#endif /*DISABLE_LEFT_MOTOR*/
17:                  	
18:                  	#ifndef DISABLE_RIGHT_MOTOR
19:                  	InitMotor(&RightMotor, RIGHTMOTORID, RIGHTMOTOR_STATUS, RIGHTMOTOR_MOB, MAXRPM, MAXCURRENTBG65,(LimitSwitch_t){0,0},true);
0000006C  00000000   NOP
20:                  	setMotorControlMode(&RightMotor, Velocity);
0000009C  00000000   NOP
21:                  	setMotorVel(&RightMotor, 0);
000000A8  00000000   NOP
22:                  	#endif /*DISABLE_ARM_MOTOR*/
23:                  	
24:                  	#ifndef DISABLE_ARM_MOTOR
25:                  	InitMotor_BG75(&ArmMotor, ARMMOTORID, ARMMOTOR_STATUS, ARMMOTOR_MOB, MAXRPM, MAXCURRENTARM, (LimitSwitch_t){LIM_D0L,LIM_D2L});
26:                  	setMotorControlMode(&ArmMotor, Velocity);
27:                  	setMotorVel(&ArmMotor, 0);
28:                  	#endif /*DISABLE_LEFT_MOTOR*/
29:                  	
30:                  	#ifndef DISABLE_BUCKET_MOTOR
31:                  	InitMotor(&BucketMotor, BUCKETMOTORID, BUCKETMOTOR_STATUS, BUCKETMOTOR_MOB, MAXRPM, MAXCURRENTBUCKET,(LimitSwitch_t){LIM_D0L,LIM_D1L},false);
000000B4  00000000   NOP
32:                  	setMotorControlMode(&BucketMotor, Velocity);
000000EC  00000000   NOP
33:                  	setMotorVel(&BucketMotor, 0);
000000F8  00000000   NOP
34:                  	#endif /*DISABLE_LEFT_MOTOR*/
35:                  	
36:                  	#ifndef DISABLE_PLOW_MOTOR
37:                  	InitMotor(&PlowMotor, PLOWMOTORID, PLOWMOTOR_STATUS, PLOWMOTOR_MOB, MAXRPM, MAXCURRENTPLOW,(LimitSwitch_t){0,0},false);
00000104  00000000   NOP
38:                  	setMotorControlMode(&PlowMotor, Velocity);
00000138  00000000   NOP
39:                  	setMotorVel(&PlowMotor, 0);
00000144  00000000   NOP
40:                  	#endif /*DISABLE_LEFT_MOTOR*/
41:                  	
42:                  }
00000150  00000000   NOP
43:                  void MotorsAllStop()
44:                  {
00000000  00000000   NOP
45:                  	
46:                  	#ifndef DISABLE_MOTOR_SYSTEMS
47:                  	
48:                  	setMotorVel(&RightMotor, 0);
00000008  00000000   NOP
49:                  	setMotorVel(&LeftMotor, 0);
00000018  00000000   NOP
50:                  
51:                  	#ifndef DISABLE_BUCKET_MOTOR
52:                  	setMotorVel(&BucketMotor,0);
00000028  00000000   NOP
53:                  	#endif
54:                  	
55:                  	#ifndef DISABLE_ARM_MOTOR
56:                  	setMotorVel(&ArmMotor, 0);
57:                  	#endif
58:                  	
59:                  	#endif
60:                  }
00000038  00000000   NOP
61:                  void setMotor_Vel(int leftSpeed,int rightSpeed)
62:                  {
00000000  00000000   NOP
63:                      setMotorVel(&RightMotor, rightSpeed);
00000010  00000000   NOP
64:                  
65:                  	setMotorVel(&LeftMotor, leftSpeed);
0000001C  00000000   NOP
66:                      
67:                  }
0000002C  00000000   NOP
68:                  
69:                  void requestMotorData(Motor_t * motor, int dataRequested) {
00000000  00000000   NOP
70:                      switch (dataRequested) {
00000004  00000000   NOP
71:                          case ENCODER_POSITION_REQUESTED:
72:                              requestMotorPacketWithResponse(motor->ID, MOTOR_ENCODER_POSITION_REQUEST, HALL_POSITION_REQUESTED, &(motor->EncoderPos));
00000050  00000000   NOP
73:                              break;
00000078  00000000   NOP
74:                          case HALL_POSITION_REQUESTED:
75:                              requestMotorPacketWithResponse(motor->ID, MOTOR_HALL_POSITION_REQUEST, SSI_ENCODER_POSITION_REQUESTED, &(motor->HallPos));
00000080  00000000   NOP
76:                              break;
000000A8  00000000   NOP
77:                          case SSI_ENCODER_POSITION_REQUESTED:
78:                              requestMotorPacketWithResponse(motor->ID, SSI_ENCODER_POSITION_REQUEST, ENCODER_POSITION_REQUESTED, &(motor->SSIEncoderPos));
000000B0  00000000   NOP
79:                              break;
000000D8  00000000   NOP
80:                          case ANALOG_0_REQUESTED:
81:                              requestMotorPacketWithResponse(motor->ID, MOTOR_ANALOG_0_INPUT_REQUEST, ANALOG_0_REQUESTED, &(motor->A0));
000000E0  00000000   NOP
82:                              break;
00000108  00000000   NOP
83:                          case ANALOG_1_REQUESTED:
84:                              requestMotorPacketWithResponse(motor->ID, MOTOR_ANALOG_1_INPUT_REQUEST, ANALOG_1_REQUESTED, &(motor->A1));
00000110  00000000   NOP
85:                              break;
00000138  00000000   NOP
86:                          case DIGITAL_INPUT_REQUESTED:
87:                              requestMotorPacketWithResponse(motor->ID, MOTOR_DIGITAL_INPUT_REQUEST, DIGITAL_INPUT_REQUESTED, &(motor->Digital));
00000140  00000000   NOP
88:                              break;
00000168  00000000   NOP
89:                          case POSITION_REACHED_REQUESTED:
90:                              requestMotorPacketWithResponse(motor->ID, MOTOR_POSITION_REACHED_REQUEST, POSITION_REACHED_REQUESTED, &(motor->PosReached));
00000170  00000000   NOP
91:                              break;
00000198  00000000   NOP
92:                          case ERROR_REQUESTED:
93:                              requestMotorPacketWithResponse(motor->ID, MOTOR_ERROR_REQUEST, ERROR_REQUESTED, &(motor->ErrorRqst));
000001A0  00000000   NOP
94:                              break;
000001C8  00000000   NOP
95:                          case CURRENT_USAGE:
96:                              requestMotorPacketWithResponse(motor->ID, MOTOR_CURRENT_USAGE, CURRENT_USAGE, &(motor->CurrentUsage));
000001D0  00000000   NOP
97:                              break;
98:                  
99:                      }
100:                 }
000001F8  00000000   NOP
101:                 void sendDriveCommand(int distance)
102:                 {
00000000  00000000   NOP
103:                     
104:                 }
105:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/map.c  ------------
1:                   #include "map.h"
2:                   #include "Definitions.h"
3:                   #include <stdlib.h>
4:                   #include <stdio.h>
5:                   
6:                   
7:                   void writeBitVal(int location, int _val);
8:                   int getBitVal(int location);
9:                   
10:                  #define WorldArraySize 61
11:                  #define SCALE_FACTOR 10
12:                  // assuming a 32 bit architecture (ARENA_LENGTH * ARENA_WIDTH) / 32
13:                  unsigned int world[WorldArraySize]; // =
14:                  
15:                  void writeBitVal(int location, int _val);
16:                  int getBitVal(int location);
17:                  void addObtaclePoint(int x, int y);
18:                  
19:                  void ClearWorld() {
9D00C9AC  3C028000   LUI V0, -32768
9D00C9B0  24424A34   ADDIU V0, V0, 18996
9D00C9B4  244300F4   ADDIU V1, V0, 244
20:                      int i;
21:                      for (i = 0; i < WorldArraySize; i++) {
9D00C9C0  5443FFFE   BNEL V0, V1, 0x9D00C9BC
9D00C9C4  AC400000   SW ZERO, 0(V0)
22:                          world[i] = 0;
9D00C9B8  AC400000   SW ZERO, 0(V0)
9D00C9BC  24420004   ADDIU V0, V0, 4
23:                      }
24:                  }
9D00C9C8  03E00008   JR RA
25:                  
26:                  /** \brief: This function given and X & Y value will provide a 1 for
27:                   *          the presence of an obstacle at that location or 0 of none.
28:                   *          Additionally, -1 will be returned if x or y value lay
29:                   *          outside the current map.
30:                   *
31:                   *
32:                   * \param:  The X coordinate that you wish to evaluate the map at
33:                   * \param:  The Y coordinate that you wish to evaluate the map at
34:                   * \return: will return the value of the map at the provided location
35:                   *
36:                   */
37:                  int h, t;
38:                  
39:                  int WorldAt(int x, int y) {
40:                      //    h = x;
41:                      //    t = y;
42:                      if (x >= 0 && x < (getWorldHight()) && y >= 0 && y < (getWorldWidth())) {
9D00C9D0  2C840226   SLTIU A0, A0, 550
9D00C9D4  10800005   BEQ A0, ZERO, 0x9D00C9EC
9D00C9D8  00000000   NOP
9D00C9DC  2CA2015E   SLTIU V0, A1, 350
9D00C9E0  38420001   XORI V0, V0, 1
9D00C9E4  03E00008   JR RA
9D00C9E8  00021023   SUBU V0, ZERO, V0
43:                          return 0;//getBitVal(((y * getWorldWidth()) / (SCALE_FACTOR*SCALE_FACTOR))+(x / SCALE_FACTOR)); //world[y*getWorldWidth()+x];
44:                      } else {
45:                          return -1;
46:                      }
47:                  }
9D00C9EC  03E00008   JR RA
48:                  
49:                  
50:                  /** \brief
51:                   *
52:                   * \param
53:                   * \param
54:                   * \return
55:                   *
56:                   */
57:                  #define COLLECTION_WIDTH 16
58:                  
59:                  void generateObstacleBoarder(int _boarderWidth) {
00000000  00000000   NOP
60:                      unsigned long i;
61:                  
62:                      int j;
63:                      // Top & Bottom Of Map boarder
64:                      for (i = 0; i < (getWorldWidth()); i++) {
00000024  00000000   NOP
00000058  00000000   NOP
65:                          for (j = 0; j < _boarderWidth; j++) {
0000004C  00000000   NOP
00000074  00000000   NOP
66:                              addObtaclePoint(i, j);
00000034  00000000   NOP
67:                              addObtaclePoint(getWorldWidth() - i, getWorldHight() - j);
00000040  00000000   NOP
68:                          }
69:                      }
70:                  
71:                      for (i = 0; i < getWorldHight(); i++) {
0000006C  00000000   NOP
000000B4  00000000   NOP
72:                          for (j = 0; j < _boarderWidth; j++) {
000000A8  00000000   NOP
000000C0  00000000   NOP
73:                              if (i > COLLECTION_WIDTH)
00000088  00000000   NOP
000000CC  00000000   NOP
74:                                  addObtaclePoint(j, i);
00000090  00000000   NOP
75:                              addObtaclePoint(getWorldWidth() - j, i);
0000009C  00000000   NOP
76:                          }
77:                  
78:                      }
79:                  }
000000D4  00000000   NOP
80:                  
81:                  void addobstacle(int _x, int _y) {
00000000  00000000   NOP
82:                      int x, y;
83:                  
84:                      // half of the robots width
85:                      //    int objectHalf = (ROBOT_WIDTH >> 1);
86:                      //    /* Should make a square rock that is the size of the robot in the Map */
87:                      //    for(y = _y - objectHalf; y < objectHalf + _y; y++)
88:                      //    {
89:                      //        for(x = _x - objectHalf; x < objectHalf +_x; x++)
90:                      //        {
91:                      //            writeBitVal(y*getWorldWidth()+x, 1);
92:                      //        }
93:                      //    }
94:                      addObtaclePoint(_x, _y);
00000008  00000000   NOP
95:                  }
00000010  00000000   NOP
96:                  
97:                  void writeBitVal(int location, int _val) {
98:                      int wordToAccess = location / 32;
00000000  00000000   NOP
99:                      int bitToAccess = location % 32;
00000010  00000000   NOP
100:                 
101:                     if (_val > 0) {
00000020  00000000   NOP
102:                         world[wordToAccess] = world[wordToAccess] | (1 << bitToAccess);
00000028  00000000   NOP
103:                     } else {
104:                         world[wordToAccess] = world[wordToAccess] & (!(1 << bitToAccess));
00000050  00000000   NOP
105:                     }
106:                 }
107:                 
108:                 int getBitVal(int location) {
109:                     int wordToAccess = location / 32;
00000000  00000000   NOP
110:                     int bitToAccess = location % 32;
111:                     if (wordToAccess < WorldArraySize) {
00000010  00000000   NOP
112:                         if (world[wordToAccess] & ((1 << bitToAccess)))
0000001C  00000000   NOP
113:                             return 1;
114:                         else
115:                             return 0;
116:                     }
117:                     return 1;
118:                 
119:                 }
00000038  00000000   NOP
120:                 
121:                 void addObtaclePoint(int x, int y) {
00000000  00000000   NOP
122:                     writeBitVal((y / SCALE_FACTOR)*(getWorldWidth() / SCALE_FACTOR)+(x / SCALE_FACTOR), 1);
00000008  00000000   NOP
123:                 }
00000054  00000000   NOP
124:                 
125:                 int getWorldHight() {
126:                     return ARENA_LENGTH;
127:                 }
128:                 
129:                 int getWorldWidth() {
130:                     return ARENA_WIDTH;
131:                 }
00000000  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/main.c  -----------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D00CAC4  27BDFFE8   ADDIU SP, SP, -24
9D00CAC8  AFBF0014   SW RA, 20(SP)
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D00CACC  0F401753   JAL SYS_Initialize
9D00CAD0  00002021   ADDU A0, ZERO, ZERO
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D00CAD4  0F4032CE   JAL SYS_Tasks
80:                  
81:                      }
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/macros.c  ---------
1:                   #include "Pozyx.h"
2:                   #include "Macros.h"
3:                   #include "Definitions.h"
4:                   #include "Map.h"
5:                   #include "Definitions.h"
6:                   #include "CAN_Handler/CANFastTransfer.h"
7:                   #include "CompairitorMethods.h"
8:                   #include "Timers.h"
9:                   #include "Algorithms.h"
10:                  #include "LinkedList.h"
11:                  #include "Telemetry.h"
12:                  #include "RockDetection.h"
13:                  #include "app.h"
14:                  #include "A_Star.h"
15:                  #include "Motor.h"
16:                  #include "Macro_Handler/Macro_Mgr.h"
17:                  
18:                  //*********************************************************
19:                  //                      DEFINITIONS
20:                  //*********************************************************
21:                  
22:                  #define CENTER_DRIVE_DISTANCE       50   //DISTANCE FROM STARTING TO CENTER OF ARENA
23:                  #define MIGRATION_DISTANCE_DIGGING  350
24:                  #define MIGRATION_DISTANCE_DUMPING  350
25:                  #define PLOWING_DISTANCE            100
26:                  #define FORWARD                     true
27:                  #define BACKWARD                    false
28:                  #define StartDriveDist              20
29:                  #define PointToDig                 (point_t){650,200}
30:                  
31:                  
32:                  
33:                  #define START_INFO_DIST_MASK  0x7FFF
34:                  #define StartInfo_Side_Mask  0x8000     // MSB = 1 (robot is in front of the master lider): MAB = 0 (Robot is in front of the slave Lidar)
35:                  
36:                  
37:                  
38:                  
39:                  bool autoWaiting = false;
40:                  
41:                  
42:                  unsigned char MacroState = 0;
43:                  
44:                  
45:                  point_t pathFrom = {40, 70};
46:                  point_t pathTo = {240, 320};
47:                  LL_t *RobotPath;
48:                  void InitPathAlgorithm();
49:                  void addStopToPath(point_t _stopPoint);
50:                  bool RunPath(int nan);
51:                  
52:                  void setWaiter(bool(*_waitingOn)());
53:                  bool(*waitingOn)();
54:                  bool waiting = false;
55:                  timers_t TimeOut, clearMacroTimer, ClearTimer;
56:                  timers_t Retransmit;
57:                  bool runningMacroData = 0;
58:                  bool MacroRunning = false;
59:                  
60:                  bool isWaiting();
61:                  bool getMotorControllerStatus();
62:                  bool getGyroControllerStatus();
63:                  bool noWaiting();
64:                  
65:                  bool gyroState = DONE, motorState = DONE;
66:                  
67:                  
68:                  
69:                  
70:                  
71:                  timers_t voidTime, voidTime2;
72:                  
73:                  bool Dummy(int val) {
00000000  00000000   NOP
74:                      if (voidTime.timerInterval != val) {
00000008  00000000   NOP
75:                          setTimerInterval(&voidTime, val);
00000014  00000000   NOP
76:                      }
77:                      return timerDone(&voidTime);
0000001C  00000000   NOP
78:                  }
00000024  00000000   NOP
79:                  
80:                  #define TEST_DRIVE (uint16_t)(1<<2)
81:                  
82:                  void handleMacroStatus() {
9D00AB58  27BDFFE8   ADDIU SP, SP, -24
9D00AB5C  AFBF0014   SW RA, 20(SP)
9D00AB60  AFB00010   SW S0, 16(SP)
83:                      ReceiveDataCAN(FT_GLOBAL);
9D00AB64  0F40279E   JAL ReceiveDataCAN
9D00AB68  24040001   ADDIU A0, ZERO, 1
84:                      ReceiveDataCAN(FT_LOCAL);
9D00AB6C  0F40279E   JAL ReceiveDataCAN
9D00AB70  00002021   ADDU A0, ZERO, ZERO
85:                      /* If a macro is seen on the global bus from the router card*/
86:                      if (getNewDataFlagStatus(FT_GLOBAL, getGBL_MACRO_INDEX(ROUTER_CARD))) {
9D00AB74  24040001   ADDIU A0, ZERO, 1
9D00AB78  0F403247   JAL getNewDataFlagStatus
9D00AB7C  2405001D   ADDIU A1, ZERO, 29
9D00AB80  1040000C   BEQ V0, ZERO, 0x9D00ABB4
9D00AB84  00002021   ADDU A0, ZERO, ZERO
87:                  
88:                          int macroID = getCANFastData(FT_GLOBAL, getGBL_MACRO_INDEX(ROUTER_CARD));
9D00AB88  24040001   ADDIU A0, ZERO, 1
9D00AB8C  0F402EED   JAL getCANFastData
9D00AB90  2405001D   ADDIU A1, ZERO, 29
9D00AB94  00408021   ADDU S0, V0, ZERO
89:                          int macroDATA = getCANFastData(FT_GLOBAL, getGBL_MACRO_INDEX(ROUTER_CARD) + 1);
9D00AB98  24040001   ADDIU A0, ZERO, 1
9D00AB9C  0F402EED   JAL getCANFastData
9D00ABA0  2405001E   ADDIU A1, ZERO, 30
90:                          handleCANmacro(macroID, macroDATA);
9D00ABA4  7C102620   SEH A0, S0
9D00ABA8  0F403069   JAL handleCANmacro
9D00ABAC  7C022E20   SEH A1, V0
91:                      }
92:                      if (getNewDataFlagStatus(FT_LOCAL, CAN_COMMAND_INDEX)) {
9D00ABB0  00002021   ADDU A0, ZERO, ZERO
9D00ABB4  0F403247   JAL getNewDataFlagStatus
9D00ABB8  24050008   ADDIU A1, ZERO, 8
9D00ABBC  1040000C   BEQ V0, ZERO, 0x9D00ABF0
9D00ABC0  8FBF0014   LW RA, 20(SP)
93:                          int macroID = getCANFastData(FT_LOCAL, CAN_COMMAND_INDEX);
9D00ABC4  00002021   ADDU A0, ZERO, ZERO
9D00ABC8  0F402EED   JAL getCANFastData
9D00ABCC  24050008   ADDIU A1, ZERO, 8
9D00ABD0  00408021   ADDU S0, V0, ZERO
94:                          int macroDATA = getCANFastData(FT_LOCAL, CAN_COMMAND_DATA_INDEX);
9D00ABD4  00002021   ADDU A0, ZERO, ZERO
9D00ABD8  0F402EED   JAL getCANFastData
9D00ABDC  24050009   ADDIU A1, ZERO, 9
95:                          handleCANmacro(macroID, macroDATA);
9D00ABE0  7C102620   SEH A0, S0
9D00ABE4  0F403069   JAL handleCANmacro
9D00ABE8  7C022E20   SEH A1, V0
96:                      }
97:                  
98:                  }
9D00ABEC  8FBF0014   LW RA, 20(SP)
99:                  
100:                 void handleCANmacro(short _macroID, short _macroDATA) {
9D00C1A4  27BDFFE8   ADDIU SP, SP, -24
101:                     if (_macroID == 0) {
9D00C1A8  14800005   BNE A0, ZERO, .LVL6
9D00C1AC  AFBF0014   SW RA, 20(SP)
102:                         clearMacros();
9D00C1B0  0F4031F1   JAL initMacroMGR
9D00C1B4  00000000   NOP
9D00C1B8  0B403079   J 0x9D00C1E4
9D00C1BC  8FBF0014   LW RA, 20(SP)
103:                     } else {
104:                         /* Add the macro to the queue*/
105:                         switch (_macroID) {
9D00C1C0  24020004   ADDIU V0, ZERO, 4
9D00C1C4  14820007   BNE A0, V0, 0x9D00C1E4
9D00C1C8  8FBF0014   LW RA, 20(SP)
106:                 
107:                             case TEST_DRIVE:
108:                                 setMacroCallback(RunPath, 5000, TEST_DRIVE);
9D00C1CC  3C049D01   LUI A0, -25343
9D00C1D0  2484808C   ADDIU A0, A0, -32628
9D00C1D4  24051388   ADDIU A1, ZERO, 5000
9D00C1D8  0F4029C4   JAL setMacroCallback
9D00C1DC  24060004   ADDIU A2, ZERO, 4
109:                                 break;
110:                             default:
111:                                 break;
112:                         }
113:                     }
114:                 }
9D00C1E0  8FBF0014   LW RA, 20(SP)
115:                 
116:                 bool isWaiting() {
00000000  00000000   NOP
117:                     if (waitingOn == NULL) {
00000008  00000000   NOP
118:                         return DONE;
119:                     }
120:                     return waitingOn();
00000014  00000000   NOP
121:                 }
00000024  00000000   NOP
122:                 
123:                 void setWaiter(bool(*_waitingOn)()) {
124:                     waitingOn = _waitingOn;
125:                 }
126:                 
127:                 bool noWaiting() {
128:                     return DONE;
129:                 }
00000000  00000000   NOP
130:                 
131:                 void testPathAlgorithm() {
9D00C410  27BDFFE0   ADDIU SP, SP, -32
9D00C414  AFBF001C   SW RA, 28(SP)
132:                     //InitPathAlgorithm();
133:                     RobotPath = LL_init();
9D00C418  0F403233   JAL LL_init
9D00C41C  00000000   NOP
134:                 
135:                     receivePozyx();
9D00C420  0F4032A1   JAL receivePozyx
9D00C424  AF82817C   SW V0, -32388(GP)
136:                     //pathFrom = getLocation();
137:                     getPolarPath(RobotPath, pathFrom, pathTo);
9D00C428  8F828018   LW V0, -32744(GP)
9D00C42C  AFA20010   SW V0, 16(SP)
9D00C430  8F878014   LW A3, -32748(GP)
9D00C434  8F84817C   LW A0, -32388(GP)
9D00C438  8F85801C   LW A1, -32740(GP)
9D00C43C  0F401A50   JAL getPolarPath
9D00C440  8F868020   LW A2, -32736(GP)
138:                     //    addStopToPath((point_t) {
139:                     //        100, 100
140:                     //    });
141:                     //    addStopToPath((point_t) {
142:                     //        100, 0
143:                     //    });
144:                     //
145:                     //    addStopToPath((point_t) {
146:                     //        0, 0
147:                     //    });
148:                     //    addStopToPath((point_t){0, 0});
149:                 }
9D00C444  8FBF001C   LW RA, 28(SP)
150:                 
151:                 typedef enum {
152:                     Init = 0,
153:                     ROTATION,
154:                     DRIVE,
155:                     GyroWait,
156:                     MotorWait
157:                 } PathFollowStep_t;
158:                 PathFollowStep_t pathSteps = Init;
159:                 double gyroHeading, motorDist;
160:                 double myHeading = 0;
161:                 
162:                 bool RunPath(int nan) {
9D00808C  27BDFFE0   ADDIU SP, SP, -32
9D008090  AFBF001C   SW RA, 28(SP)
9D008094  AFB20018   SW S2, 24(SP)
9D008098  AFB10014   SW S1, 20(SP)
163:                     if (getGyroControllerStatus() == DONE && getMotorControllerStatus() == DONE) {
9D00809C  0F40328F   JAL getGyroControllerStatus
9D0080A0  AFB00010   SW S0, 16(SP)
9D0080A4  14400082   BNE V0, ZERO, 0x9D0082B0
9D0080A8  00408021   ADDU S0, V0, ZERO
9D0080AC  0F403286   JAL getMotorControllerStatus
9D0080B0  00000000   NOP
9D0080B4  1440007F   BNE V0, ZERO, 0x9D0082B4
9D0080B8  00408821   ADDU S1, V0, ZERO
164:                         if (pathSteps == Init) {
9D0080BC  8F828088   LW V0, -32632(GP)
9D0080C0  14400006   BNE V0, ZERO, 0x9D0080DC
9D0080C4  8F82817C   LW V0, -32388(GP)
165:                             testPathAlgorithm();
9D0080C8  0F403104   JAL testPathAlgorithm
9D0080CC  00000000   NOP
166:                             pathSteps = ROTATION;
9D0080D0  24020001   ADDIU V0, ZERO, 1
9D0080D4  0B40203C   J 0x9D0080F0
9D0080D8  AF828088   SW V0, -32632(GP)
167:                         } else {
168:                             if (RobotPath != 0 && RobotPath->size < 1) {
9D0080DC  10400004   BEQ V0, ZERO, 0x9D0080F0
9D0080E0  00000000   NOP
9D0080E4  8C420000   LW V0, 0(V0)
9D0080E8  10400072   BEQ V0, ZERO, 0x9D0082B4
9D0080EC  24100001   ADDIU S0, ZERO, 1
169:                                 return true;
170:                             }
171:                         }
172:                         receivePozyx();
9D0080F0  0F4032A1   JAL receivePozyx
9D0080F4  00000000   NOP
173:                         myHeading = getPozyxHeading();
9D0080F8  0F4032FC   JAL getPozyxHeading
9D0080FC  00000000   NOP
9D008100  E7808084   SWC1 F0, -32636(GP)
174:                         switch (pathSteps) {
9D008104  8F828088   LW V0, -32632(GP)
9D008108  24030002   ADDIU V1, ZERO, 2
9D00810C  1043002F   BEQ V0, V1, 0x9D0081CC
9D008110  2C430003   SLTIU V1, V0, 3
9D008114  10600006   BEQ V1, ZERO, 0x9D008130
9D008118  24030003   ADDIU V1, ZERO, 3
9D00811C  24030001   ADDIU V1, ZERO, 1
9D008120  10430009   BEQ V0, V1, 0x9D008148
9D008124  8F82817C   LW V0, -32388(GP)
9D008130  10430039   BEQ V0, V1, 0x9D008218
9D008134  24030004   ADDIU V1, ZERO, 4
9D008138  1043004A   BEQ V0, V1, 0x9D008264
9D00813C  02208021   ADDU S0, S1, ZERO
175:                            
176:                             case ROTATION:
177:                                 gyroHeading = ((waypoint_t*) (RobotPath->first->data))->heading;
9D008148  8C420004   LW V0, 4(V0)
9D00814C  8C420000   LW V0, 0(V0)
9D008150  C4410008   LWC1 F1, 8(V0)
178:                                 if (gyroHeading > myHeading) {
9D008154  4601003C   C.LT.S F0, F1
9D008158  45020004   BC1FL 0x9D00816C
9D00815C  46010001   SUB.S F0, F0, F1
179:                                     gyroHeading = gyroHeading - myHeading;
9D008160  46000801   SUB.S F0, F1, F0
9D008164  0B40205C   J 0x9D008170
9D008168  E7808158   SWC1 F0, -32424(GP)
180:                                 } else {
181:                                     gyroHeading = myHeading - gyroHeading;
9D00816C  E7808158   SWC1 F0, -32424(GP)
182:                                 }
183:                                 if (gyroHeading > 180)
9D008170  C7808158   LWC1 F0, -32424(GP)
9D008174  3C029D01   LUI V0, -25343
9D008178  C441A3DC   LWC1 F1, -23588(V0)
9D00817C  4600093C   C.LT.S 1, F1, F0
9D008180  45040004   BC1F 1, 0x9D008194
9D008184  24040001   ADDIU A0, ZERO, 1
184:                                     gyroHeading -= 180;
9D008188  46010001   SUB.S F0, F0, F1
9D00818C  E7808158   SWC1 F0, -32424(GP)
185:                                 setGyroMacro(ROTATION_COMMAND, gyroHeading);
9D008190  C7808158   LWC1 F0, -32424(GP)
9D008194  4600000D   TRUNC.W.S F0, F0
9D008198  0F4030B1   JAL setGyroMacro
9D00819C  44050000   MFC1 A1, F0
186:                                 myHeading += gyroHeading;
9D0081A0  C7808158   LWC1 F0, -32424(GP)
9D0081A4  C7818084   LWC1 F1, -32636(GP)
9D0081A8  46000800   ADD.S F0, F1, F0
9D0081AC  E7808084   SWC1 F0, -32636(GP)
187:                                 pathSteps = GyroWait;
9D0081B0  24020003   ADDIU V0, ZERO, 3
9D0081B4  AF828088   SW V0, -32632(GP)
188:                                 setTimerInterval(&Retransmit, 500);
9D0081B8  27848174   ADDIU A0, GP, -32396
9D0081BC  0F403306   JAL setTimerInterval
9D0081C0  240501F4   ADDIU A1, ZERO, 500
189:                                 break;
9D0081C4  0B4020AD   J 0x9D0082B4
9D0081C8  02208021   ADDU S0, S1, ZERO
190:                             case DRIVE:
191:                                 motorDist = ((waypoint_t*) (RobotPath->first->data))->Distance;
9D0081CC  8F82817C   LW V0, -32388(GP)
9D0081D0  8C420004   LW V0, 4(V0)
9D0081D4  8C420000   LW V0, 0(V0)
9D0081D8  8C45000C   LW A1, 12(V0)
9D0081DC  AF85815C   SW A1, -32420(GP)
192:                                 setMotorMacro(ENCODER_COMMAND, motorDist);
9D0081E0  24040003   ADDIU A0, ZERO, 3
9D0081E4  44850000   MTC1 A1, F0
9D0081E8  4600000D   TRUNC.W.S F0, F0
9D0081EC  0F4030C2   JAL setMotorMacro
9D0081F0  44050000   MFC1 A1, F0
193:                                 LL_pop(RobotPath);
9D0081F4  0F402F48   JAL LL_pop
9D0081F8  8F84817C   LW A0, -32388(GP)
194:                                 pathSteps = MotorWait;
9D0081FC  24020004   ADDIU V0, ZERO, 4
9D008200  AF828088   SW V0, -32632(GP)
195:                                 setTimerInterval(&Retransmit, 500);
9D008204  27848174   ADDIU A0, GP, -32396
9D008208  0F403306   JAL setTimerInterval
9D00820C  240501F4   ADDIU A1, ZERO, 500
196:                                 break;
9D008210  0B4020AD   J 0x9D0082B4
9D008214  02208021   ADDU S0, S1, ZERO
197:                             case GyroWait:
198:                                 if (getGyroControllerStatus())
9D008218  0F40328F   JAL getGyroControllerStatus
9D00821C  00000000   NOP
9D008220  10400005   BEQ V0, ZERO, 0x9D008238
9D008224  00409021   ADDU S2, V0, ZERO
199:                                     pathSteps = DRIVE;
9D008228  24020002   ADDIU V0, ZERO, 2
9D00822C  AF828088   SW V0, -32632(GP)
9D008230  0B4020AD   J 0x9D0082B4
9D008234  02208021   ADDU S0, S1, ZERO
200:                                 else if (timerDone(&Retransmit))
9D008238  0F403198   JAL timerDone
9D00823C  27848174   ADDIU A0, GP, -32396
9D008240  1040001C   BEQ V0, ZERO, 0x9D0082B4
9D008244  00408021   ADDU S0, V0, ZERO
201:                                     setGyroMacro(ROTATION_COMMAND, gyroHeading);
9D008248  24040001   ADDIU A0, ZERO, 1
9D00824C  C7808158   LWC1 F0, -32424(GP)
9D008250  4600000D   TRUNC.W.S F0, F0
9D008254  0F4030B1   JAL setGyroMacro
9D008258  44050000   MFC1 A1, F0
202:                                 break;
203:                             case MotorWait:
204:                                 if (getMotorControllerStatus())
9D008264  0F403286   JAL getMotorControllerStatus
9D008268  00000000   NOP
9D00826C  10400005   BEQ V0, ZERO, 0x9D008284
9D008270  00409021   ADDU S2, V0, ZERO
205:                                     pathSteps = ROTATION;
9D008274  24020001   ADDIU V0, ZERO, 1
9D008278  AF828088   SW V0, -32632(GP)
9D00827C  0B4020AD   J 0x9D0082B4
9D008280  02208021   ADDU S0, S1, ZERO
206:                                 else if (timerDone(&Retransmit))
9D008284  0F403198   JAL timerDone
9D008288  27848174   ADDIU A0, GP, -32396
9D00828C  10400009   BEQ V0, ZERO, 0x9D0082B4
9D008290  00408021   ADDU S0, V0, ZERO
207:                                     setMotorMacro(ENCODER_COMMAND, motorDist);
9D008294  24040003   ADDIU A0, ZERO, 3
9D008298  C780815C   LWC1 F0, -32420(GP)
9D00829C  4600000D   TRUNC.W.S F0, F0
9D0082A0  0F4030C2   JAL setMotorMacro
9D0082A4  44050000   MFC1 A1, F0
208:                                 break;
209:                         }
210:                     }
211:                     return false;
9D008128  0B4020AD   J 0x9D0082B4
9D00812C  02208021   ADDU S0, S1, ZERO
9D00825C  0B4020AD   J 0x9D0082B4
9D008260  02408021   ADDU S0, S2, ZERO
9D0082A8  0B4020AD   J 0x9D0082B4
9D0082AC  02408021   ADDU S0, S2, ZERO
9D0082B0  00008021   ADDU S0, ZERO, ZERO
212:                 }
9D008140  0B4020AE   J 0x9D0082B8
9D008144  02001021   ADDU V0, S0, ZERO
9D0082B4  02001021   ADDU V0, S0, ZERO
213:                 
214:                 void addStopToPath(point_t _stopPoint) {
00000000  00000000   NOP
215:                     point_t endpoint = ((point_t) ((waypoint_t*) RobotPath->last->data)->Endpoint);
00000010  00000000   NOP
216:                     getPolarPath(RobotPath, endpoint, _stopPoint);
00000024  00000000   NOP
217:                 }
00000038  00000000   NOP
218:                 
219:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/macro_handler/macro_mgr.c
1:                   #include "Macro_Handler/Macro_Mgr.h"
2:                   #include "Definitions.h"
3:                   #include <stddef.h>
4:                   // Will hold the function callback of the macros
5:                   MacroCallBack_t macroCallBacks[MaxNumMacros];
6:                   unsigned char macroCount = 0;
7:                   void initMacroMGR()
8:                   {
9D00C7C4  3C028000   LUI V0, -32768
9D00C7C8  24424A04   ADDIU V0, V0, 18948
9D00C7CC  24430030   ADDIU V1, V0, 48
9:                       int i;
10:                      for(i =0; i <MaxNumMacros;i++)
9D00C7E0  5443FFFC   BNEL V0, V1, 0x9D00C7D4
9D00C7E4  AC400004   SW ZERO, 4(V0)
11:                      {
12:                          macroCallBacks[i].ID = 0;
9D00C7D0  AC400004   SW ZERO, 4(V0)
13:                          macroCallBacks[i].callBack = NULL;
9D00C7D4  AC400000   SW ZERO, 0(V0)
14:                          macroCallBacks[i].parameter = 0;
9D00C7D8  AC400008   SW ZERO, 8(V0)
9D00C7DC  2442000C   ADDIU V0, V0, 12
15:                      }
16:                      macroCount = 0;
9D00C7E8  03E00008   JR RA
17:                  }
18:                  /* 
19:                   *  < bool setMacroCallback(bool(*_callBack)(int), int _parm, unsigned int _macroID) >
20:                   * 
21:                   *  *_callBack: this parameter should be a pointer to a function that 
22:                   *              will return true when the macro has completed
23:                   * 
24:                   *      _parm : this parameter should be passed to the function callback
25:                   *              every time it is called
26:                   * 
27:                   *    _macroID: this parameter should be a unique id that is associated 
28:                   *              with the macro that is being run
29:                   * 
30:                   *      Return: will return true when the function was successfully 
31:                   *              added to the call stack
32:                   */
33:                  bool setMacroCallback(PFI _callBack, int _parm, unsigned int _macroID) {
34:                      int i;
35:                      /* If the macro id is already registered and 
36:                       * running we don't want to added it again */
37:                      for (i = 0; i < MaxNumMacros; i++) {
38:                          
39:                          if (macroCallBacks[i].ID == _macroID)
9D00A710  3C028000   LUI V0, -32768
9D00A714  8C424A08   LW V0, 18952(V0)
9D00A718  10460025   BEQ V0, A2, .LVL11
9D00A71C  00000000   NOP
9D00A720  3C028000   LUI V0, -32768
9D00A724  8C424A14   LW V0, 18964(V0)
9D00A728  10460023   BEQ V0, A2, .LVL12
9D00A72C  00000000   NOP
9D00A730  3C028000   LUI V0, -32768
9D00A734  8C424A20   LW V0, 18976(V0)
9D00A738  10460021   BEQ V0, A2, .LVL13
9D00A73C  00000000   NOP
9D00A740  3C028000   LUI V0, -32768
9D00A744  8C424A2C   LW V0, 18988(V0)
9D00A748  1046001F   BEQ V0, A2, .LVL14
9D00A74C  3C038000   LUI V1, -32768
9D00A750  24634A04   ADDIU V1, V1, 18948
9D00A754  00001021   ADDU V0, ZERO, ZERO
40:                               return 0;
9D00A7B0  03E00008   JR RA
41:                      }
42:                      bool callBackSet = false;
43:                      for (i = 0; i < MaxNumMacros; i++) {
9D00A758  24080004   ADDIU T0, ZERO, 4
9D00A7A0  1448FFEE   BNE V0, T0, .LVL7
9D00A7A4  2463000C   ADDIU V1, V1, 12
9D00A7A8  03E00008   JR RA
9D00A7AC  00001021   ADDU V0, ZERO, ZERO
44:                          if (macroCallBacks[i].callBack == NULL) {
9D00A75C  8C670000   LW A3, 0(V1)
9D00A760  54E0000F   BNEL A3, ZERO, .LVL10
9D00A764  24420001   ADDIU V0, V0, 1
45:                              /* Add the Macro function to the callback list */
46:                              macroCallBacks[i].callBack = _callBack;
9D00A768  00021880   SLL V1, V0, 2
9D00A76C  00021100   SLL V0, V0, 4
9D00A770  00431023   SUBU V0, V0, V1
9D00A774  3C038000   LUI V1, -32768
9D00A778  24634A04   ADDIU V1, V1, 18948
9D00A77C  00431021   ADDU V0, V0, V1
9D00A780  AC440000   SW A0, 0(V0)
47:                              macroCallBacks[i].ID = _macroID;
9D00A784  AC460004   SW A2, 4(V0)
48:                              macroCallBacks[i].parameter = _parm;
9D00A788  AC450008   SW A1, 8(V0)
49:                              macroCount++;
9D00A78C  93828064   LBU V0, -32668(GP)
9D00A790  24420001   ADDIU V0, V0, 1
9D00A794  A3828064   SB V0, -32668(GP)
50:                              /* Setting that the call back was inserted into the list */
51:                              callBackSet = true;
9D00A798  03E00008   JR RA
9D00A79C  24020001   ADDIU V0, ZERO, 1
52:                              /* jump out of the for loop */
53:                              i = MaxNumMacros;
54:                          }
55:                      }
56:                      return callBackSet;
57:                  }
58:                  
59:                  /* 
60:                   *  < bool runMacros() >
61:                   * 
62:                   *  Return: will return true when any of the macros in the list completes
63:                   */
64:                  bool runMacros() {
9D00B33C  27BDFFD8   ADDIU SP, SP, -40
9D00B340  AFBF0024   SW RA, 36(SP)
9D00B344  AFB30020   SW S3, 32(SP)
9D00B348  AFB2001C   SW S2, 28(SP)
9D00B34C  AFB10018   SW S1, 24(SP)
9D00B350  AFB00014   SW S0, 20(SP)
9D00B354  3C108000   LUI S0, -32768
9D00B358  26104A04   ADDIU S0, S0, 18948
9D00B35C  26120030   ADDIU S2, S0, 48
65:                      bool macroFinished = false;
9D00B360  00009821   ADDU S3, ZERO, ZERO
66:                      int i;
67:                      for (i = 0; i < MaxNumMacros; i++) {
9D00B3A0  5612FFF1   BNEL S0, S2, 0x9D00B368
9D00B3A4  8E030000   LW V1, 0(S0)
68:                          /* Running the macro and if it returns true (indicating it has completed)
69:                           * it will or it with the macroFinished state */
70:                          if (macroCallBacks[i].callBack != NULL) {
9D00B364  8E030000   LW V1, 0(S0)
9D00B368  5060000D   BEQL V1, ZERO, 0x9D00B3A0
9D00B36C  2610000C   ADDIU S0, S0, 12
71:                              /* When a Macro returns true remove it from the macro list */
72:                              if ((*(macroCallBacks[i].callBack))(macroCallBacks[i].parameter)) {
9D00B370  0060F809   JALR V1
9D00B374  8E040008   LW A0, 8(S0)
9D00B378  50400009   BEQL V0, ZERO, 0x9D00B3A0
9D00B37C  2610000C   ADDIU S0, S0, 12
73:                                  macroFinished |= 1;
9D00B398  24130001   ADDIU S3, ZERO, 1
9D00B39C  2610000C   ADDIU S0, S0, 12
74:                                  macroCallBacks[i].callBack = NULL;
9D00B380  AE000000   SW ZERO, 0(S0)
75:                                  macroCallBacks[i].ID = NULL;
9D00B384  AE000004   SW ZERO, 4(S0)
76:                                  macroCallBacks[i].parameter = NULL;
9D00B388  AE000008   SW ZERO, 8(S0)
77:                                  macroCount--;
9D00B38C  93828064   LBU V0, -32668(GP)
9D00B390  2442FFFF   ADDIU V0, V0, -1
9D00B394  A3828064   SB V0, -32668(GP)
78:                              }
79:                          }
80:                  
81:                      }
82:                      return macroFinished;
83:                  }
9D00B3A8  02601021   ADDU V0, S3, ZERO
84:                  
85:                  /* 
86:                   *  < uint32_t getRunningMacros()  >
87:                   * 
88:                   *  Return: A 32 bit integer is returned with the IDth bit of
89:                   *          macroResult 1 for each of the IDs found in the macro list
90:                   */
91:                  #define isMacroXrunning(c) (getRunningMacros() & (1 << c))
92:                  
93:                  int getRunningMacros() {
9D00C5F0  3C038000   LUI V1, -32768
9D00C5F4  24634A04   ADDIU V1, V1, 18948
9D00C5F8  24650030   ADDIU A1, V1, 48
94:                      int i;
95:                     uint16_t macroResult = 0;
9D00C5FC  00001021   ADDU V0, ZERO, ZERO
96:                      for (i = 0; i < MaxNumMacros; i++) {
9D00C618  5465FFFA   BNEL V1, A1, 0x9D00C604
9D00C61C  8C640000   LW A0, 0(V1)
97:                          /* Running the macro and if it returns true (indicating it has completed)
98:                           * it will or it with the macroFinished state */
99:                          if((macroCallBacks[i].callBack) != NULL) {
9D00C600  8C640000   LW A0, 0(V1)
9D00C604  50800004   BEQL A0, ZERO, 0x9D00C618
9D00C608  2463000C   ADDIU V1, V1, 12
100:                             /* The IDth bit of macroResult 1 if the ID if found in the list */
101:                             macroResult = macroResult | macroCallBacks[i].ID;
9D00C60C  94640004   LHU A0, 4(V1)
9D00C610  00441025   OR V0, V0, A0
9D00C614  2463000C   ADDIU V1, V1, 12
102:                         }
103:                 
104:                     }
105:                     return (uint16_t)(macroResult & 0xFFFF);
106:                 }
9D00C620  03E00008   JR RA
107:                 /* 
108:                  *  < void getRunningMacroCount()  >
109:                  * 
110:                  *  Return: returns the number of registered macros that are running
111:                  */
112:                 int getRunningMacroCount()
113:                 {
114:                     return macroCount;
115:                 }
00000000  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/linkedlist.c  -----
1:                   /*
2:                    * File:      LL.c
3:                    * Author:    Philip Klostermann
4:                    * Source:    https://github.com/philbot9/generic-linked-list/blob/master/src
5:                    */
6:                   
7:                   #include <stdio.h>
8:                   #include <stdlib.h>
9:                   #include "LinkedList.h"
10:                  
11:                  #define C_OK 0
12:                  #define C_NOK -1
13:                  
14:                  static LL_node_t *LL_findNode(LL_t *, int);
15:                  static LL_node_t *LL_initNode(void *);
16:                  
17:                  /*  
18:                   * Initialize a new list
19:                   * returns:   pointer to new list
20:                   */
21:                  LL_t *LL_init() {
9D00C8CC  27BDFFE8   ADDIU SP, SP, -24
9D00C8D0  AFBF0014   SW RA, 20(SP)
22:                      LL_t *list = (LL_t *)malloc(sizeof(LL_t));
9D00C8D4  0F4012F7   JAL malloc
9D00C8D8  2404000C   ADDIU A0, ZERO, 12
23:                      list->size = 0;
9D00C8DC  AC400000   SW ZERO, 0(V0)
24:                      list->first = NULL;
9D00C8E0  AC400004   SW ZERO, 4(V0)
25:                      list->last = NULL;
9D00C8E4  AC400008   SW ZERO, 8(V0)
26:                      return list;
27:                  }
9D00C8E8  8FBF0014   LW RA, 20(SP)
28:                  
29:                  /*
30:                   * Helper function:
31:                   * Initialize a new node
32:                   * in:        pointer to data
33:                   * returns:   pointer to new node
34:                   */
35:                  LL_node_t *node;
36:                  static LL_node_t *LL_initNode(void *data) {
9D00C5B8  27BDFFE8   ADDIU SP, SP, -24
9D00C5BC  AFBF0014   SW RA, 20(SP)
9D00C5C0  AFB00010   SW S0, 16(SP)
9D00C5C4  00808021   ADDU S0, A0, ZERO
37:                      node = NULL;
38:                      node = (LL_node_t *) malloc(sizeof (LL_node_t));
9D00C5C8  0F4012F7   JAL malloc
9D00C5CC  2404000C   ADDIU A0, ZERO, 12
9D00C5D0  AF8280C4   SW V0, -32572(GP)
39:                      node->data = data;
9D00C5D4  AC500000   SW S0, 0(V0)
40:                      node->prev = NULL;
9D00C5D8  AC400004   SW ZERO, 4(V0)
41:                      node->next = NULL;
9D00C5DC  AC400008   SW ZERO, 8(V0)
42:                      return node;
43:                  }
9D00C5E0  8FBF0014   LW RA, 20(SP)
44:                  
45:                  /*
46:                   * Get element at arbitrary position 
47:                   * in:        pointer to list
48:                   * in:        position
49:                   * returns:   void pointer to data / NULL on failure
50:                   */
51:                  void *LL_get(LL_t *list, int pos) {
00000000  00000000   NOP
52:                      LL_node_t *node = LL_findNode(list, pos);
00000008  00000000   NOP
53:                      if (node != NULL)
00000010  00000000   NOP
54:                          return node->data;
55:                      else
56:                          return NULL;
57:                  }
0000001C  00000000   NOP
58:                  
59:                  /*
60:                   * return the first element in the list
61:                   * in:        list pointer
62:                   * returns:   data of first element / NULL on failure
63:                   */
64:                  void *LL_first(LL_t *list) {
65:                      if (list->first == NULL)
00000000  00000000   NOP
66:                          return NULL;
67:                  
68:                      return list->first->data;
0000000C  00000000   NOP
69:                  }
00000014  00000000   NOP
70:                  
71:                  /*
72:                   * return the last element in the list
73:                   * in:        list pointer
74:                   * returns:   data of last element / NULL on failure
75:                   */
76:                  void *LL_last(LL_t *list) {
77:                      if (list->last == NULL)
00000000  00000000   NOP
78:                          return NULL;
79:                  
80:                      return list->last->data;
0000000C  00000000   NOP
81:                  }
00000014  00000000   NOP
82:                  
83:                  /*
84:                   * Helper function:
85:                   * Find node at a given position
86:                   * in:        pointer to list
87:                   * in:        position
88:                   * returns:   pointer to Node / NULL on failure
89:                   */
90:                  static LL_node_t *LL_findNode(LL_t *list, int pos) {
91:                      if (pos > list->size || pos < 0)
9D00B0E8  8C830000   LW V1, 0(A0)
9D00B0EC  0065102B   SLTU V0, V1, A1
9D00B0F0  1440001E   BNE V0, ZERO, .LVL10
9D00B0F4  00000000   NOP
9D00B0F8  04A0001E   BLTZ A1, 0x9D00B174
9D00B0FC  2463FFFF   ADDIU V1, V1, -1
92:                          return NULL;
9D00B16C  03E00008   JR RA
9D00B170  00001021   ADDU V0, ZERO, ZERO
9D00B174  00001021   ADDU V0, ZERO, ZERO
93:                  
94:                      LL_node_t *currNode;
95:                      int currPos;
96:                      int reverse;
97:                  
98:                      /* decide where to start iterating from (font or back of the list) */
99:                      if (pos > ((list->size - 1) / 2)) {
9D00B100  00031042   SRL V0, V1, 1
9D00B104  0045102B   SLTU V0, V0, A1
9D00B108  50400009   BEQL V0, ZERO, .LVL4
9D00B10C  8C820004   LW V0, 4(A0)
100:                         reverse = 1;
9D00B114  24040001   ADDIU A0, ZERO, 1
101:                         currPos = list->size - 1;
102:                         currNode = list->last;
9D00B110  8C820008   LW V0, 8(A0)
103:                     } else {
104:                         reverse = 0;
9D00B130  00002021   ADDU A0, ZERO, ZERO
105:                         currPos = 0;
9D00B134  0B402C46   J .LVL3
9D00B138  00001821   ADDU V1, ZERO, ZERO
106:                         currNode = list->first;
107:                     }
108:                 
109:                     while (currNode != NULL) {
9D00B118  10400017   BEQ V0, ZERO, .LVL11
9D00B11C  00000000   NOP
9D00B15C  1440FFF7   BNE V0, ZERO, .LVL6
9D00B160  00000000   NOP
9D00B164  03E00008   JR RA
9D00B168  00000000   NOP
110:                         if (currPos == pos)
9D00B120  14A30008   BNE A1, V1, 0x9D00B144
9D00B124  00000000   NOP
9D00B128  03E00008   JR RA
9D00B12C  00000000   NOP
9D00B13C  1065000E   BEQ V1, A1, .LVL11
9D00B140  00000000   NOP
111:                             break;
112:                 
113:                         currNode = (reverse ? (currNode->prev) : (currNode->next));
9D00B144  50800004   BEQL A0, ZERO, .LVL8
9D00B148  8C420008   LW V0, 8(V0)
9D00B14C  8C420004   LW V0, 4(V0)
9D00B150  0B402C57   J 0x9D00B15C
9D00B154  2463FFFF   ADDIU V1, V1, -1
114:                         currPos = (reverse ? (currPos - 1) : (currPos + 1));
9D00B158  24630001   ADDIU V1, V1, 1
115:                     }
116:                     return currNode;
117:                 }
9D00B178  03E00008   JR RA
118:                 
119:                 /*
120:                  * Add new element add an arbitray position
121:                  * in:        pointer to list
122:                  * in:        pointer to data
123:                  * in:        position
124:                  * returns:   0 on success, -1 on failure
125:                  */
126:                 int LL_add(LL_t *list, void *data, int pos) {
00000000  00000000   NOP
127:                     if (pos > list->size || pos < 0)
00000018  00000000   NOP
128:                         return C_NOK;
129:                 
130:                     LL_node_t *newNode;
131:                     LL_node_t *currNode;
132:                 
133:                     /* Create the new node */
134:                     newNode = LL_initNode(data);
00000030  00000000   NOP
135:                 
136:                     /* if list is empty */
137:                     if (list->size == 0) {
0000003C  00000000   NOP
138:                         list->first = newNode;
00000048  00000000   NOP
139:                         list->last = newNode;
0000004C  00000000   NOP
140:                 
141:                         list->size++;
00000050  00000000   NOP
142:                         return C_OK;
00000054  00000000   NOP
143:                     }
144:                 
145:                     /* if list is not empty */
146:                     currNode = LL_findNode(list, pos);
0000005C  00000000   NOP
147:                 
148:                     /* adding at the front or in the middle */
149:                     if (currNode != NULL) {
00000068  00000000   NOP
150:                         newNode->prev = currNode->prev;
00000070  00000000   NOP
151:                         newNode->next = currNode;
00000078  00000000   NOP
152:                 
153:                         if (currNode->prev == NULL)
0000007C  00000000   NOP
154:                             list->first = newNode;
155:                         else
156:                             currNode->prev->next = newNode;
157:                 
158:                         currNode->prev = newNode;
159:                     } else { /* adding at the end */
160:                         list->last->next = newNode;
00000094  00000000   NOP
161:                         newNode->prev = list->last;
00000098  00000000   NOP
162:                         list->last = newNode;
000000A0  00000000   NOP
163:                     }
164:                     list->size++;
000000A4  00000000   NOP
165:                     return C_OK;
000000B0  00000000   NOP
166:                 }
000000BC  00000000   NOP
167:                 
168:                 /*
169:                  * replace data of node at pos with new data
170:                  * in:        pointer to list
171:                  * in:        pointer to data
172:                  * in:        position in list
173:                  * returns:   data previously stored at pos
174:                  */
175:                 void *LL_set(LL_t *list, void *data, int pos) {
00000000  00000000   NOP
176:                     LL_node_t *currNode = LL_findNode(list, pos);
00000010  00000000   NOP
177:                 
178:                     if (currNode == NULL)
00000018  00000000   NOP
179:                         return NULL;
180:                 
181:                     void *oldData = currNode->data;
00000020  00000000   NOP
182:                     currNode->data = data;
00000024  00000000   NOP
183:                 
184:                     return oldData;
185:                 }
0000002C  00000000   NOP
186:                 
187:                 /*
188:                  * add element to front of list
189:                  * in:        pointer to list
190:                  * in:        pointer to data
191:                  * returns:   0 on success, -1 on failure
192:                  */
193:                 int LL_push(LL_t *list, void *data) {
00000000  00000000   NOP
194:                     LL_node_t *newNode = LL_initNode(data);
00000010  00000000   NOP
195:                 
196:                     /* if list is empty */
197:                     if (list->size == 0) {
00000018  00000000   NOP
198:                         list->last = newNode;
199:                     } else {
200:                         /* if there is at least one element */
201:                         list->first->prev = newNode;
0000002C  00000000   NOP
202:                         newNode->next = list->first;
00000030  00000000   NOP
203:                     }
204:                     list->first = newNode;
00000038  00000000   NOP
205:                     list->size++;
0000003C  00000000   NOP
206:                     return C_OK;
207:                 }
00000048  00000000   NOP
208:                 
209:                 /*
210:                  * add element to end of list
211:                  * in:        pointer to list
212:                  * in:        pointer to data
213:                  * returns:   0 on success, -1 on failure
214:                  */
215:                 int LL_pushBack(LL_t *list, void *data) {
9D00BC10  27BDFFE8   ADDIU SP, SP, -24
9D00BC14  AFBF0014   SW RA, 20(SP)
9D00BC18  AFB00010   SW S0, 16(SP)
9D00BC1C  00808021   ADDU S0, A0, ZERO
216:                     /* initialize new node */
217:                     LL_node_t *newNode = LL_initNode(data);
9D00BC20  0F40316E   JAL .LFE2, .LFB1, LL_initNode, .LVL12
9D00BC24  00A02021   ADDU A0, A1, ZERO
218:                 
219:                     /* if list is empty */
220:                     if (list->size == 0) {
9D00BC28  8E030000   LW V1, 0(S0)
9D00BC2C  54600003   BNEL V1, ZERO, 0x9D00BC3C
9D00BC30  8E030008   LW V1, 8(S0)
9D00BC34  0B402F12   J 0x9D00BC48
9D00BC38  AE020004   SW V0, 4(S0)
221:                         list->first = newNode;
222:                     } else {
223:                         /* if there is at least one element */
224:                         list->last->next = newNode;
9D00BC3C  AC620008   SW V0, 8(V1)
225:                         newNode->prev = list->last;
9D00BC40  8E030008   LW V1, 8(S0)
9D00BC44  AC430004   SW V1, 4(V0)
226:                     }
227:                     list->last = newNode;
9D00BC48  AE020008   SW V0, 8(S0)
228:                     list->size++;
9D00BC4C  8E020000   LW V0, 0(S0)
9D00BC50  24420001   ADDIU V0, V0, 1
9D00BC54  AE020000   SW V0, 0(S0)
229:                     return C_OK;
230:                 }
9D00BC58  00001021   ADDU V0, ZERO, ZERO
231:                 
232:                 /*
233:                  * remove from an arbitrary position
234:                  * in:        pointer to list
235:                  * in:        pointer to data
236:                  * returns:   0 on success, -1 on failure
237:                  */
238:                 void *LL_remove(LL_t *list, int pos) {
9D00B3C8  27BDFFE0   ADDIU SP, SP, -32
9D00B3CC  AFBF001C   SW RA, 28(SP)
9D00B3D0  AFB10018   SW S1, 24(SP)
9D00B3D4  AFB00014   SW S0, 20(SP)
239:                     LL_node_t *currNode = LL_findNode(list, pos);
9D00B3D8  0F402C3A   JAL .LFB5, LL_findNode, .LVL0, .LFE0
9D00B3DC  00808021   ADDU S0, A0, ZERO
240:                     void *data = NULL;
241:                 
242:                     if (currNode == NULL)
9D00B3E0  50400016   BEQL V0, ZERO, .LVL55
9D00B3E4  00001021   ADDU V0, ZERO, ZERO
243:                         return NULL;
244:                 
245:                     data = currNode->data;
246:                 
247:                     if (currNode->prev == NULL)
9D00B3E8  8C430004   LW V1, 4(V0)
9D00B3EC  14600004   BNE V1, ZERO, 0x9D00B400
9D00B3F0  8C510000   LW S1, 0(V0)
248:                         list->first = currNode->next;
9D00B3F4  8C430008   LW V1, 8(V0)
9D00B3F8  0B402D02   J 0x9D00B408
9D00B3FC  AE030004   SW V1, 4(S0)
249:                     else
250:                         currNode->prev->next = currNode->next;
9D00B400  8C440008   LW A0, 8(V0)
9D00B404  AC640008   SW A0, 8(V1)
251:                 
252:                     if (currNode->next == NULL)
9D00B408  8C430008   LW V1, 8(V0)
9D00B40C  54600004   BNEL V1, ZERO, 0x9D00B420
9D00B410  8C440004   LW A0, 4(V0)
253:                         list->last = currNode->prev;
9D00B414  8C430004   LW V1, 4(V0)
9D00B418  0B402D09   J 0x9D00B424
9D00B41C  AE030008   SW V1, 8(S0)
254:                     else
255:                         currNode->next->prev = currNode->prev;
9D00B420  AC640004   SW A0, 4(V1)
256:                 
257:                     list->size--;
9D00B424  8E030000   LW V1, 0(S0)
9D00B428  2463FFFF   ADDIU V1, V1, -1
9D00B42C  AE030000   SW V1, 0(S0)
258:                     free(currNode);
9D00B430  0F4031CD   JAL .LFB1, free
9D00B434  00402021   ADDU A0, V0, ZERO
9D00B438  02201021   ADDU V0, S1, ZERO
259:                     return data;
260:                 }
9D00B43C  8FBF001C   LW RA, 28(SP)
261:                 
262:                 /*
263:                  * remove the head of the list and return its value
264:                  * in:        pointer to list
265:                  * returns:   pointer to data of first node/NULL if empty
266:                  */
267:                 void *LL_pop(LL_t *list) {
9D00BD34  27BDFFE8   ADDIU SP, SP, -24
9D00BD38  AFBF0014   SW RA, 20(SP)
9D00BD3C  AFB00010   SW S0, 16(SP)
268:                     if (!list)
9D00BD20  1080000D   BEQ A0, ZERO, .LVL62, .LCFI18
9D00BD24  00000000   NOP
269:                         return NULL;
9D00BD58  03E00008   JR RA
9D00BD5C  00001021   ADDU V0, ZERO, ZERO
270:                 
271:                     LL_node_t *node = list->first;
9D00BD28  8C820004   LW V0, 4(A0)
272:                     if (node == NULL)
9D00BD2C  1040000C   BEQ V0, ZERO, .LVL63
9D00BD30  00000000   NOP
273:                         return NULL;
9D00BD60  03E00008   JR RA
9D00BD64  00001021   ADDU V0, ZERO, ZERO
274:                 
275:                     void *data = node->data;
9D00BD40  8C500000   LW S0, 0(V0)
276:                 
277:                     if (LL_remove(list, 0) == NULL)
9D00BD44  0F402CF2   JAL LL_remove
9D00BD48  00002821   ADDU A1, ZERO, ZERO
278:                         return NULL;
279:                 
280:                     return data;
9D00BD4C  0002800A   MOVZ S0, ZERO, V0
9D00BD50  0B402F5A   J .LVL64, .LCFI19
9D00BD54  02001021   ADDU V0, S0, ZERO
281:                 }
9D00BD68  8FBF0014   LW RA, 20(SP)
282:                 
283:                 /*
284:                  * remove the tail of the list and return its value
285:                  * in:        pointer to list
286:                  * returns:   pointer to data of last node/NULL if empty
287:                  */
288:                 void *LL_popBack(LL_t *list) {
0000000C  00000000   NOP
289:                     LL_node_t *node = list->last;
00000000  00000000   NOP
290:                     if (node == NULL)
00000004  00000000   NOP
291:                         return NULL;
00000034  00000000   NOP
292:                 
293:                     void *data = node->data;
00000018  00000000   NOP
294:                 
295:                     if (LL_remove(list, (list->size - 1)) == NULL)
0000001C  00000000   NOP
296:                         return NULL;
297:                 
298:                     return data;
00000028  00000000   NOP
299:                 }
0000003C  00000000   NOP
300:                 
301:                 /*
302:                  * iterates over the entire list from the beginning and 
303:                  * calls the specified function with with each element.
304:                  * in:        pointer to list
305:                  * in:        pointer to function
306:                  *            ** function must be of return type void and
307:                  *            ** take void pointer as parameter
308:                  */
309:                 void LL_each(LL_t *list, void (*f)(void *)) {
00000000  00000000   NOP
310:                     LL_node_t *currNode = list->first;
00000010  00000000   NOP
311:                 
312:                     while (currNode != NULL) {
00000014  00000000   NOP
00000028  00000000   NOP
313:                         (*f)(currNode->data);
0000001C  00000000   NOP
314:                         currNode = currNode->next;
00000024  00000000   NOP
315:                     }
316:                 }
00000030  00000000   NOP
317:                 
318:                 /*
319:                  * iterates over the entire list from the end and
320:                  * calls the specified function with each element.
321:                  * in:        pointer to list
322:                  * in:        pointer to function
323:                  *            ** function must be of return type void and
324:                  *            ** take void pointer as parameter
325:                  */
326:                 void LL_eachReverse(LL_t *list, void (*f)(void *)) {
00000000  00000000   NOP
327:                     LL_node_t *currNode = list->last;
00000010  00000000   NOP
328:                 
329:                     while (currNode != NULL) {
00000014  00000000   NOP
00000028  00000000   NOP
330:                         (*f)(currNode->data);
0000001C  00000000   NOP
331:                         currNode = currNode->prev;
00000024  00000000   NOP
332:                     }
333:                 }
00000030  00000000   NOP
334:                 
335:                 /*
336:                  * destroys the list and allocates a new (empty)
337:                  * in its memory location
338:                  * in:        pointer to list
339:                  */
340:                 void LL_clear(LL_t *list) {
00000000  00000000   NOP
341:                     LL_node_t *currNode = list->first;
00000014  00000000   NOP
342:                     LL_node_t *nextNode;
343:                 
344:                     while (currNode != NULL) {
00000018  00000000   NOP
00000028  00000000   NOP
345:                         nextNode = currNode->next;
346:                         free(currNode);
00000020  00000000   NOP
347:                         currNode = nextNode;
348:                     }
349:                 
350:                     list->first = NULL;
00000030  00000000   NOP
351:                     list->last = NULL;
00000034  00000000   NOP
352:                     list->size = 0;
00000038  00000000   NOP
353:                 }
0000003C  00000000   NOP
354:                 
355:                 /*
356:                  * destroys a list and frees all list related memory
357:                  * Does not touch the data stored at the nodes!
358:                  * in:        pointer to list
359:                  */
360:                 void LL_destroy(LL_t *list) {
00000000  00000000   NOP
361:                     LL_node_t *currNode = list->first;
00000014  00000000   NOP
362:                     LL_node_t *nextNode;
363:                     //void *data = currNode->data;
364:                     while (currNode != NULL) {
00000018  00000000   NOP
00000028  00000000   NOP
365:                         nextNode = currNode->next;
366:                         //free(data);
367:                         free(currNode);
00000020  00000000   NOP
368:                         currNode = nextNode;
369:                     }
370:                     free(list);
00000030  00000000   NOP
371:                 }
00000038  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/fasttransfer.c  ---
1:                   #include "FastTransfer.h"
2:                   
3:                   #define FT_START_BYTE_1 0x06
4:                   #define FT_START_BYTE_2 0x85
5:                   
6:                   #define polynomial 0x8C  //polynomial used to calculate crc
7:                   #define CRC_COUNT 5 // how many AKNAKs are stored
8:                   #define CRC_DEPTH 3  // how many pieces of data are stored with each CRC send event
9:                   #define CRC_BUFFER_SIZE (CRC_COUNT * CRC_DEPTH) //crc buffer size 5 deep and 3 bytes an entry
10:                  //*****************Receive******************************************************
11:                  unsigned char rx_buffer[255]; //address for temporary storage and parsing buffer
12:                  unsigned char rx_array_inx; //index for RX parsing buffer
13:                  unsigned char rx_len = 0; //RX packet length according to the packet
14:                  unsigned char calc_CS; //calculated Checksum
15:                  unsigned char moduleAddress; // the address of this module
16:                  unsigned char returnAddress; //the address to send the crc back to
17:                  unsigned char maxDataAddress; //max address allowable
18:                  short * receiveArrayAddress; // this is where the data will go when it is received
19:                  unsigned char * sendStructAddress; // this is where the data will be sent from
20:                  bool AKNAKsend; // turns the acknowledged or not acknowledged on/off
21:                  unsigned int alignErrorCounter; //counts the align errors
22:                  unsigned int crcErrorCounter; // counts any failed crcs
23:                  unsigned int addressErrorCounter; // counts every time a wrong address is received
24:                  unsigned int dataAdressErrorCounter; // counts if the received data fall outside of the receive array
25:                  unsigned char rx_address; //RX address received
26:                  
27:                  struct crcBufS
28:                  { // this is where the address where sent to, the sent crc, the status of the AKNAK
29:                      unsigned char buf[CRC_BUFFER_SIZE];
30:                      int head;
31:                  };
32:                  struct crcBufS crc_buffer;
33:                  
34:                  unsigned char crcBufS_get(struct crcBufS* _this, unsigned char time, unsigned char space);
35:                  unsigned int FastTransfer_buffer_modulo_inc(const unsigned int value, const unsigned int modulus);
36:                  void FastTransfer_buffer_put(FastTransfer_t *_this, unsigned char towhere, unsigned int towhat);
37:                  unsigned char CRC8(const unsigned char * data, unsigned char len);
38:                  unsigned char _peek(FastTransfer_t *_FTobject);
39:                  int _available(FastTransfer_t *_FTobject);
40:                  unsigned char _get(FastTransfer_t* _FTobject);
41:                  unsigned char CRC8(const unsigned char * data, unsigned char len);
42:                  unsigned char AKNAK(unsigned char module);
43:                  unsigned int alignError(void);
44:                  unsigned int CRCError(void);
45:                  unsigned int addressError(void);
46:                  unsigned int dataAddressError(void);
47:                  void crcBufS_put(struct crcBufS* _this, unsigned char address, unsigned char oldCRC, unsigned char status);
48:                  void crcBufS_status_put(struct crcBufS* _this, unsigned char time, unsigned char status);
49:                  void CRCcheck(FastTransfer_t * _this);
50:                  
51:                  
52:                  void InitFastTransferModule(FastTransfer_t* _this,SYS_MODULE_INDEX _uartModule, int _myAddress,  void (*_writeData)(UART_Object_t* _TXobject, unsigned char _data), unsigned char (*_readData)(RingBuffer_t*),int (*_isAvailable)(RingBuffer_t*), unsigned char (*_dataPeek)(RingBuffer_t*))
53:                  {
9D00B764  27BDFFE0   ADDIU SP, SP, -32
9D00B768  AFBF001C   SW RA, 28(SP)
9D00B76C  AFB10018   SW S1, 24(SP)
9D00B770  AFB00014   SW S0, 20(SP)
9D00B774  00808021   ADDU S0, A0, ZERO
9D00B778  00A08821   ADDU S1, A1, ZERO
54:                      
55:                      _this->COMdriver.uartTXModule   = _uartModule;
9D00B77C  A6050062   SH A1, 98(S0)
56:                      _this->COMdriver.uartRXModule   = _uartModule;
9D00B780  A6050060   SH A1, 96(S0)
57:                      _this->ModuleADDRESS            = _myAddress;
9D00B784  AC860000   SW A2, 0(A0)
58:                      
59:                      _this->serial_write             = _writeData;
9D00B788  AC870070   SW A3, 112(A0)
60:                      _this->serial_read              = _readData;
9D00B78C  8FA20030   LW V0, 48(SP)
9D00B790  AC820074   SW V0, 116(A0)
61:                      _this->serial_available         = _isAvailable;
9D00B794  8FA20034   LW V0, 52(SP)
9D00B798  AC820078   SW V0, 120(A0)
62:                      _this->serial_peek              = _dataPeek;
9D00B79C  8FA20038   LW V0, 56(SP)
9D00B7A0  AC82007C   SW V0, 124(A0)
63:                     
64:                      _this->DataBuffer = createRingBuffer(_this->DataBuffer, BUFFER_SIZE);
9D00B7A4  8C840004   LW A0, 4(A0)
9D00B7A8  0F400044   JAL createRingBuffer
9D00B7AC  24050100   ADDIU A1, ZERO, 256
9D00B7B0  AE020004   SW V0, 4(S0)
65:                     
66:                      //this is to keep FT library similar to Legacy library
67:                      maxDataAddress                  = sizeof(_this->ReceivedData);
9D00B7B4  24020028   ADDIU V0, ZERO, 40
9D00B7B8  A3828129   SB V0, -32471(GP)
68:                      receiveArrayAddress             = _this->ReceivedData;
9D00B7BC  26020008   ADDIU V0, S0, 8
9D00B7C0  AF828134   SW V0, -32460(GP)
69:                     
70:                      InitUARTModule(&_this->COMdriver, _uartModule);
9D00B7C4  26040048   ADDIU A0, S0, 72
9D00B7C8  0F402C86   JAL InitUARTModule
9D00B7CC  02202821   ADDU A1, S1, ZERO
71:                  }
9D00B7D0  8FBF001C   LW RA, 28(SP)
72:                  void CloseFastTransferModule(FastTransfer_t* _this)
73:                  {
00000000  00000000   NOP
74:                      if(_this->COMdriver.uartTXHandle == _this->COMdriver.uartRXHandle)
00000010  00000000   NOP
75:                      {
76:                          //doesn't have to be the tx handle i just randomly pick on since they are the same
77:                          DRV_USART_Close(_this->COMdriver.uartTXHandle);
00000020  00000000   NOP
78:                      }
79:                      else
80:                      {
81:                          DRV_USART_Close(_this->COMdriver.uartTXHandle);
00000030  00000000   NOP
82:                          DRV_USART_Close(_this->COMdriver.uartRXHandle);
00000038  00000000   NOP
83:                      }
84:                  }
00000040  00000000   NOP
85:                  
86:                  bool isFTFlagSet(FastTransfer_t *_this, unsigned char index)
87:                  {
88:                      return _this->ReceivedDataFlags[index];
00000000  00000000   NOP
89:                  }
00000004  00000000   NOP
90:                  int16_t getFTReceivedData(FastTransfer_t *_this, unsigned char index)
91:                  {
92:                      _this->ReceivedDataFlags[index] = false;
00000000  00000000   NOP
93:                      return _this->ReceivedData[index];
00000008  00000000   NOP
94:                  }
00000010  00000000   NOP
95:                  void ToSend(FastTransfer_t *_this,short _address, int _data)
96:                  {
00000000  00000000   NOP
97:                      FastTransfer_buffer_put(_this, _address, _data);
00000008  00000000   NOP
98:                  }
00000010  00000000   NOP
99:                  
100:                 bool sendData(FastTransfer_t *_FTobject, unsigned char whereToSend)
101:                 {
00000000  00000000   NOP
102:                 
103:                     //calculate the crc
104:                     unsigned char CS = CRC8(_FTobject->DataBuffer->buf, _FTobject->DataBuffer->count);
00000020  00000000   NOP
105:                 
106:                     _FTobject->serial_write(&_FTobject->COMdriver,FT_START_BYTE_1); //start address
00000034  00000000   NOP
107:                     _FTobject->serial_write(&_FTobject->COMdriver,FT_START_BYTE_2); //start address
00000048  00000000   NOP
108:                     _FTobject->serial_write(&_FTobject->COMdriver,whereToSend);
00000058  00000000   NOP
109:                     _FTobject->serial_write(&_FTobject->COMdriver,_FTobject->ModuleADDRESS);
00000068  00000000   NOP
110:                     _FTobject->serial_write(&_FTobject->COMdriver,_FTobject->DataBuffer->count); //length of packet not including the crc
00000078  00000000   NOP
111:                 
112:                 
113:                     //send the rest of the packet
114:                     int i;
115:                     for (i = 0; i < _FTobject->DataBuffer->count; i++)
0000008C  00000000   NOP
000000B0  00000000   NOP
116:                     {
117:                         _FTobject->serial_write(&_FTobject->COMdriver,*(_FTobject->DataBuffer->buf + i));
0000009C  00000000   NOP
118:                     }
119:                 
120:                     //send the crc
121:                     _FTobject->serial_write(&_FTobject->COMdriver, CS);
000000C8  00000000   NOP
122:                 
123:                     //record the sent message data for aknak check later
124:                     //crcBufS_put(&crc_buffer, whereToSend, CS, 0);
125:                     
126:                     // clears the buffer after a sending
127:                     Buffer_Wipe(_FTobject->DataBuffer);
000000D8  00000000   NOP
128:                     return true;
129:                 }
000000E0  00000000   NOP
130:                 
131:                  void FastTransfer_buffer_put(FastTransfer_t *_this, unsigned char towhere, unsigned int towhat)
132:                 {
133:                 
134:                     group.integer = towhat;
00000000  00000000   NOP
135:                 
136:                     if (_this->DataBuffer->count < (BUFFER_SIZE - 3))
00000004  00000000   NOP
137:                     {
138:                         _this->DataBuffer->buf[_this->DataBuffer->head] = towhere;
00000018  00000000   NOP
139:                         _this->DataBuffer->head = FastTransfer_buffer_modulo_inc(_this->DataBuffer->head, BUFFER_SIZE);
00000028  00000000   NOP
0000003C  00000000   NOP
140:                         ++_this->DataBuffer->count;
00000040  00000000   NOP
141:                         _this->DataBuffer->buf[_this->DataBuffer->head] = group.parts[0];
00000050  00000000   NOP
142:                         _this->DataBuffer->head = FastTransfer_buffer_modulo_inc(_this->DataBuffer->head, BUFFER_SIZE);
00000068  00000000   NOP
0000007C  00000000   NOP
143:                         ++_this->DataBuffer->count;
00000080  00000000   NOP
144:                         _this->DataBuffer->buf[_this->DataBuffer->head] = group.parts[1];
00000090  00000000   NOP
145:                         _this->DataBuffer->head = FastTransfer_buffer_modulo_inc(_this->DataBuffer->head, BUFFER_SIZE);
000000A8  00000000   NOP
000000BC  00000000   NOP
146:                         ++_this->DataBuffer->count;
000000C0  00000000   NOP
147:                 
148:                     }
149:                 
150:                 }
151:                  unsigned int FastTransfer_buffer_modulo_inc(const unsigned int value, const unsigned int modulus)
152:                 {
153:                     unsigned int my_value = value + 1;
00000000  00000000   NOP
0000002C  00000000   NOP
0000006C  00000000   NOP
000000AC  00000000   NOP
154:                     if (my_value >= modulus)
00000004  00000000   NOP
00000034  00000000   NOP
00000074  00000000   NOP
000000B4  00000000   NOP
155:                     {
156:                         my_value = 0;
00000038  00000000   NOP
00000078  00000000   NOP
000000B8  00000000   NOP
157:                     }
158:                     return (my_value);
159:                 }
00000008  00000000   NOP
160:                 
161:                 bool receiveData(FastTransfer_t *_this)
162:                 {
9D0046B8  27BDFFE0   ADDIU SP, SP, -32
9D0046BC  AFBF001C   SW RA, 28(SP)
9D0046C0  AFB20018   SW S2, 24(SP)
9D0046C4  AFB10014   SW S1, 20(SP)
9D0046C8  AFB00010   SW S0, 16(SP)
163:                   
164:                 
165:                     //start off by looking for the header bytes. If they were already found in a previous call, skip it.
166:                     if (rx_len == 0)
9D0046CC  93828080   LBU V0, -32640(GP)
9D0046D0  1440003E   BNE V0, ZERO, 0x9D0047CC
9D0046D4  00808021   ADDU S0, A0, ZERO
167:                     {
168:                         //this size check may be redundant due to the size check below, but for now I'll leave it the way it is.
169:                         if (_this->serial_available(_this->COMdriver.RxBuffer) > 8)
9D0046D8  8C820078   LW V0, 120(A0)
9D0046DC  0040F809   JALR V0
9D0046E0  8C840048   LW A0, 72(A0)
9D0046E4  28420009   SLTI V0, V0, 9
9D0046E8  1040000B   BEQ V0, ZERO, 0x9D004718
9D0046EC  24110006   ADDIU S1, ZERO, 6
9D0046F0  0B4011F1   J 0x9D0047C4
9D0046F4  93838080   LBU V1, -32640(GP)
170:                         {
171:                             
172:                             //this will block until a 0x06 is found or buffer size becomes less then 3.
173:                             while (_this->serial_read(_this->COMdriver.RxBuffer) != 0x06)
9D004718  8E020074   LW V0, 116(S0)
9D00471C  0040F809   JALR V0
9D004720  8E040048   LW A0, 72(S0)
9D004724  1451FFF4   BNE V0, S1, 0x9D0046F8
9D004728  8F828138   LW V0, -32456(GP)
174:                             {
175:                                 //This will trash any preamble junk in the serial buffer
176:                                 //but we need to make sure there is enough in the buffer to process while we trash the rest
177:                                 //if the buffer becomes too empty, we will escape and try again on the next call
178:                                 alignErrorCounter++; //increments the counter whenever a byte is trashed
9D0046F8  24420001   ADDIU V0, V0, 1
9D0046FC  AF828138   SW V0, -32456(GP)
179:                                 if (_this->serial_available(_this->COMdriver.RxBuffer) < 5)
9D004700  8E020078   LW V0, 120(S0)
9D004704  0040F809   JALR V0
9D004708  8E040048   LW A0, 72(S0)
9D00470C  28420005   SLTI V0, V0, 5
9D004710  14400088   BNE V0, ZERO, 0x9D004934
9D004714  00001021   ADDU V0, ZERO, ZERO
180:                                     return false;
181:                             }
182:                             if (_this->serial_read(_this->COMdriver.RxBuffer) == 0x85)
9D00472C  8E020074   LW V0, 116(S0)
9D004730  0040F809   JALR V0
9D004734  8E040048   LW A0, 72(S0)
9D004738  24030085   ADDIU V1, ZERO, 133
9D00473C  14430021   BNE V0, V1, 0x9D0047C4
9D004740  93838080   LBU V1, -32640(GP)
183:                             {
184:                                 rx_address = _this->serial_read(_this->COMdriver.RxBuffer); // pulls the address
9D004744  8E020074   LW V0, 116(S0)
9D004748  0040F809   JALR V0
9D00474C  8E040048   LW A0, 72(S0)
9D004750  A3828144   SB V0, -32444(GP)
185:                                 returnAddress = _this->serial_read(_this->COMdriver.RxBuffer); // pulls where the message came from
9D004754  8E020074   LW V0, 116(S0)
9D004758  0040F809   JALR V0
9D00475C  8E040048   LW A0, 72(S0)
9D004760  A382813D   SB V0, -32451(GP)
186:                                 rx_len = _this->serial_read(_this->COMdriver.RxBuffer); // pulls the length
9D004764  8E020074   LW V0, 116(S0)
9D004768  0040F809   JALR V0
9D00476C  8E040048   LW A0, 72(S0)
9D004770  A3828080   SB V0, -32640(GP)
187:                                
188:                                                
189:                                 //make sure the address received is a match for this module if not throw the packet away
190:                               
191:                                 if (rx_address != _this->ModuleADDRESS)
9D004774  93838144   LBU V1, -32444(GP)
9D004778  8E020000   LW V0, 0(S0)
9D00477C  10620010   BEQ V1, V0, .LVL139, .LBE17
9D004780  00008821   ADDU S1, ZERO, ZERO
192:                                 {
193:                                     addressErrorCounter++; // increments a counter whenever the wrong address is received
9D004784  8F828140   LW V0, -32448(GP)
9D004788  24420001   ADDIU V0, V0, 1
9D00478C  AF828140   SW V0, -32448(GP)
194:                                     //if the address does not match the buffer is flushed for the size of
195:                                     //the data packet plus one for the CRC
196:                                     int u;
197:                                     for (u = 0; u <= (rx_len + 1); u++)
9D00479C  26310001   ADDIU S1, S1, 1
9D0047A0  93828080   LBU V0, -32640(GP)
9D0047A4  24420001   ADDIU V0, V0, 1
9D0047A8  0051102A   SLT V0, V0, S1
9D0047AC  5040FFF9   BEQL V0, ZERO, 0x9D004794
9D0047B0  8E020074   LW V0, 116(S0)
198:                                     {
199:                                         _this->serial_read(_this->COMdriver.RxBuffer);
9D004790  8E020074   LW V0, 116(S0)
9D004794  0040F809   JALR V0
9D004798  8E040048   LW A0, 72(S0)
200:                                     }
201:                                     rx_len = 0; // reset length
9D0047B4  A3808080   SB ZERO, -32640(GP)
202:                                     return false;
9D0047B8  0B40124D   J 0x9D004934
9D0047BC  00001021   ADDU V0, ZERO, ZERO
203:                                 }
204:                                 // if the address matches the a dynamic buffer is created to store the received data
205:                                 //rx_buffer = (unsigned char*) malloc(rx_len + 1);
206:                             }
207:                         }
208:                     }
209:                 
210:                     //we get here if we already found the header bytes, the address matched what we know, and now we are byte aligned.
211:                     if (rx_len != 0)
9D0047C0  93838080   LBU V1, -32640(GP)
9D0047C4  1060005B   BEQ V1, ZERO, 0x9D004934
9D0047C8  00001021   ADDU V0, ZERO, ZERO
212:                     {
213:                         //DRV_USART0_WriteByte(0xFC);
214:                         //this check is preformed to see if the first data address is a 255, if it is then this packet is an AKNAK
215:                         if (rx_array_inx == 0)
9D0047CC  9382813E   LBU V0, -32450(GP)
9D0047D0  50400004   BEQL V0, ZERO, 0x9D0047E4
9D0047D4  8E020078   LW V0, 120(S0)
216:                         {
217:                             while (!(_this->serial_available(_this->COMdriver.RxBuffer) >= 1));
9D0047E4  0040F809   JALR V0
9D0047E8  8E040048   LW A0, 72(S0)
9D0047EC  5840FFFD   BLEZL V0, 0x9D0047E4
9D0047F0  8E020078   LW V0, 120(S0)
218:                             if (255 == _this->serial_peek(_this->COMdriver.RxBuffer))
9D0047F4  8E02007C   LW V0, 124(S0)
9D0047F8  0040F809   JALR V0
9D0047FC  8E040048   LW A0, 72(S0)
9D004800  240300FF   ADDIU V1, ZERO, 255
9D004804  1443FFF5   BNE V0, V1, 0x9D0047DC
9D004808  3C128000   LUI S2, -32768
219:                             {
220:                                 CRCcheck(_this);
9D00480C  0F4023A5   JAL CRCcheck
9D004810  02002021   ADDU A0, S0, ZERO
221:                                 rx_len = 0;
9D004814  A3808080   SB ZERO, -32640(GP)
222:                                 rx_array_inx = 0;
9D004818  A380813E   SB ZERO, -32450(GP)
223:                                 //free(rx_buffer);
224:                                 
225:                                 //Buffer_Wipe(rx_buffer,255);
226:                                 return receiveData(_this);
9D00481C  0F4011AE   JAL receiveData
9D004820  02002021   ADDU A0, S0, ZERO
9D004824  0B40124E   J 0x9D004938
9D004828  8FBF001C   LW RA, 28(SP)
227:                             }
228:                         }
229:                 
230:                         
231:                         while ((_this->serial_available(_this->COMdriver.RxBuffer)) > 0 && ( rx_array_inx <= rx_len))//(serial_available() > 0) &&( rx_array_inx <= rx_len))
9D004844  8E020078   LW V0, 120(S0)
9D004848  0040F809   JALR V0
9D00484C  8E040048   LW A0, 72(S0)
9D004850  18400005   BLEZ V0, 0x9D004868
9D004854  9391813E   LBU S1, -32450(GP)
9D004858  93828080   LBU V0, -32640(GP)
9D00485C  0051102B   SLTU V0, V0, S1
9D004860  5040FFF2   BEQL V0, ZERO, 0x9D00482C
9D004864  26220001   ADDIU V0, S1, 1
232:                         {  
233:                              rx_buffer[rx_array_inx++] = _this->serial_read(_this->COMdriver.RxBuffer);
9D0047D8  3C128000   LUI S2, -32768
9D0047DC  0B401211   J 0x9D004844
9D0047E0  2652578C   ADDIU S2, S2, 22412
9D00482C  A382813E   SB V0, -32450(GP)
9D004830  8E020074   LW V0, 116(S0)
9D004834  0040F809   JALR V0
9D004838  8E040048   LW A0, 72(S0)
9D00483C  02328821   ADDU S1, S1, S2
9D004840  A2220000   SB V0, 0(S1)
234:                               
235:                         }
236:                 
237:                         if (rx_len == (rx_array_inx - 1))
9D004868  93918080   LBU S1, -32640(GP)
9D00486C  9383813E   LBU V1, -32450(GP)
9D004870  2463FFFF   ADDIU V1, V1, -1
9D004874  1623002F   BNE S1, V1, 0x9D004934
9D004878  00001021   ADDU V0, ZERO, ZERO
238:                         {
239:                             //seem to have got whole message
240:                             //last uint8_t is CS
241:                             calc_CS = CRC8(rx_buffer, rx_len);
9D00487C  3C128000   LUI S2, -32768
9D004880  2644578C   ADDIU A0, S2, 22412
9D004884  0F402F8A   JAL CRC8
9D004888  02202821   ADDU A1, S1, ZERO
9D00488C  A382813C   SB V0, -32452(GP)
242:                 
243:                 
244:                             
245:                             if (calc_CS == rx_buffer[rx_array_inx - 1])
9D004890  2652578C   ADDIU S2, S2, 22412
9D004894  7E51898A   LBUX S1, S1(S2)
9D004898  56220021   BNEL S1, V0, .LBE18
9D00489C  8F82812C   LW V0, -32468(GP)
246:                             {//CS good
247:                 
248:                                 // reassembles the data and places it into the receive array according to data address.
249:                                 int r;
250:                                 for (r = 0; r < rx_len; r = r + 3)
9D0048A0  93868080   LBU A2, -32640(GP)
9D0048A4  18C0001A   BLEZ A2, .LVL150
9D0048A8  8F878120   LW A3, -32480(GP)
9D0048FC  24630003   ADDIU V1, V1, 3
9D004900  0066202A   SLT A0, V1, A2
9D004904  1480FFED   BNE A0, ZERO, .LVL148
9D004908  24420003   ADDIU V0, V0, 3
9D00490C  AF878120   SW A3, -32480(GP)
251:                                 {
252:                                     if (rx_buffer[r] < maxDataAddress)
9D0048AC  93888129   LBU T0, -32471(GP)
9D0048B0  02401021   ADDU V0, S2, ZERO
9D0048B4  00001821   ADDU V1, ZERO, ZERO
9D0048BC  90440000   LBU A0, 0(V0)
9D0048C0  0088282B   SLTU A1, A0, T0
9D0048C4  50A0000D   BEQL A1, ZERO, 0x9D0048FC
9D0048C8  24E70001   ADDIU A3, A3, 1
253:                                     {
254:                                         group.parts[0] = rx_buffer[r + 1];
9D0048CC  90450001   LBU A1, 1(V0)
9D0048D0  A38580C8   SB A1, -32568(GP)
255:                                         group.parts[1] = rx_buffer[r + 2];
9D0048D4  90450002   LBU A1, 2(V0)
9D0048D8  A38580C9   SB A1, -32567(GP)
256:                                         
257:                                         _this->ReceivedData[(rx_buffer[r])] = group.integer;
9D0048DC  24840004   ADDIU A0, A0, 4
9D0048E0  00042040   SLL A0, A0, 1
9D0048E4  02042021   ADDU A0, S0, A0
9D0048E8  978580C8   LHU A1, -32568(GP)
9D0048EC  A4850000   SH A1, 0(A0)
258:                   
259:                                         _this->ReceivedDataFlags[(rx_buffer[r])] = true;
9D0048B8  24090001   ADDIU T1, ZERO, 1
9D0048F0  90440000   LBU A0, 0(V0)
9D0048F4  02042021   ADDU A0, S0, A0
9D0048F8  A0890030   SB T1, 48(A0)
260:                                         
261:                                     } else
262:                                     {
263:                                         dataAdressErrorCounter++;
264:                                     }
265:                                 }
266:                 //TODO: need to Make this fit the new serial_write parameters
267:                 //                if (AKNAKsend)
268:                 //                { // if enabled sends an AK
269:                 //                    unsigned char holder[3];
270:                 //                    holder[0] = 255;
271:                 //                    holder[1] = 1;
272:                 //                    holder[2] = rx_buffer[rx_array_inx - 1];
273:                 //                    unsigned char crcHolder = CRC8(holder, 3);
274:                 //                    _this->serial_write(0x06);
275:                 //                    _this->serial_write(0x85);
276:                 //                    _this->serial_write(returnAddress);
277:                 //                    _this->serial_write(moduleAddress);
278:                 //                    _this->serial_write(3);
279:                 //                    _this->serial_write(255);
280:                 //                    _this->serial_write(1);
281:                 //                    _this->serial_write(rx_buffer[rx_array_inx - 1]);
282:                 //                    _this->serial_write(crcHolder);
283:                 //                }
284:                 
285:                 
286:                                 
287:                                 rx_len = 0;
9D004910  A3808080   SB ZERO, -32640(GP)
288:                                 rx_array_inx = 0;
9D004914  A380813E   SB ZERO, -32450(GP)
289:                                 //free(rx_buffer);
290:                                
291:                                 //Buffer_Wipe(rx_buffer,255);
292:                                 return true;
9D004918  0B40124D   J 0x9D004934
9D00491C  24020001   ADDIU V0, ZERO, 1
293:                             }
294:                             else
295:                             {
296:                                 crcErrorCounter++; //increments the counter every time a crc fails
9D004920  24420001   ADDIU V0, V0, 1
9D004924  AF82812C   SW V0, -32468(GP)
297:                 
298:                 //TODO: need to Make this fit the new serial_write parameters
299:                 //                if (AKNAKsend)
300:                 //                { // if enabled sends NAK
301:                 //                    unsigned char holder[3];
302:                 //                    holder[0] = 255;
303:                 //                    holder[1] = 2;
304:                 //                    holder[2] = rx_buffer[rx_array_inx - 1];
305:                 //                    unsigned char crcHolder = CRC8(holder, 3);
306:                 //                    serial_write(0x06);
307:                 //                    serial_write(0x85);
308:                 //                    serial_write(returnAddress);
309:                 //                    serial_write(moduleAddress);
310:                 //                    serial_write(3);
311:                 //                    serial_write(255);
312:                 //                    serial_write(2);
313:                 //                    serial_write(rx_buffer[rx_array_inx - 1]);
314:                 //                    serial_write(crcHolder);
315:                 //                }
316:                                 
317:                                 //failed checksum, need to clear this out
318:                                 rx_len = 0;
9D004928  A3808080   SB ZERO, -32640(GP)
319:                                 rx_array_inx = 0;
9D00492C  A380813E   SB ZERO, -32450(GP)
9D004930  00001021   ADDU V0, ZERO, ZERO
320:                                 //free(rx_buffer);
321:                                 
322:                                // Buffer_Wipe(rx_buffer,255);
323:                                 return false;
324:                             }
325:                         }
326:                     }
327:                     return false;
328:                 }
9D004934  8FBF001C   LW RA, 28(SP)
329:                 /*******************************************************************
330:                  * Use the #define functions to access the data in the Legacy method
331:                  *******************************************************************
332:                  */
333:                 
334:                 //#define Receive_peak(_FT)       _peek(_FT)
335:                 //#define Receive_available(_FT)  _available(_FT)
336:                 //#define Receive_get(_FT)        _get(_FT)
337:                 
338:                 /*******************************************************************
339:                  * Don't use the functions below to access FastTransfer data!!!!
340:                  ******************************************************************/
341:                 unsigned char _peek(FastTransfer_t* _FTobject)
342:                 {
00000000  00000000   NOP
343:                     return _FTobject->serial_peek(_FTobject->COMdriver.RxBuffer);
00000008  00000000   NOP
344:                 }
00000014  00000000   NOP
345:                 
346:                 int _available(FastTransfer_t *_FTobject)
347:                 {
00000000  00000000   NOP
348:                     return _FTobject->serial_available(_FTobject->COMdriver.RxBuffer);
00000008  00000000   NOP
349:                 }
00000014  00000000   NOP
350:                 unsigned char _get(FastTransfer_t* _FTobject)
351:                 {
00000000  00000000   NOP
352:                     return _FTobject->serial_read(_FTobject->COMdriver.RxBuffer);
00000008  00000000   NOP
353:                 }
00000014  00000000   NOP
354:                 /*******************************************************************
355:                  ******************************************************************/
356:                 
357:                 unsigned char CRC8(const unsigned char * data, unsigned char len)
358:                 {
359:                     unsigned char crc = 0x00;
9D00BE28  00001021   ADDU V0, ZERO, ZERO
360:                     while (len--)
9D00BE2C  240900FF   ADDIU T1, ZERO, 255
9D00BE30  0B402F9A   J .LVL60, .LBE14
9D00BE34  2408FF8C   ADDIU T0, ZERO, -116
9D00BE68  24A5FFFF   ADDIU A1, A1, -1
9D00BE6C  30A500FF   ANDI A1, A1, 255
9D00BE70  54A9FFF1   BNEL A1, T1, .LVL53, .LBB14
9D00BE74  90860000   LBU A2, 0(A0)
361:                     {
362:                         unsigned char extract = *data++;
9D00BE38  24030008   ADDIU V1, ZERO, 8
363:                         unsigned char tempI;
364:                         for (tempI = 8; tempI; tempI--)
9D00BE5C  1460FFF7   BNE V1, ZERO, .LVL54, .LBB15
9D00BE60  00063042   SRL A2, A2, 1
9D00BE64  24840001   ADDIU A0, A0, 1
365:                         {
366:                             unsigned char sum = (crc ^ extract) & 0x01;
9D00BE3C  00C23826   XOR A3, A2, V0
9D00BE40  30E70001   ANDI A3, A3, 1
367:                             crc >>= 1;
368:                             if (sum)
9D00BE44  10E00003   BEQ A3, ZERO, .LVL57
9D00BE48  00021042   SRL V0, V0, 1
369:                             {
370:                                 crc ^= polynomial;
9D00BE4C  00481026   XOR V0, V0, T0
9D00BE50  304200FF   ANDI V0, V0, 255
9D00BE54  2463FFFF   ADDIU V1, V1, -1
9D00BE58  306300FF   ANDI V1, V1, 255
371:                             }
372:                             extract >>= 1;
373:                         }
374:                     }
375:                     return crc;
376:                 }
9D00BE78  03E00008   JR RA
377:                 
378:                 
379:                 //searches the buffer for the status of a message that was sent
380:                 
381:                 unsigned char AKNAK(unsigned char module)
382:                 {
00000000  00000000   NOP
383:                     int r;
384:                     for (r = 0; r < CRC_COUNT; r++)
00000020  00000000   NOP
0000002C  00000000   NOP
00000068  00000000   NOP
385:                     {
386:                         if (module == crcBufS_get(&crc_buffer, r, 0))
00000024  00000000   NOP
00000030  00000000   NOP
387:                         {
388:                             return crcBufS_get(&crc_buffer, r, 2);
0000004C  00000000   NOP
389:                         }
390:                     }
391:                     return 4;
00000070  00000000   NOP
392:                 }
00000074  00000000   NOP
393:                 
394:                 
395:                 //returns align error
396:                 
397:                 unsigned int alignError(void)
398:                 {
399:                     return alignErrorCounter;
400:                 }
401:                 
402:                 
403:                 //returns CRC error
404:                 
405:                 unsigned int CRCError(void)
406:                 {
407:                     return crcErrorCounter;
408:                 }
409:                 
410:                 
411:                 //returns address error
412:                 
413:                 unsigned int addressError(void)
414:                 {
415:                     return addressErrorCounter;
416:                 }
417:                 
418:                 unsigned int dataAddressError(void)
419:                 {
420:                     return dataAdressErrorCounter;
421:                 }
422:                 
423:                 // after a packet is sent records the info of that packet
424:                 
425:                 void crcBufS_put(struct crcBufS* _this, unsigned char address, unsigned char oldCRC, unsigned char status)
426:                 {
427:                     _this->buf[_this->head] = address;
00000000  00000000   NOP
428:                     _this->head++;
429:                     _this->buf[_this->head] = oldCRC;
0000000C  00000000   NOP
430:                     _this->head++;
431:                     _this->buf[_this->head] = status;
00000010  00000000   NOP
432:                     _this->head++;
00000014  00000000   NOP
0000001C  00000000   NOP
433:                     if (_this->head >= CRC_BUFFER_SIZE)
00000018  00000000   NOP
434:                     {
435:                         _this->head = 0;
436:                     }
437:                 }
438:                 
439:                 
440:                 // after a Ak or NAK is received that status is stored
441:                 void crcBufS_status_put(struct crcBufS* _this, unsigned char time, unsigned char status)
442:                 {
9D00C15C  00A01021   ADDU V0, A1, ZERO
9D00C160  2CA50005   SLTIU A1, A1, 5
9D00C164  50A00001   BEQL A1, ZERO, .LVL84
9D00C168  24020004   ADDIU V0, ZERO, 4
443:                 
444:                     if (time >= CRC_COUNT)
445:                     {
446:                         time = CRC_COUNT - 1;
447:                     }
448:                     time = time + 1;
9D00C16C  24420001   ADDIU V0, V0, 1
449:                     int wantedTime = time * 3;
9D00C170  304200FF   ANDI V0, V0, 255
9D00C174  00021840   SLL V1, V0, 1
9D00C178  00621021   ADDU V0, V1, V0
450:                     if (wantedTime > _this->head)
9D00C17C  8C830010   LW V1, 16(A0)
9D00C180  0062282A   SLT A1, V1, V0
9D00C184  10A00004   BEQ A1, ZERO, .LVL88
9D00C188  00621023   SUBU V0, V1, V0
451:                     {
452:                         wantedTime = (CRC_BUFFER_SIZE) - (wantedTime - _this->head);
453:                         _this->buf[(wantedTime + 2)] = status;
9D00C18C  00822021   ADDU A0, A0, V0
9D00C190  03E00008   JR RA
9D00C194  A0860011   SB A2, 17(A0)
454:                     } else
455:                     {
456:                         _this->buf[(_this->head - wantedTime) + 2] = status;
9D00C198  00822021   ADDU A0, A0, V0
457:                     }
458:                 }
459:                 
460:                 
461:                 // pulls data from the AKNAK buffer
462:                 
463:                 unsigned char crcBufS_get(struct crcBufS* _this, unsigned char time, unsigned char space)
464:                 {
9D00BAEC  00A01821   ADDU V1, A1, ZERO
9D00BAF0  2CA50005   SLTIU A1, A1, 5
9D00BAF4  50A00001   BEQL A1, ZERO, .LVL92
9D00BAF8  24030004   ADDIU V1, ZERO, 4
9D00BAFC  00C01021   ADDU V0, A2, ZERO
9D00BB00  2CC60003   SLTIU A2, A2, 3
9D00BB04  14C00002   BNE A2, ZERO, .LVL94
9D00BB08  306300FF   ANDI V1, V1, 255
9D00BB0C  24020002   ADDIU V0, ZERO, 2
9D00BB10  304500FF   ANDI A1, V0, 255
465:                     if (time >= CRC_COUNT)
466:                     {
467:                         time = CRC_COUNT - 1;
468:                     }
469:                     if (space >= CRC_DEPTH)
470:                     {
471:                         space = CRC_DEPTH - 1;
472:                     }
473:                     time = time + 1;
9D00BB14  24630001   ADDIU V1, V1, 1
474:                     int wantedTime = time * 3;
9D00BB18  306300FF   ANDI V1, V1, 255
9D00BB1C  00031040   SLL V0, V1, 1
9D00BB20  00431821   ADDU V1, V0, V1
475:                     if (wantedTime > _this->head)
9D00BB24  8C820010   LW V0, 16(A0)
9D00BB28  0043302A   SLT A2, V0, V1
9D00BB2C  10C00005   BEQ A2, ZERO, .LVL101
9D00BB30  00431823   SUBU V1, V0, V1
476:                     {
477:                         wantedTime = (CRC_BUFFER_SIZE) - (wantedTime - _this->head);
478:                         return (_this->buf[(wantedTime + space)]);
9D00BB34  00832021   ADDU A0, A0, V1
9D00BB38  00852821   ADDU A1, A0, A1
9D00BB3C  03E00008   JR RA
9D00BB40  90A2000F   LBU V0, 15(A1)
479:                     } else
480:                     {
481:                         return (_this->buf[(_this->head - wantedTime) + space]);
9D00BB44  00851021   ADDU V0, A0, A1
482:                     }
483:                 }
9D00BB48  03E00008   JR RA
484:                 
485:                 
486:                 //when an AK or NAK is received this compares it to the buffer and records the status
487:                 
488:                 void CRCcheck(FastTransfer_t *_this)
489:                 {
9D008E94  27BDFFC0   ADDIU SP, SP, -64
9D008E98  AFBF003C   SW RA, 60(SP)
9D008E9C  AFB70038   SW S7, 56(SP)
9D008EA0  AFB60034   SW S6, 52(SP)
9D008EA4  AFB50030   SW S5, 48(SP)
9D008EA8  AFB4002C   SW S4, 44(SP)
9D008EAC  AFB30028   SW S3, 40(SP)
9D008EB0  AFB20024   SW S2, 36(SP)
9D008EB4  AFB10020   SW S1, 32(SP)
9D008EB8  AFB0001C   SW S0, 28(SP)
9D008EBC  00808021   ADDU S0, A0, ZERO
490:                 
491:                     while (!(_this->serial_available(_this->COMdriver.RxBuffer) > 3)); // trap makes sure that there are enough bytes in the buffer for the AKNAK check
9D008EC0  8E020078   LW V0, 120(S0)
9D008EC4  0040F809   JALR V0
9D008EC8  8E040048   LW A0, 72(S0)
9D008ECC  28420004   SLTI V0, V0, 4
9D008ED0  5440FFFC   BNEL V0, ZERO, 0x9D008EC4
9D008ED4  8E020078   LW V0, 120(S0)
492:                 
493:                     unsigned char arrayHolder[3];
494:                     arrayHolder[0] = _this->serial_read(_this->COMdriver.RxBuffer);
9D008ED8  8E020074   LW V0, 116(S0)
9D008EDC  0040F809   JALR V0
9D008EE0  8E040048   LW A0, 72(S0)
9D008EE4  A3A20010   SB V0, 16(SP)
495:                     arrayHolder[1] = _this->serial_read(_this->COMdriver.RxBuffer);
9D008EE8  8E020074   LW V0, 116(S0)
9D008EEC  0040F809   JALR V0
9D008EF0  8E040048   LW A0, 72(S0)
9D008EF4  00409821   ADDU S3, V0, ZERO
9D008EF8  A3A20011   SB V0, 17(SP)
496:                     arrayHolder[2] = _this->serial_read(_this->COMdriver.RxBuffer);
9D008EFC  8E020074   LW V0, 116(S0)
9D008F00  0040F809   JALR V0
9D008F04  8E040048   LW A0, 72(S0)
9D008F08  00409021   ADDU S2, V0, ZERO
9D008F0C  A3A20012   SB V0, 18(SP)
497:                     unsigned char SentCRC = _this->serial_read(_this->COMdriver.RxBuffer);
9D008F10  8E020074   LW V0, 116(S0)
9D008F14  0040F809   JALR V0
9D008F18  8E040048   LW A0, 72(S0)
9D008F1C  00408021   ADDU S0, V0, ZERO
498:                     unsigned char calculatedCRC = CRC8(arrayHolder, 3);
9D008F20  27A40010   ADDIU A0, SP, 16
9D008F24  0F402F8A   JAL CRC8
9D008F28  24050003   ADDIU A1, ZERO, 3
499:                 
500:                 
501:                     if (SentCRC == calculatedCRC)
9D008F2C  1602002A   BNE S0, V0, .LVL125, .LBE16
9D008F30  8F82812C   LW V0, -32468(GP)
502:                     {
503:                 
504:                         int rt;
505:                         for (rt = 0; rt < CRC_COUNT; rt++)
9D008F48  24160005   ADDIU S6, ZERO, 5
9D008FC8  1616FFE1   BNE S0, S6, 0x9D008F50
9D008FCC  321100FF   ANDI S1, S0, 255
9D008FD0  0B4023F9   J 0x9D008FE4
9D008FD4  8FBF003C   LW RA, 60(SP)
506:                         {
507:                             if (returnAddress == crcBufS_get(&crc_buffer, rt, 0))
9D008F34  9395813D   LBU S5, -32451(GP)
9D008F38  00008021   ADDU S0, ZERO, ZERO
9D008F3C  3C148000   LUI S4, -32768
9D008F40  26945778   ADDIU S4, S4, 22392
9D008F4C  321100FF   ANDI S1, S0, 255
9D008F50  02802021   ADDU A0, S4, ZERO
9D008F54  02202821   ADDU A1, S1, ZERO
9D008F58  0F402EBB   JAL crcBufS_get
9D008F5C  00003021   ADDU A2, ZERO, ZERO
9D008F60  54550019   BNEL V0, S5, 0x9D008FC8
9D008F64  26100001   ADDIU S0, S0, 1
508:                             {
509:                                 if (arrayHolder[2] == crcBufS_get(&crc_buffer, rt, 1))
9D008F68  02802021   ADDU A0, S4, ZERO
9D008F6C  02202821   ADDU A1, S1, ZERO
9D008F70  0F402EBB   JAL crcBufS_get
9D008F74  24060001   ADDIU A2, ZERO, 1
9D008F78  56420013   BNEL S2, V0, 0x9D008FC8
9D008F7C  26100001   ADDIU S0, S0, 1
510:                                 {
511:                                     if (arrayHolder[1] == 1)
9D008F80  24020001   ADDIU V0, ZERO, 1
9D008F84  16620007   BNE S3, V0, 0x9D008FA4
9D008F88  3C048000   LUI A0, -32768
512:                                     {
513:                                         crcBufS_status_put(&crc_buffer, rt, 1);
9D008F8C  24845778   ADDIU A0, A0, 22392
9D008F90  02202821   ADDU A1, S1, ZERO
9D008F94  0F403057   JAL crcBufS_status_put
9D008F98  24060001   ADDIU A2, ZERO, 1
514:                                         break;
9D008F9C  0B4023F9   J 0x9D008FE4
9D008FA0  8FBF003C   LW RA, 60(SP)
515:                                     } else if (arrayHolder[1] == 2)
9D008F44  24170002   ADDIU S7, ZERO, 2
9D008FA4  16770008   BNE S3, S7, 0x9D008FC8
9D008FA8  26100001   ADDIU S0, S0, 1
516:                                     {
517:                                         crcBufS_status_put(&crc_buffer, rt, 2);
9D008FAC  3C048000   LUI A0, -32768
9D008FB0  24845778   ADDIU A0, A0, 22392
9D008FB4  02202821   ADDU A1, S1, ZERO
9D008FB8  0F403057   JAL crcBufS_status_put
9D008FBC  24060002   ADDIU A2, ZERO, 2
518:                                         break;
9D008FC0  0B4023F9   J 0x9D008FE4
9D008FC4  8FBF003C   LW RA, 60(SP)
519:                                     }
520:                                 }
521:                             }
522:                         }
523:                     } else
524:                     {
525:                         crcErrorCounter++;
9D008FD8  24420001   ADDIU V0, V0, 1
9D008FDC  AF82812C   SW V0, -32468(GP)
526:                     } //increments the counter every time a crc fails
527:                 }
9D008FE0  8FBF003C   LW RA, 60(SP)
528:                 
529:                 
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/datapublishing.c  -
1:                   #include <stddef.h>
2:                   #include "DataPublishing.h"
3:                   #include "CAN_Handler/CANFastTransfer.h"
4:                   #include "Definitions.h"
5:                   #include "Timers.h"
6:                   
7:                   #define isINITbit   0
8:                   #define DATA_ELEMENTS_COUNT 7
9:                   timers_t dataPeriodTimer[DATA_ELEMENTS_COUNT];
10:                  int (*dataRetrievalFunc[DATA_ELEMENTS_COUNT])();
11:                  void InitDataPublishing()
12:                  {
9D00CA60  3C028000   LUI V0, -32768
9D00CA64  2442588C   ADDIU V0, V0, 22668
9D00CA68  2443001C   ADDIU V1, V0, 28
13:                      int i;
14:                      for( i = 0;i< DATA_ELEMENTS_COUNT;i++)
9D00CA74  5443FFFE   BNEL V0, V1, 0x9D00CA70
9D00CA78  AC400000   SW ZERO, 0(V0)
15:                      {
16:                          dataRetrievalFunc[i] = NULL;
9D00CA6C  AC400000   SW ZERO, 0(V0)
9D00CA70  24420004   ADDIU V0, V0, 4
17:                      }
18:                  }
9D00CA7C  03E00008   JR RA
19:                  void initGlobalData(GlobalDeviceData_t _index, int (*getFuncPointer)(void), unsigned long _interval) {
9D00BE80  27BDFFE0   ADDIU SP, SP, -32
9D00BE84  AFBF001C   SW RA, 28(SP)
9D00BE88  AFB10018   SW S1, 24(SP)
9D00BE8C  AFB00014   SW S0, 20(SP)
9D00BE90  00808021   ADDU S0, A0, ZERO
9D00BE94  00A08821   ADDU S1, A1, ZERO
20:                      setTimerInterval(&dataPeriodTimer[_index], _interval);
9D00BE98  000410C0   SLL V0, A0, 3
9D00BE9C  3C048000   LUI A0, -32768
9D00BEA0  248458A8   ADDIU A0, A0, 22696
9D00BEA4  00822021   ADDU A0, A0, V0
9D00BEA8  0F403306   JAL setTimerInterval
9D00BEAC  00C02821   ADDU A1, A2, ZERO
21:                      dataRetrievalFunc[_index] = getFuncPointer;
9D00BEB0  00108080   SLL S0, S0, 2
9D00BEB4  3C028000   LUI V0, -32768
9D00BEB8  2442588C   ADDIU V0, V0, 22668
9D00BEBC  02028021   ADDU S0, S0, V0
9D00BEC0  AE110000   SW S1, 0(S0)
22:                  
23:                  }
9D00BEC4  8FBF001C   LW RA, 28(SP)
24:                  
25:                  bool publishData() {
9D00A944  27BDFFD0   ADDIU SP, SP, -48
9D00A948  AFBF002C   SW RA, 44(SP)
9D00A94C  AFB50028   SW S5, 40(SP)
9D00A950  AFB40024   SW S4, 36(SP)
9D00A954  AFB30020   SW S3, 32(SP)
9D00A958  AFB2001C   SW S2, 28(SP)
9D00A95C  AFB10018   SW S1, 24(SP)
9D00A960  AFB00014   SW S0, 20(SP)
9D00A964  3C108000   LUI S0, -32768
9D00A968  2610588C   ADDIU S0, S0, 22668
9D00A96C  3C118000   LUI S1, -32768
9D00A970  263158A8   ADDIU S1, S1, 22696
9D00A974  2614001C   ADDIU S4, S0, 28
9D00A978  24120023   ADDIU S2, ZERO, 35
26:                      int i;
27:                      bool validData = false;
9D00A97C  0000A821   ADDU S5, ZERO, ZERO
28:                      // Loop through all the elements that we could potentially send
29:                      for (i = 0; i < DATA_ELEMENTS_COUNT; i++) {
9D00A9BC  1614FFF0   BNE S0, S4, .LVL10
9D00A9C0  26520001   ADDIU S2, S2, 1
30:                          // if an data element hasn't been initialized then the pointer to the data retrieval function will be NULL
31:                          if (dataRetrievalFunc[i] != NULL) {
9D00A980  8E030000   LW V1, 0(S0)
9D00A984  5060000C   BEQL V1, ZERO, 0x9D00A9B8
9D00A988  26100004   ADDIU S0, S0, 4
32:                  
33:                              // Make sure the interval that we want to send the data out on has elapsed
34:                              if (timerDone(&dataPeriodTimer[i])) {
9D00A98C  0F403198   JAL timerDone
9D00A990  02202021   ADDU A0, S1, ZERO
9D00A994  50400008   BEQL V0, ZERO, 0x9D00A9B8
9D00A998  26100004   ADDIU S0, S0, 4
35:                                  // Making sure we actually have data to send
36:                                  validData = true;
37:                                  //Send the data on the can bus
38:                                  ToSendCAN(i + DATA_ELEMENTS_COUNT*MASTER_CONTROLLER, (dataRetrievalFunc[i])());
9D00A99C  8E020000   LW V0, 0(S0)
9D00A9A0  0040F809   JALR V0
9D00A9A4  24150001   ADDIU S5, ZERO, 1
9D00A9A8  02402021   ADDU A0, S2, ZERO
9D00A9AC  0F4031E6   JAL ToSendCAN
9D00A9B0  00402821   ADDU A1, V0, ZERO
9D00A9B4  26100004   ADDIU S0, S0, 4
9D00A9B8  26310008   ADDIU S1, S1, 8
39:                              }
40:                          }
41:                      }
42:                      if (validData) {
9D00A9C4  12A00004   BEQ S5, ZERO, 0x9D00A9D8
9D00A9C8  02A01021   ADDU V0, S5, ZERO
43:                          sendDataCAN(GLOBAL_ADDRESS);
9D00A9CC  0F402960   JAL sendDataCAN
9D00A9D0  2404001F   ADDIU A0, ZERO, 31
44:                      }
45:                      return validData;
46:                  }
9D00A9D4  02A01021   ADDU V0, S5, ZERO
47:                  
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/comunications.c  --
1:                   
2:                   #include "Comunications.h"
3:                   #include "CAN_Handler/CAN.h"
4:                   #include "CAN_Handler/CANFastTransfer.h"
5:                   #include "uart_Handler.h"
6:                   #include "FastTransfer.h"
7:                   #include "Macros.h"
8:                   #include "app.h"
9:                   #include "Timers.h"
10:                  #include "Motor.h"
11:                  #include "Definitions.h"
12:                  
13:                  
14:                  int lastMacroIndex, lastData;
15:                  
16:                  bool SafeForMacros = false;
17:                  timers_t retransmitTimer;
18:                  
19:                  //- Getting the status of the other controller processes for autonomy
20:                  //  so for either the gyro or motor controller, when it is done with a macro
21:                  //  it will send a done status through fastTransfer
22:                  
23:                  void setGyroMacro(int macroIndex, int data) {
9D00C2C4  27BDFFE8   ADDIU SP, SP, -24
9D00C2C8  AFBF0014   SW RA, 20(SP)
9D00C2CC  AFB00010   SW S0, 16(SP)
9D00C2D0  00801021   ADDU V0, A0, ZERO
9D00C2D4  00A08021   ADDU S0, A1, ZERO
24:                      ToSendCAN(CAN_COMMAND_INDEX, macroIndex);
9D00C2D8  24040008   ADDIU A0, ZERO, 8
9D00C2DC  0F4031E6   JAL ToSendCAN
9D00C2E0  00402821   ADDU A1, V0, ZERO
25:                      ToSendCAN(CAN_COMMAND_DATA_INDEX, data);
9D00C2E4  24040009   ADDIU A0, ZERO, 9
9D00C2E8  0F4031E6   JAL ToSendCAN
9D00C2EC  02002821   ADDU A1, S0, ZERO
26:                      sendDataCAN(GYRO_CONTROLLER);
9D00C2F0  0F402960   JAL sendDataCAN
9D00C2F4  24040007   ADDIU A0, ZERO, 7
27:                  }
9D00C2F8  8FBF0014   LW RA, 20(SP)
28:                  
29:                  void setMotorMacro(int macroIndex, int data) {
9D00C308  27BDFFE8   ADDIU SP, SP, -24
9D00C30C  AFBF0014   SW RA, 20(SP)
9D00C310  AFB00010   SW S0, 16(SP)
9D00C314  00801021   ADDU V0, A0, ZERO
9D00C318  00A08021   ADDU S0, A1, ZERO
30:                      ToSendCAN(CAN_COMMAND_INDEX, macroIndex);
9D00C31C  24040008   ADDIU A0, ZERO, 8
9D00C320  0F4031E6   JAL ToSendCAN
9D00C324  00402821   ADDU A1, V0, ZERO
31:                      ToSendCAN(CAN_COMMAND_DATA_INDEX, data);
9D00C328  24040009   ADDIU A0, ZERO, 9
9D00C32C  0F4031E6   JAL ToSendCAN
9D00C330  02002821   ADDU A1, S0, ZERO
32:                      sendDataCAN(MOTOR_CONTROLLER);
9D00C334  0F402960   JAL sendDataCAN
9D00C338  24040006   ADDIU A0, ZERO, 6
33:                  }
9D00C33C  8FBF0014   LW RA, 20(SP)
34:                  
35:                  
36:                  
37:                  /* Returns the macro status of the motor controller */
38:                  bool getMotorControllerStatus() {
9D00CA18  27BDFFE8   ADDIU SP, SP, -24
9D00CA1C  AFBF0014   SW RA, 20(SP)
39:                      return getCANFastData(FT_GLOBAL, getGBL_MACRO_INDEX(MOTOR_CONTROLLER));
9D00CA20  24040001   ADDIU A0, ZERO, 1
9D00CA24  0F402EED   JAL getCANFastData
9D00CA28  2405002B   ADDIU A1, ZERO, 43
40:                  }
9D00CA2C  0002102B   SLTU V0, ZERO, V0
41:                  
42:                  /* Returns the status of the gyro controller and if we haven't received 
43:                   * confirmation of a macro then a retransmission of the last 
44:                   * macro sent is resulting */
45:                  bool getGyroControllerStatus() {
9D00CA3C  27BDFFE8   ADDIU SP, SP, -24
9D00CA40  AFBF0014   SW RA, 20(SP)
46:                      // returning the macros that the gyro may be running 
47:                      return getCANFastData(FT_GLOBAL, getGBL_MACRO_INDEX(GYRO_CONTROLLER));
9D00CA44  24040001   ADDIU A0, ZERO, 1
9D00CA48  0F402EED   JAL getCANFastData
9D00CA4C  24050032   ADDIU A1, ZERO, 50
48:                  }
9D00CA50  0002102B   SLTU V0, ZERO, V0
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/compairitormethods.c
1:                   /* 
2:                    * File:   CompairitorMethods.c
3:                    * Author: Seth Carpenter
4:                    *
5:                    * Created on June 12, 2019, 3:24 PM
6:                    */
7:                   #include "CompairitorMethods.h"
8:                   #include "Definitions.h"
9:                   #include <stdlib.h>
10:                  #define HeadingToleranceVal    9
11:                  #define ToleranceVal           15
12:                  
13:                  
14:                  bool compairHeading(int headingA, int headingB) {
15:                      return (abs(headingA - headingB) < HeadingToleranceVal);
00000000  00000000   NOP
16:                  }
00000008  00000000   NOP
17:                  
18:                  bool compairPoint(point_t _pointA, point_t _pointB) {
00000000  00000000   NOP
19:                      return (abs(_pointA.x - _pointB.x) < ToleranceVal && abs(_pointA.y - _pointB.y) < ToleranceVal);
00000010  00000000   NOP
20:                  }
00000030  00000000   NOP
21:                  
22:                  bool compairPoint_TalVal(point_t _pointA, point_t _pointB, int _tolVal) {
00000000  00000000   NOP
23:                      return (abs(_pointA.x - _pointB.x) < _tolVal && abs(_pointA.y - _pointB.y) < _tolVal);
00000014  00000000   NOP
24:                  
25:                  }
00000044  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/changenotification.c
1:                   #include "changeNotification.h"
2:                   
3:                   intPin_t *pinArray[CN_PIN_COUNT];
4:                   unsigned char getPinState(unsigned char ID);
5:                   void initChangeNotification()
6:                   {
9D00B2AC  27BDFFD8   ADDIU SP, SP, -40
9D00B2B0  AFBF0024   SW RA, 36(SP)
9D00B2B4  AFB30020   SW S3, 32(SP)
9D00B2B8  AFB2001C   SW S2, 28(SP)
9D00B2BC  AFB10018   SW S1, 24(SP)
9D00B2C0  AFB00014   SW S0, 20(SP)
7:                       pinArray[0] = &GyroPin1;
9D00B2C4  3C108000   LUI S0, -32768
9D00B2C8  27828100   ADDIU V0, GP, -32512
9D00B2CC  AE025768   SW V0, 22376(S0)
8:                       pinArray[1] = &GyroPin2;
9D00B2D0  26105768   ADDIU S0, S0, 22376
9D00B2D4  27828104   ADDIU V0, GP, -32508
9D00B2D8  AE020004   SW V0, 4(S0)
9:                       pinArray[2] = &MotorPin1;
9D00B2DC  278280FC   ADDIU V0, GP, -32516
9D00B2E0  AE020008   SW V0, 8(S0)
10:                      pinArray[3] = &MotorPin2;
9D00B2E4  27828108   ADDIU V0, GP, -32504
9D00B2E8  AE02000C   SW V0, 12(S0)
11:                      
12:                      int i;
13:                      for(i = 0; i < CN_PIN_COUNT; i++)
9D00B2EC  00008821   ADDU S1, ZERO, ZERO
9D00B2F0  24130004   ADDIU S3, ZERO, 4
9D00B314  26310001   ADDIU S1, S1, 1
9D00B318  1633FFF6   BNE S1, S3, .LVL2
9D00B31C  26100004   ADDIU S0, S0, 4
14:                      {
15:                          pinArray[i]->pinId = i;
9D00B2F4  8E020000   LW V0, 0(S0)
9D00B2F8  A0510000   SB S1, 0(V0)
16:                          pinArray[i]->changed = false;
9D00B2FC  8E020000   LW V0, 0(S0)
9D00B300  A0400002   SB ZERO, 2(V0)
17:                          pinArray[i]->prevState = getPinState(pinArray[i]->pinId);
9D00B304  8E120000   LW S2, 0(S0)
9D00B308  0F402EA2   JAL getPinState
9D00B30C  92440000   LBU A0, 0(S2)
9D00B310  A2420001   SB V0, 1(S2)
18:                      }
19:                  }
9D00B320  8FBF0024   LW RA, 36(SP)
20:                  
21:                  
22:                  bool pinState(intPin_t *pin)
23:                  {
00000000  00000000   NOP
24:                      if(pin->changed)
00000010  00000000   NOP
25:                      {
26:                          pin->changed = false;
0000001C  00000000   NOP
27:                          pin->prevState = getPinState(pin->pinId);
00000020  00000000   NOP
28:                          return true;
29:                      }
30:                      return false;
31:                  }
0000002C  00000000   NOP
32:                  // put in system interrupt 
33:                  void pinChangeNotified()
34:                  {
9D00B4D4  27BDFFD8   ADDIU SP, SP, -40
9D00B4D8  AFBF0024   SW RA, 36(SP)
9D00B4DC  AFB40020   SW S4, 32(SP)
9D00B4E0  AFB3001C   SW S3, 28(SP)
9D00B4E4  AFB20018   SW S2, 24(SP)
9D00B4E8  AFB10014   SW S1, 20(SP)
9D00B4EC  AFB00010   SW S0, 16(SP)
9D00B4F0  3C118000   LUI S1, -32768
9D00B4F4  26315768   ADDIU S1, S1, 22376
35:                      int pinIndex;
36:                      for(pinIndex = 0; pinIndex < CN_PIN_COUNT; pinIndex++)
9D00B4F8  00008021   ADDU S0, ZERO, ZERO
9D00B500  24130004   ADDIU S3, ZERO, 4
9D00B52C  26100001   ADDIU S0, S0, 1
9D00B530  1613FFF4   BNE S0, S3, .LVL11
9D00B534  26310004   ADDIU S1, S1, 4
37:                      {
38:                          if(pinArray[pinIndex]->prevState != getPinState(pinIndex) && pinArray[pinIndex]->changed == false)
9D00B504  8E220000   LW V0, 0(S1)
9D00B508  90520001   LBU S2, 1(V0)
9D00B50C  0F402EA2   JAL getPinState
9D00B510  320400FF   ANDI A0, S0, 255
9D00B514  52420006   BEQL S2, V0, 0x9D00B530
9D00B518  26100001   ADDIU S0, S0, 1
9D00B51C  8E220000   LW V0, 0(S1)
9D00B520  90430002   LBU V1, 2(V0)
9D00B524  50600001   BEQL V1, ZERO, 0x9D00B52C
9D00B528  A0540002   SB S4, 2(V0)
39:                          {
40:                              pinArray[pinIndex]->changed = true;
9D00B4FC  24140001   ADDIU S4, ZERO, 1
41:                          }
42:                      }
43:                  }
9D00B538  8FBF0024   LW RA, 36(SP)
44:                  unsigned char getPinState(unsigned char ID)
45:                  {
46:                      switch(ID)
9D00BA88  24020001   ADDIU V0, ZERO, 1
9D00BA8C  1082000E   BEQ A0, V0, 0x9D00BAC8
9D00BA90  3C02BF86   LUI V0, -16506
9D00BA94  10800009   BEQ A0, ZERO, 0x9D00BABC
9D00BA98  00000000   NOP
9D00BA9C  24020002   ADDIU V0, ZERO, 2
9D00BAA0  1082000C   BEQ A0, V0, 0x9D00BAD4
9D00BAA4  3C02BF86   LUI V0, -16506
9D00BAA8  24020003   ADDIU V0, ZERO, 3
9D00BAAC  5082000C   BEQL A0, V0, 0x9D00BAE0
9D00BAB0  3C02BF86   LUI V0, -16506
47:                      {
48:                          case 0:
49:                          {
50:                              return INPUT_INTURRUPT_PIN_0;
9D00BABC  8C420120   LW V0, 288(V0)
9D00BAC0  03E00008   JR RA
9D00BAC4  7C420200   EXT V0, V0, 8, 1
51:                              break;
52:                          }
53:                          case 1:
54:                          {
55:                              return INPUT_INTURRUPT_PIN_1;
9D00BAC8  8C420120   LW V0, 288(V0)
9D00BACC  03E00008   JR RA
9D00BAD0  7C420240   EXT V0, V0, 9, 1
56:                              break;
57:                          }
58:                          case 2:
59:                          {
60:                              return INPUT_INTURRUPT_PIN_2;
9D00BAD4  8C420120   LW V0, 288(V0)
9D00BAD8  03E00008   JR RA
9D00BADC  7C420300   EXT V0, V0, 12, 1
61:                              break;
62:                          }
63:                          case 3:
64:                          {
65:                              return INPUT_INTURRUPT_PIN_3;
9D00BAE0  8C420120   LW V0, 288(V0)
66:                              break;
67:                          }
68:                      }
69:                      return 0;
9D00BAB4  03E00008   JR RA
9D00BAB8  00001021   ADDU V0, ZERO, ZERO
70:                  }
71:                  void togglePinState(intPin_t *pin)
72:                  {
73:                      
74:                      switch(pin->pinId)
00000000  00000000   NOP
75:                      {
76:                          case 0:
77:                          {
78:                              OUTPUT_INTURRUPT_PIN_0 ^= 1;
00000030  00000000   NOP
79:                              break;
0000004C  00000000   NOP
80:                          }
81:                          case 1:
82:                          {
83:                              OUTPUT_INTURRUPT_PIN_1 ^= 1;
00000054  00000000   NOP
84:                              break;
0000006C  00000000   NOP
85:                          }
86:                          case 2:
87:                          {
88:                              OUTPUT_INTURRUPT_PIN_2 ^= 1;
00000074  00000000   NOP
89:                              break;
00000090  00000000   NOP
90:                          }
91:                          case 3:
92:                          {
93:                              OUTPUT_INTURRUPT_PIN_3 ^= 1;
00000098  00000000   NOP
94:                              break;
95:                          }
96:                      }
97:                  }
98:                  void setPinState(intPin_t *pin, unsigned char state)
99:                  {
100:                     
101:                     switch(pin->pinId)
00000000  00000000   NOP
102:                     {
103:                         case 0:
104:                         {
105:                             OUTPUT_INTURRUPT_PIN_0 = (state & 0x01);
00000030  00000000   NOP
106:                             break;
00000040  00000000   NOP
107:                         }
108:                         case 1:
109:                         {
110:                             OUTPUT_INTURRUPT_PIN_1 = (state & 0x01);
00000048  00000000   NOP
111:                             break;
00000054  00000000   NOP
112:                         }
113:                         case 2:
114:                         {
115:                             OUTPUT_INTURRUPT_PIN_2 = (state & 0x01);
0000005C  00000000   NOP
116:                             break;
0000006C  00000000   NOP
117:                         }
118:                         case 3:
119:                         {
120:                             OUTPUT_INTURRUPT_PIN_3 = (state & 0x01);
00000074  00000000   NOP
121:                             break;
122:                         }
123:                     }
124:                 }
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/can_handler/canfasttransfer.c
1:                   #include "CANFastTransfer.h"
2:                   #include "CANbufferHandler.h"
3:                   #include "GlobalCAN_IDs.h"
4:                   //0b0111 1111 11xx xxxx (where the x's are your address)
5:                   #define LAST_BOARD_RECEIEVED 0
6:                   
7:                   
8:                   void beginCANFast(volatile short * ptr, volatile bool *flagPtr, unsigned int maxSize, unsigned char givenAddress, FT_type_t _t);
9:                   void buffer_put(ringBufCAN_t *_this, unsigned int towhere, unsigned int towhat);
10:                  
11:                  void setNewDataFlag(FT_type_t _t, int index);
12:                  
13:                  ringBufCAN_t transmit_buffer_CAN, send_buffer_CAN_FT, rx_buffer_CAN;
14:                  ringBufCAN_t rx_buffer_CAN_Global;
15:                  
16:                  bool dataReceived[2] = {false,false};
17:                  volatile int * receiveArrayAddressCAN[2];
18:                  volatile bool * receiveArrayAddressCAN_Flag[2];
19:                  unsigned char moduleAddressCAN[2];
20:                  unsigned int MaxIndex[2];
21:                  short receiveArrayCAN[10];
22:                  bool receiveArrayCAN_Flag[10];
23:                  
24:                  int newDataFlag = 0;
25:                  int newDataFlag_Global[2];
26:                  
27:                  int * getReceiveArrayCAN(void) {
28:                      return receiveArrayCAN;
29:                  }
00000000  00000000   NOP
30:                  
31:                  void initCANFT(void) {
9D00BCC8  27BDFFE0   ADDIU SP, SP, -32
9D00BCCC  AFBF001C   SW RA, 28(SP)
32:                      beginCANFast(receiveArrayCAN, receiveArrayCAN_Flag, sizeof (receiveArrayCAN), MY_ADDRESS,FT_LOCAL);
9D00BCD0  AFA00010   SW ZERO, 16(SP)
9D00BCD4  3C048000   LUI A0, -32768
9D00BCD8  2484095C   ADDIU A0, A0, 2396
9D00BCDC  3C058000   LUI A1, -32768
9D00BCE0  24A5054C   ADDIU A1, A1, 1356
9D00BCE4  24060014   ADDIU A2, ZERO, 20
9D00BCE8  0F402B77   JAL beginCANFast
9D00BCEC  24070005   ADDIU A3, ZERO, 5
33:                      beginCANFast(receiveArrayCAN_Global, GBL_CAN_FT_recievedFlag, sizeof (receiveArrayCAN_Global), GLOBAL_ADDRESS, FT_GLOBAL);
9D00BCF0  24020001   ADDIU V0, ZERO, 1
9D00BCF4  AFA20010   SW V0, 16(SP)
9D00BCF8  3C048000   LUI A0, -32768
9D00BCFC  24840558   ADDIU A0, A0, 1368
9D00BD00  3C058000   LUI A1, -32768
9D00BD04  24A505E8   ADDIU A1, A1, 1512
9D00BD08  2406008E   ADDIU A2, ZERO, 142
9D00BD0C  0F402B77   JAL beginCANFast
9D00BD10  2407001F   ADDIU A3, ZERO, 31
34:                  }
9D00BD14  8FBF001C   LW RA, 28(SP)
35:                  
36:                  void beginCANFast(volatile short * ptr, volatile bool *flagPtr, unsigned int maxSize, unsigned char givenAddress, FT_type_t _t) {
9D00ADDC  27BDFFE8   ADDIU SP, SP, -24
9D00ADE0  AFBF0014   SW RA, 20(SP)
9D00ADE4  8FA20028   LW V0, 40(SP)
37:                  
38:                      receiveArrayAddressCAN[_t] = ptr;
9D00ADE8  00021880   SLL V1, V0, 2
9D00ADEC  278880A0   ADDIU T0, GP, -32608
9D00ADF0  01034021   ADDU T0, T0, V1
9D00ADF4  AD040000   SW A0, 0(T0)
39:                      receiveArrayAddressCAN_Flag[_t] = flagPtr;
9D00ADF8  278480B0   ADDIU A0, GP, -32592
9D00ADFC  00832021   ADDU A0, A0, V1
9D00AE00  AC850000   SW A1, 0(A0)
40:                      moduleAddressCAN[_t] = givenAddress;
9D00AE04  278480C0   ADDIU A0, GP, -32576
9D00AE08  00822021   ADDU A0, A0, V0
9D00AE0C  A0870000   SB A3, 0(A0)
41:                      MaxIndex[_t] = maxSize;
9D00AE10  278480B8   ADDIU A0, GP, -32584
9D00AE14  00831821   ADDU V1, A0, V1
9D00AE18  AC660000   SW A2, 0(V1)
42:                  
43:                      if (_t == FT_GLOBAL) {
9D00AE1C  24030001   ADDIU V1, ZERO, 1
9D00AE20  14430007   BNE V0, V1, .LVL4
9D00AE24  3C048000   LUI A0, -32768
44:                          buffer_flush(&rx_buffer_CAN_Global, 0);
9D00AE28  3C048000   LUI A0, -32768
9D00AE2C  24840C9C   ADDIU A0, A0, 3228
9D00AE30  0F4031A6   JAL buffer_flush
9D00AE34  00002821   ADDU A1, ZERO, ZERO
9D00AE38  0B402B9C   J .LVL9
9D00AE3C  8FBF0014   LW RA, 20(SP)
45:                      } else {
46:                          buffer_flush(&rx_buffer_CAN, 0);
9D00AE40  24840970   ADDIU A0, A0, 2416
9D00AE44  0F4031A6   JAL buffer_flush
9D00AE48  00002821   ADDU A1, ZERO, ZERO
47:                          buffer_flush(&send_buffer_CAN_FT, 0);
9D00AE4C  3C048000   LUI A0, -32768
9D00AE50  24840630   ADDIU A0, A0, 1584
9D00AE54  0F4031A6   JAL buffer_flush
9D00AE58  00002821   ADDU A1, ZERO, ZERO
48:                          buffer_flush(&transmit_buffer_CAN, 0);
9D00AE5C  3C048000   LUI A0, -32768
9D00AE60  24840FC8   ADDIU A0, A0, 4040
9D00AE64  0F4031A6   JAL buffer_flush
9D00AE68  00002821   ADDU A1, ZERO, ZERO
49:                      }
50:                  }
9D00AE6C  8FBF0014   LW RA, 20(SP)
51:                  
52:                  void setNewDataFlag(FT_type_t _t, int index) {
53:                      (receiveArrayAddressCAN_Flag[_t])[index] = 1;
9D009EF8  278280B0   ADDIU V0, GP, -32592
9D009EFC  0055A821   ADDU S5, V0, S5
9D009F00  24140001   ADDIU S4, ZERO, 1
9D009F28  8EA20000   LW V0, 0(S5)
9D009F2C  00518821   ADDU S1, V0, S1
9D009F30  A2340000   SB S4, 0(S1)
54:                  }
55:                  
56:                  void clearNewDataFlag(FT_type_t _t, int index) {
57:                      (receiveArrayAddressCAN_Flag[_t])[index] = 0;
00000000  00000000   NOP
00000018  00000000   NOP
58:                  }
59:                  
60:                  bool getNewDataFlagStatus(FT_type_t _t, int index) {
61:                      if ((receiveArrayAddressCAN_Flag[_t])[index]) {
9D00C91C  00042080   SLL A0, A0, 2
9D00C920  278280B0   ADDIU V0, GP, -32592
9D00C924  7C44100A   LWX V0, A0(V0)
9D00C928  00451821   ADDU V1, V0, A1
9D00C92C  7C45118A   LBUX V0, A1(V0)
9D00C930  54400001   BNEL V0, ZERO, 0x9D00C938
9D00C934  A0600000   SB ZERO, 0(V1)
62:                          clearNewDataFlag(_t, index);
63:                          return true;
64:                      } else {
65:                          return false;
66:                      }
67:                  }
9D00C938  03E00008   JR RA
68:                  
69:                  int getCANFastData(FT_type_t _t, uint8_t index) {
9D00BBB4  27BDFFE0   ADDIU SP, SP, -32
9D00BBB8  AFBF001C   SW RA, 28(SP)
9D00BBBC  AFB10018   SW S1, 24(SP)
9D00BBC0  AFB00014   SW S0, 20(SP)
9D00BBC4  00808821   ADDU S1, A0, ZERO
70:                      ReceiveDataCAN(_t);
9D00BBC8  0F40279E   JAL ReceiveDataCAN
9D00BBCC  00A08021   ADDU S0, A1, ZERO
71:                      if (index < MaxIndex[_t]) {
9D00BBD0  00111080   SLL V0, S1, 2
9D00BBD4  278380B8   ADDIU V1, GP, -32584
9D00BBD8  7C62180A   LWX V1, V0(V1)
9D00BBDC  0203182B   SLTU V1, S0, V1
9D00BBE0  10600006   BEQ V1, ZERO, 0x9D00BBFC
9D00BBE4  3402FFFF   ORI V0, ZERO, -1
72:                  
73:                          return (receiveArrayAddressCAN[_t])[index];
9D00BBE8  00118880   SLL S1, S1, 2
9D00BBEC  00108080   SLL S0, S0, 2
9D00BBF0  278280A0   ADDIU V0, GP, -32608
9D00BBF4  7C51100A   LWX V0, S1(V0)
9D00BBF8  7C50100A   LWX V0, S0(V0)
74:                      }
75:                      return 0xFFFF;
76:                  }
9D00BBFC  8FBF001C   LW RA, 28(SP)
77:                  
78:                  void clearCANFastDataValue(int index) {
79:                  
80:                      receiveArrayCAN[index] = 0;
81:                  }
82:                  
83:                  void clearCANFastDataValueRange(int startIndex, int end) {
84:                      if (startIndex > end) {
00000000  00000000   NOP
85:                          int index = startIndex;
86:                          startIndex = end;
0000003C  00000000   NOP
87:                          end = index;
00000040  00000000   NOP
88:                      }
89:                      int i;
90:                      for (i = startIndex; i <= end; i++) {
00000024  00000000   NOP
91:                  
92:                          receiveArrayCAN[i] = 0;
00000014  00000000   NOP
93:                          clearNewDataFlag(FT_LOCAL, i);
94:                      }
95:                  }
96:                  
97:                  void ReceiveCANFast(my_can_packet_t *p, FT_type_t _t) // interrupt callback
98:                  {
9D008868  27BDFFE0   ADDIU SP, SP, -32
9D00886C  AFBF001C   SW RA, 28(SP)
9D008870  AFB20018   SW S2, 24(SP)
9D008874  AFB10014   SW S1, 20(SP)
9D008878  AFB00010   SW S0, 16(SP)
9D00887C  00808021   ADDU S0, A0, ZERO
99:                      ringBufCAN_t *rx_Buff;
100:                     if (_t == FT_LOCAL) 
9D008880  14A00004   BNE A1, ZERO, 0x9D008894
9D008884  00A08821   ADDU S1, A1, ZERO
101:                         rx_Buff = &rx_buffer_CAN;
9D008888  3C128000   LUI S2, -32768
9D00888C  0B402227   J .LVL31
9D008890  26520970   ADDIU S2, S2, 2416
102:                     else 
103:                         rx_Buff = &rx_buffer_CAN_Global;
9D008894  3C128000   LUI S2, -32768
9D008898  26520C9C   ADDIU S2, S2, 3228
104:                 
105:                     if ((p->canAddress >> 6) == moduleAddressCAN[_t]) {
9D00889C  96020002   LHU V0, 2(S0)
9D0088A0  278380C0   ADDIU V1, GP, -32576
9D0088A4  7C71198A   LBUX V1, S1(V1)
9D0088A8  00021182   SRL V0, V0, 6
9D0088AC  1462004E   BNE V1, V0, 0x9D0089E8
9D0088B0  8FBF001C   LW RA, 28(SP)
106:                         if (p->DLC_Code == 8 || p->DLC_Code == 9) //Check number of bytes, if 8 read in two ints
9D0088B4  92020004   LBU V0, 4(S0)
9D0088B8  2442FFF8   ADDIU V0, V0, -8
9D0088BC  304200FF   ANDI V0, V0, 255
9D0088C0  2C420002   SLTIU V0, V0, 2
9D0088C4  1040002F   BEQ V0, ZERO, .LVL38
9D0088C8  92050005   LBU A1, 5(S0)
107:                         {
108:                             if ((p->messageContents[0] << 8) +(p->messageContents[1]) < MaxIndex[_t]) {
9D0088CC  00052A00   SLL A1, A1, 8
9D0088D0  92020006   LBU V0, 6(S0)
9D0088D4  00A22821   ADDU A1, A1, V0
9D0088D8  00111080   SLL V0, S1, 2
9D0088DC  278380B8   ADDIU V1, GP, -32584
9D0088E0  7C62100A   LWX V0, V0(V1)
9D0088E4  00A2102B   SLTU V0, A1, V0
9D0088E8  5040000C   BEQL V0, ZERO, 0x9D00891C
9D0088EC  92050009   LBU A1, 9(S0)
109:                                 buffer_put(rx_Buff, (p->messageContents[0] << 8) +(p->messageContents[1]), (p->messageContents[2] << 8) +(p->messageContents[3]));
9D0088F0  92060007   LBU A2, 7(S0)
9D0088F4  00063200   SLL A2, A2, 8
9D0088F8  92020008   LBU V0, 8(S0)
9D0088FC  02402021   ADDU A0, S2, ZERO
9D008900  0F402E88   JAL buffer_put
9D008904  00C23021   ADDU A2, A2, V0
110:                                 dataReceived[_t] = 1;
9D008908  2782804C   ADDIU V0, GP, -32692
9D00890C  00511021   ADDU V0, V0, S1
9D008910  24030001   ADDIU V1, ZERO, 1
9D008914  A0430000   SB V1, 0(V0)
111:                             }
112:                             if ((p->messageContents[4] << 8) +(p->messageContents[5]) < MaxIndex[_t]) {
9D008918  92050009   LBU A1, 9(S0)
9D00891C  00052A00   SLL A1, A1, 8
9D008920  9202000A   LBU V0, 10(S0)
9D008924  00A22821   ADDU A1, A1, V0
9D008928  00111080   SLL V0, S1, 2
9D00892C  278380B8   ADDIU V1, GP, -32584
9D008930  7C62100A   LWX V0, V0(V1)
9D008934  00A2102B   SLTU V0, A1, V0
9D008938  5040000C   BEQL V0, ZERO, 0x9D00896C
9D00893C  96060002   LHU A2, 2(S0)
113:                                 buffer_put(rx_Buff, (p->messageContents[4] << 8) +(p->messageContents[5]), (p->messageContents[6] << 8) +(p->messageContents[7]));
9D008940  9206000B   LBU A2, 11(S0)
9D008944  00063200   SLL A2, A2, 8
9D008948  9202000C   LBU V0, 12(S0)
9D00894C  02402021   ADDU A0, S2, ZERO
9D008950  0F402E88   JAL buffer_put
9D008954  00C23021   ADDU A2, A2, V0
114:                                 dataReceived[_t] = 1;
9D008958  2782804C   ADDIU V0, GP, -32692
9D00895C  00518821   ADDU S1, V0, S1
9D008960  24020001   ADDIU V0, ZERO, 1
9D008964  A2220000   SB V0, 0(S1)
115:                             }
116:                             buffer_put(rx_Buff, LAST_BOARD_RECEIEVED, (p->canAddress & 0b11111));
9D008968  96060002   LHU A2, 2(S0)
9D00896C  02402021   ADDU A0, S2, ZERO
9D008970  00002821   ADDU A1, ZERO, ZERO
9D008974  0F402E88   JAL buffer_put
9D008978  30C6001F   ANDI A2, A2, 31
9D00897C  0B40227A   J 0x9D0089E8
9D008980  8FBF001C   LW RA, 28(SP)
117:                         } else //else read in one int
118:                         {
119:                             if ((p->messageContents[0] << 8) +(p->messageContents[1]) < MaxIndex[_t]) {
9D008984  00052A00   SLL A1, A1, 8
9D008988  92020006   LBU V0, 6(S0)
9D00898C  00A22821   ADDU A1, A1, V0
9D008990  00111080   SLL V0, S1, 2
9D008994  278380B8   ADDIU V1, GP, -32584
9D008998  7C62100A   LWX V0, V0(V1)
9D00899C  00A2102B   SLTU V0, A1, V0
9D0089A0  5040000C   BEQL V0, ZERO, 0x9D0089D4
9D0089A4  96060002   LHU A2, 2(S0)
120:                 
121:                                 buffer_put(rx_Buff, (p->messageContents[0] << 8) +(p->messageContents[1]), (p->messageContents[2] << 8) +(p->messageContents[3]));
9D0089A8  92060007   LBU A2, 7(S0)
9D0089AC  00063200   SLL A2, A2, 8
9D0089B0  92020008   LBU V0, 8(S0)
9D0089B4  02402021   ADDU A0, S2, ZERO
9D0089B8  0F402E88   JAL buffer_put
9D0089BC  00C23021   ADDU A2, A2, V0
122:                                 dataReceived[_t] = 1;
9D0089C0  2782804C   ADDIU V0, GP, -32692
9D0089C4  00518821   ADDU S1, V0, S1
9D0089C8  24020001   ADDIU V0, ZERO, 1
9D0089CC  A2220000   SB V0, 0(S1)
123:                             }
124:                             buffer_put(rx_Buff, LAST_BOARD_RECEIEVED, (p->canAddress & 0b11111));
9D0089D0  96060002   LHU A2, 2(S0)
9D0089D4  02402021   ADDU A0, S2, ZERO
9D0089D8  00002821   ADDU A1, ZERO, ZERO
9D0089DC  0F402E88   JAL buffer_put
9D0089E0  30C6001F   ANDI A2, A2, 31
125:                         }
126:                     }
127:                 }
9D0089E4  8FBF001C   LW RA, 28(SP)
128:                 
129:                 int ReceiveDataCAN(FT_type_t _t) {
9D009E78  27BDFFD0   ADDIU SP, SP, -48
9D009E7C  AFBF002C   SW RA, 44(SP)
9D009E80  AFB60028   SW S6, 40(SP)
9D009E84  AFB50024   SW S5, 36(SP)
9D009E88  AFB40020   SW S4, 32(SP)
9D009E8C  AFB3001C   SW S3, 28(SP)
9D009E90  AFB20018   SW S2, 24(SP)
9D009E94  AFB10014   SW S1, 20(SP)
9D009E98  AFB00010   SW S0, 16(SP)
130:                     ringBufCAN_t *rx_Buff;
131:                     if (_t == FT_LOCAL) rx_Buff = &rx_buffer_CAN;
9D009E9C  14800004   BNE A0, ZERO, 0x9D009EB0
9D009EA0  0080A821   ADDU S5, A0, ZERO
9D009EA4  3C128000   LUI S2, -32768
9D009EA8  0B4027AE   J .LVL46
9D009EAC  26520970   ADDIU S2, S2, 2416
132:                     else rx_Buff = &rx_buffer_CAN_Global;
9D009EB0  3C128000   LUI S2, -32768
9D009EB4  26520C9C   ADDIU S2, S2, 3228
133:                 
134:                     if (dataReceived[_t]) {
9D009EB8  2783804C   ADDIU V1, GP, -32692
9D009EBC  7C75198A   LBUX V1, S5(V1)
9D009EC0  10600022   BEQ V1, ZERO, .LVL59, .LBE14
9D009EC4  00001021   ADDU V0, ZERO, ZERO
135:                         dataReceived[_t] = 0;
9D009EC8  2782804C   ADDIU V0, GP, -32692
9D009ECC  00551021   ADDU V0, V0, S5
9D009ED0  A0400000   SB ZERO, 0(V0)
136:                         int i = buffer_GetCount(rx_Buff);
9D009ED4  0F40331F   JAL buffer_GetCount
9D009ED8  02402021   ADDU A0, S2, ZERO
9D009EDC  00408021   ADDU S0, V0, ZERO
137:                         if (i) //this better be true ... if not in instant receive 
9D009EE0  1200001A   BEQ S0, ZERO, .LVL59, .LBE14
9D009EE4  00001021   ADDU V0, ZERO, ZERO
138:                         {
139:                             for (; i > 0; i = i - 2) {
9D009EE8  1A000017   BLEZ S0, .LVL58
9D009EEC  0015A880   SLL S5, S5, 2
9D009F34  2610FFFE   ADDIU S0, S0, -2
9D009F38  1E00FFF2   BGTZ S0, .LBE16
9D009F3C  24020001   ADDIU V0, ZERO, 1
9D009F40  0B4027D4   J 0x9D009F50
9D009F44  8FBF002C   LW RA, 44(SP)
9D009F48  24020001   ADDIU V0, ZERO, 1
140:                                 int address = buffer_get(rx_Buff);
9D009F04  0F403160   JAL buffer_get
9D009F08  02402021   ADDU A0, S2, ZERO
9D009F0C  00408821   ADDU S1, V0, ZERO
141:                                 (receiveArrayAddressCAN[_t])[address] = buffer_get(rx_Buff);
9D009EF0  279680A0   ADDIU S6, GP, -32608
9D009EF4  02D5B021   ADDU S6, S6, S5
9D009F10  00021080   SLL V0, V0, 2
9D009F14  8ED30000   LW S3, 0(S6)
9D009F18  02629821   ADDU S3, S3, V0
9D009F1C  0F403160   JAL buffer_get
9D009F20  02402021   ADDU A0, S2, ZERO
9D009F24  AE620000   SW V0, 0(S3)
142:                                 setNewDataFlag(_t, address);
143:                             }
144:                             return 1;
145:                         } else {
146:                             //error (how was ReceiveData true if no data available)
147:                             return 0;
148:                         }
149:                 
150:                     } else
151:                         return 0;
152:                 }
9D009F4C  8FBF002C   LW RA, 44(SP)
153:                 
154:                 bool TransmitCANFast(my_can_packet_t *p) // interrupt callback
155:                 {
9D0066E4  27BDFFE0   ADDIU SP, SP, -32
9D0066E8  AFBF001C   SW RA, 28(SP)
9D0066EC  AFB20018   SW S2, 24(SP)
9D0066F0  AFB10014   SW S1, 20(SP)
9D0066F4  AFB00010   SW S0, 16(SP)
9D0066F8  00808021   ADDU S0, A0, ZERO
156:                     if (buffer_GetCount(&transmit_buffer_CAN) > 0) {
9D0066FC  3C048000   LUI A0, -32768
9D006700  0F40331F   JAL buffer_GetCount
9D006704  24840FC8   ADDIU A0, A0, 4040
9D006708  10400083   BEQ V0, ZERO, 0x9D006918
9D00670C  3C02BF88   LUI V0, -16504
157:                 
158:                         //if more than 2 data/index pairs left might be able to send large packet. 
159:                         if (buffer_GetCount(&transmit_buffer_CAN) > 6) {
9D006710  3C048000   LUI A0, -32768
9D006714  0F40331F   JAL buffer_GetCount
9D006718  24840FC8   ADDIU A0, A0, 4040
9D00671C  2C420007   SLTIU V0, V0, 7
9D006720  14400032   BNE V0, ZERO, .LVL85
9D006724  3C048000   LUI A0, -32768
160:                             unsigned int address = buffer_get(&transmit_buffer_CAN);
9D006728  3C118000   LUI S1, -32768
9D00672C  0F403160   JAL buffer_get
9D006730  26240FC8   ADDIU A0, S1, 4040
9D006734  00409021   ADDU S2, V0, ZERO
161:                             p->canAddress = (address << 6) + MY_ADDRESS; //not passed through messages will have wrong sender address
9D006738  00021180   SLL V0, V0, 6
9D00673C  24420005   ADDIU V0, V0, 5
9D006740  A6020002   SH V0, 2(S0)
162:                             //we are good to send the first index/value pair for sure. 
163:                             int i = 0;
164:                             for (i = 0; i < 2; i++) {
165:                                 unsigned int temp = buffer_get(&transmit_buffer_CAN);
9D006744  0F403160   JAL buffer_get
9D006748  26240FC8   ADDIU A0, S1, 4040
9D006758  0F403160   JAL buffer_get
9D00675C  26240FC8   ADDIU A0, S1, 4040
166:                                 p->messageContents[2 * i] = (temp >> 8);
9D00674C  00021A02   SRL V1, V0, 8
9D006750  A2030005   SB V1, 5(S0)
9D006760  00021A02   SRL V1, V0, 8
9D006764  A2030007   SB V1, 7(S0)
167:                                 p->messageContents[2 * i + 1] = temp;
9D006754  A2020006   SB V0, 6(S0)
9D006768  A2020008   SB V0, 8(S0)
168:                             }
169:                             //now we need to check that the next address matches the current address
170:                             if (buffer_peek(&transmit_buffer_CAN) == address) {
9D00676C  0F403250   JAL buffer_peek
9D006770  26240FC8   ADDIU A0, S1, 4040
9D006774  14520019   BNE V0, S2, .LVL84, .LBB24
9D006778  00408821   ADDU S1, V0, ZERO
171:                                 //address match and we are clear to send them in a single packet
172:                                 buffer_get(&transmit_buffer_CAN); //call this to clear out the address
9D00677C  3C128000   LUI S2, -32768
9D006780  0F403160   JAL buffer_get
9D006784  26440FC8   ADDIU A0, S2, 4040
173:                                 int i = 0;
174:                                 for (i = 2; i < 4; i++) {
175:                                     unsigned int temp = buffer_get(&transmit_buffer_CAN);
9D006788  0F403160   JAL buffer_get
9D00678C  26440FC8   ADDIU A0, S2, 4040
9D00679C  0F403160   JAL buffer_get
9D0067A0  26440FC8   ADDIU A0, S2, 4040
176:                                     p->messageContents[2 * i] = (temp >> 8);
9D006790  00021A02   SRL V1, V0, 8
9D006794  A2030009   SB V1, 9(S0)
9D0067A4  00021A02   SRL V1, V0, 8
9D0067A8  A203000B   SB V1, 11(S0)
177:                                     p->messageContents[2 * i + 1] = temp;
9D006798  A202000A   SB V0, 10(S0)
9D0067AC  A202000C   SB V0, 12(S0)
178:                                 }
179:                                 //need to check if this was the last packet 
180:                                 if (buffer_peek(&transmit_buffer_CAN) == address) {
9D0067B0  0F403250   JAL buffer_peek
9D0067B4  26440FC8   ADDIU A0, S2, 4040
9D0067B8  56220005   BNEL S1, V0, 0x9D0067D0
9D0067BC  24020009   ADDIU V0, ZERO, 9
181:                                     //next address is same, so this isn't the last packet, send a length 8.
182:                                     p->DLC_Code = 8;
9D0067C0  24020008   ADDIU V0, ZERO, 8
9D0067C4  A2020004   SB V0, 4(S0)
9D0067C8  0B401A4A   J 0x9D006928
9D0067CC  24020001   ADDIU V0, ZERO, 1
183:                                 } else {
184:                                     //next address is different, and this is the last packet, so send a 9.
185:                                     p->DLC_Code = 9;
9D0067D0  A2020004   SB V0, 4(S0)
186:                                 }
187:                             } else {
188:                                 //addresses don't match and we should just send what is currently in the packet. 
189:                                 p->DLC_Code = 4;
9D0067DC  24020004   ADDIU V0, ZERO, 4
9D0067E0  A2020004   SB V0, 4(S0)
190:                             }
191:                         }//if exactly 2 data/index pairs left send with length 9. Receiver
192:                             //will read the "wrong" length correctly, but realize this is the last packet.
193:                             //note: still need to check incase two different destinations. 
194:                         else if (buffer_GetCount(&transmit_buffer_CAN) == 6) {
9D0067EC  0F40331F   JAL buffer_GetCount
9D0067F0  24840FC8   ADDIU A0, A0, 4040
9D0067F4  24030006   ADDIU V1, ZERO, 6
9D0067F8  14430029   BNE V0, V1, .LVL103
9D0067FC  3C048000   LUI A0, -32768
195:                             unsigned int address = buffer_get(&transmit_buffer_CAN);
9D006800  3C118000   LUI S1, -32768
9D006804  0F403160   JAL buffer_get
9D006808  26240FC8   ADDIU A0, S1, 4040
9D00680C  00409021   ADDU S2, V0, ZERO
196:                             p->canAddress = (address << 6) + MY_ADDRESS; //not passed through messages will have wrong sender address
9D006810  00021180   SLL V0, V0, 6
9D006814  24420005   ADDIU V0, V0, 5
9D006818  A6020002   SH V0, 2(S0)
197:                             //we are good to send the first index/value pair for sure.
198:                             int i = 0;
199:                             for (i = 0; i < 2; i++) {
200:                                 unsigned int temp = buffer_get(&transmit_buffer_CAN);
9D00681C  0F403160   JAL buffer_get
9D006820  26240FC8   ADDIU A0, S1, 4040
9D006830  0F403160   JAL buffer_get
9D006834  26240FC8   ADDIU A0, S1, 4040
201:                                 p->messageContents[2 * i] = (temp >> 8); //this is so dumb
9D006824  00021A02   SRL V1, V0, 8
9D006828  A2030005   SB V1, 5(S0)
9D006838  00021A02   SRL V1, V0, 8
9D00683C  A2030007   SB V1, 7(S0)
202:                                 p->messageContents[2 * i + 1] = temp;
9D00682C  A2020006   SB V0, 6(S0)
9D006840  A2020008   SB V0, 8(S0)
203:                             }
204:                             //now we need to check that the next address matches the current address
205:                             if (buffer_peek(&transmit_buffer_CAN) == address) {
9D006844  0F403250   JAL buffer_peek
9D006848  26240FC8   ADDIU A0, S1, 4040
9D00684C  54520011   BNEL V0, S2, .LVL102
9D006850  24020004   ADDIU V0, ZERO, 4
206:                                 //address match and we are clear to send them in a single packet
207:                                 buffer_get(&transmit_buffer_CAN); //call this to clear out the address
9D006854  0F403160   JAL buffer_get
9D006858  26240FC8   ADDIU A0, S1, 4040
208:                                 int i = 0;
209:                                 for (i = 2; i < 4; i++) {
210:                                     unsigned int temp = buffer_get(&transmit_buffer_CAN);
9D00685C  0F403160   JAL buffer_get
9D006860  26240FC8   ADDIU A0, S1, 4040
9D006870  0F403160   JAL buffer_get
9D006874  26240FC8   ADDIU A0, S1, 4040
211:                                     p->messageContents[2 * i] = (temp >> 8);
9D006864  00021A02   SRL V1, V0, 8
9D006868  A2030009   SB V1, 9(S0)
9D006878  00021A02   SRL V1, V0, 8
9D00687C  A203000B   SB V1, 11(S0)
212:                                     p->messageContents[2 * i + 1] = temp;
9D00686C  A202000A   SB V0, 10(S0)
9D006880  A202000C   SB V0, 12(S0)
213:                                 }
214:                                 p->DLC_Code = 9;
9D006884  24020009   ADDIU V0, ZERO, 9
9D006888  A2020004   SB V0, 4(S0)
9D00688C  0B401A4A   J 0x9D006928
9D006890  24020001   ADDIU V0, ZERO, 1
215:                             } else {
216:                                 //addresses don't match and we should just send what is currently in the packet.
217:                                 p->DLC_Code = 4;
9D006894  A2020004   SB V0, 4(S0)
218:                             }
219:                 
220:                         }//if only 1 data/index pair receiver will know it is the last packet.
221:                         else if (buffer_GetCount(&transmit_buffer_CAN) == 3) {
9D0068A0  0F40331F   JAL buffer_GetCount
9D0068A4  24840FC8   ADDIU A0, A0, 4040
9D0068A8  24030003   ADDIU V1, ZERO, 3
9D0068AC  14430015   BNE V0, V1, .LVL112
9D0068B0  3C048000   LUI A0, -32768
222:                             unsigned int address = buffer_get(&transmit_buffer_CAN);
9D0068B4  3C118000   LUI S1, -32768
9D0068B8  0F403160   JAL buffer_get
9D0068BC  26240FC8   ADDIU A0, S1, 4040
223:                             p->canAddress = (address << 6) + MY_ADDRESS; //not passed through messages will have wrong sender address
9D0068C0  00021180   SLL V0, V0, 6
9D0068C4  24420005   ADDIU V0, V0, 5
9D0068C8  A6020002   SH V0, 2(S0)
224:                             p->DLC_Code = 4;
9D0068CC  24020004   ADDIU V0, ZERO, 4
9D0068D0  A2020004   SB V0, 4(S0)
225:                             int i = 0;
226:                             for (i = 0; i < 2; i++) {
227:                                 unsigned int temp = buffer_get(&transmit_buffer_CAN);
9D0068D4  0F403160   JAL buffer_get
9D0068D8  26240FC8   ADDIU A0, S1, 4040
9D0068E8  0F403160   JAL buffer_get
9D0068EC  26240FC8   ADDIU A0, S1, 4040
228:                                 p->messageContents[2 * i] = (temp >> 8);
9D0068DC  00021A02   SRL V1, V0, 8
9D0068E0  A2030005   SB V1, 5(S0)
9D0068F0  00021A02   SRL V1, V0, 8
9D0068F4  A2030007   SB V1, 7(S0)
229:                                 p->messageContents[2 * i + 1] = temp;
9D0068E4  A2020006   SB V0, 6(S0)
9D0068F8  A2020008   SB V0, 8(S0)
230:                             }
231:                         } else {
232:                             //error, missing dest/index/value set, previous packets could be very corrupt
233:                             //TransmitSetMissMatch++;
234:                             buffer_flush(&transmit_buffer_CAN, 1);
9D006904  24840FC8   ADDIU A0, A0, 4040
9D006908  0F4031A6   JAL buffer_flush
9D00690C  24050001   ADDIU A1, ZERO, 1
235:                             return false;
9D006910  0B401A4A   J 0x9D006928
9D006914  00001021   ADDU V0, ZERO, ZERO
236:                         }
237:                         return true;
9D0067D4  0B401A4A   J 0x9D006928
9D0067D8  24020001   ADDIU V0, ZERO, 1
9D0067E4  0B401A4A   J 0x9D006928
9D0067E8  24020001   ADDIU V0, ZERO, 1
9D006898  0B401A4A   J 0x9D006928
9D00689C  24020001   ADDIU V0, ZERO, 1
9D0068FC  0B401A4A   J 0x9D006928
9D006900  24020001   ADDIU V0, ZERO, 1
238:                     } else {
239:                         C1FIFOINT2bits.TXEMPTYIE = 0;
9D006918  8C4303E0   LW V1, 992(V0)
9D00691C  7C03C604   INS V1, ZERO, 24, 1
9D006920  AC4303E0   SW V1, 992(V0)
240:                 
241:                         return false;
9D006924  00001021   ADDU V0, ZERO, ZERO
242:                     }
243:                 }
9D006928  8FBF001C   LW RA, 28(SP)
244:                 
245:                 void ToSendCAN(unsigned int where, unsigned int what) {
9D00C798  27BDFFE8   ADDIU SP, SP, -24
9D00C79C  AFBF0014   SW RA, 20(SP)
9D00C7A0  00801021   ADDU V0, A0, ZERO
9D00C7A4  00A03021   ADDU A2, A1, ZERO
246:                 
247:                     buffer_put(&send_buffer_CAN_FT, where, what);
9D00C7A8  3C048000   LUI A0, -32768
9D00C7AC  24840630   ADDIU A0, A0, 1584
9D00C7B0  0F402E88   JAL buffer_put
9D00C7B4  00402821   ADDU A1, V0, ZERO
248:                 }
9D00C7B8  8FBF0014   LW RA, 20(SP)
249:                 
250:                 void sendDataCAN(unsigned int whereToSend) {
9D00A580  27BDFFD0   ADDIU SP, SP, -48
9D00A584  AFBF002C   SW RA, 44(SP)
9D00A588  AFB50028   SW S5, 40(SP)
9D00A58C  AFB40024   SW S4, 36(SP)
9D00A590  AFB30020   SW S3, 32(SP)
9D00A594  AFB2001C   SW S2, 28(SP)
9D00A598  AFB10018   SW S1, 24(SP)
9D00A59C  AFB00014   SW S0, 20(SP)
9D00A5A0  0080A021   ADDU S4, A0, ZERO
251:                     //NEW STATIC METHOD
252:                     int temp = buffer_GetCount(&send_buffer_CAN_FT); //get size of things to send
9D00A5A4  3C048000   LUI A0, -32768
9D00A5A8  0F40331F   JAL buffer_GetCount
9D00A5AC  24840630   ADDIU A0, A0, 1584
253:                 
254:                     int i = 0;
255:                     for (i = 0; i < (temp >> 1); i++) { //need to divid by two since reading index/value pairs, hence >>1
9D00A5B0  00029843   SRA S3, V0, 1
9D00A5B4  1A600012   BLEZ S3, .LVL128
9D00A5B8  00008021   ADDU S0, ZERO, ZERO
9D00A5F4  26100001   ADDIU S0, S0, 1
9D00A5F8  1613FFF4   BNE S0, S3, .LVL122
9D00A5FC  00000000   NOP
256:                         int index = buffer_get(&send_buffer_CAN_FT);
9D00A5BC  3C118000   LUI S1, -32768
9D00A5C0  26310630   ADDIU S1, S1, 1584
9D00A5CC  0F403160   JAL buffer_get
9D00A5D0  02202021   ADDU A0, S1, ZERO
9D00A5D4  00409021   ADDU S2, V0, ZERO
257:                         int value = buffer_get(&send_buffer_CAN_FT);
9D00A5D8  0F403160   JAL buffer_get
9D00A5DC  02202021   ADDU A0, S1, ZERO
258:                         buffer_put_3(&transmit_buffer_CAN, whereToSend, index, value);
9D00A5C4  3C158000   LUI S5, -32768
9D00A5C8  26B50FC8   ADDIU S5, S5, 4040
9D00A5E0  02A02021   ADDU A0, S5, ZERO
9D00A5E4  02802821   ADDU A1, S4, ZERO
9D00A5E8  02403021   ADDU A2, S2, ZERO
9D00A5EC  0F402B9E   JAL buffer_put_3
9D00A5F0  00403821   ADDU A3, V0, ZERO
259:                     }
260:                     if (C1FIFOINT2bits.TXEMPTYIE == 0) {
9D00A600  3C02BF88   LUI V0, -16504
9D00A604  8C4203E0   LW V0, 992(V0)
9D00A608  7C420600   EXT V0, V0, 24, 1
9D00A60C  14400005   BNE V0, ZERO, 0x9D00A624
9D00A610  3C02BF88   LUI V0, -16504
261:                 
262:                         C1FIFOINT2bits.TXEMPTYIE = 1;
9D00A614  8C4303E0   LW V1, 992(V0)
9D00A618  24040001   ADDIU A0, ZERO, 1
9D00A61C  7C83C604   INS V1, A0, 24, 1
9D00A620  AC4303E0   SW V1, 992(V0)
263:                     }
264:                 }
9D00A624  8FBF002C   LW RA, 44(SP)
265:                 
266:                 
267:                 
268:                 int GlobalAddressInturpret(int index) {
269:                     return MY_ADDRESS * GLOBAL_SYSTEM_DATA_SIZE + index;
270:                 }
00000000  00000000   NOP
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/can_handler/canbufferhandler.c
1:                   
2:                   #include "CANbufferHandler.h"
3:                   #include <stdint.h>
4:                   
5:                   
6:                   void buffer_put(ringBufCAN_t *_this, unsigned int towhere, unsigned int towhat) {
7:                   
8:                   
9:                       if (_this->count < (BUFFER_SIZE_CAN - 3)) {
9D00BA20  8C820328   LW V0, 808(A0)
9D00BA24  284300C5   SLTI V1, V0, 197
9D00BA28  10600015   BEQ V1, ZERO, .LVL9
9D00BA2C  00000000   NOP
10:                  
11:                          _this->buf[_this->head] = towhere;
9D00BA30  8C830320   LW V1, 800(A0)
9D00BA34  00033880   SLL A3, V1, 2
9D00BA38  00873821   ADDU A3, A0, A3
9D00BA3C  ACE50000   SW A1, 0(A3)
12:                          _this->head = buffer_modulo_inc(_this->head, BUFFER_SIZE_CAN);
13:                          ++_this->count;
14:                          _this->buf[_this->head] = towhat;
9D00BA50  00052880   SLL A1, A1, 2
9D00BA54  00852821   ADDU A1, A0, A1
9D00BA58  ACA60000   SW A2, 0(A1)
15:                          _this->head = buffer_modulo_inc(_this->head, BUFFER_SIZE_CAN);
9D00BA68  AC830320   SW V1, 800(A0)
16:                          ++_this->count;
9D00BA6C  24420002   ADDIU V0, V0, 2
9D00BA70  03E00008   JR RA
9D00BA74  AC820328   SW V0, 808(A0)
17:                      }
18:                  
19:                  }
20:                  
21:                  void buffer_put_3(ringBufCAN_t *_this, unsigned int towhere, unsigned int towhat, unsigned int val) {
22:                      if (_this->count < (BUFFER_SIZE_CAN - 3)) {
9D00AE78  8C820328   LW V0, 808(A0)
9D00AE7C  284300C5   SLTI V1, V0, 197
9D00AE80  10600022   BEQ V1, ZERO, .LVL26
9D00AE84  00000000   NOP
23:                  
24:                          _this->buf[_this->head] = towhere;
9D00AE88  8C830320   LW V1, 800(A0)
9D00AE8C  00034080   SLL T0, V1, 2
9D00AE90  00884021   ADDU T0, A0, T0
9D00AE94  AD050000   SW A1, 0(T0)
25:                          _this->head = buffer_modulo_inc(_this->head, BUFFER_SIZE_CAN);
9D00AEA8  AC850320   SW A1, 800(A0)
26:                          ++_this->count;
9D00AEAC  24480001   ADDIU T0, V0, 1
9D00AEB0  AC880328   SW T0, 808(A0)
27:                          _this->buf[_this->head] = towhat;
9D00AEB4  00052880   SLL A1, A1, 2
9D00AEB8  00852821   ADDU A1, A0, A1
9D00AEBC  ACA60000   SW A2, 0(A1)
28:                          _this->head = buffer_modulo_inc(_this->head, BUFFER_SIZE_CAN);
29:                          ++_this->count;
30:                          _this->buf[_this->head] = val;
9D00AED0  00052880   SLL A1, A1, 2
9D00AED4  00852821   ADDU A1, A0, A1
9D00AED8  ACA70000   SW A3, 0(A1)
9D00AEF8  AC870004   SW A3, 4(A0)
31:                          _this->head = buffer_modulo_inc(_this->head, BUFFER_SIZE_CAN);
9D00AEE8  AC830320   SW V1, 800(A0)
32:                          ++_this->count;
9D00AEEC  24420003   ADDIU V0, V0, 3
9D00AEF0  03E00008   JR RA
9D00AEF4  AC820328   SW V0, 808(A0)
33:                      }
34:                  
35:                  }
36:                  
37:                  
38:                  //pulls info out of the send buffer in a first in first out fashion
39:                  
40:                  unsigned int buffer_get(ringBufCAN_t* _this) {
41:                      unsigned int c;
42:                      if (_this->count > 0) {
9D00C580  8C850328   LW A1, 808(A0)
9D00C584  18A0000A   BLEZ A1, .LVL32
9D00C588  24A5FFFF   ADDIU A1, A1, -1
43:                          c = _this->buf[_this->tail];
9D00C58C  8C830324   LW V1, 804(A0)
9D00C590  00031080   SLL V0, V1, 2
9D00C594  7C82100A   LWX V0, V0(A0)
44:                          _this->tail = buffer_modulo_inc(_this->tail, BUFFER_SIZE_CAN);
9D00C5A4  AC830324   SW V1, 804(A0)
9D00C5A8  03E00008   JR RA
9D00C5AC  AC850328   SW A1, 808(A0)
45:                          --_this->count;
46:                      } else {
47:                  
48:                          c = 0;
49:                      }
50:                      return (c);
51:                  }
9D00C5B0  03E00008   JR RA
52:                  
53:                  unsigned int buffer_peek(ringBufCAN_t* _this) {
54:                      unsigned int c;
55:                      if (_this->count > 0) {
9D00C940  8C820328   LW V0, 808(A0)
9D00C944  18400005   BLEZ V0, 0x9D00C95C
9D00C948  00000000   NOP
56:                          c = _this->buf[_this->tail];
9D00C94C  8C820324   LW V0, 804(A0)
9D00C950  00021080   SLL V0, V0, 2
9D00C954  03E00008   JR RA
9D00C958  7C82100A   LWX V0, V0(A0)
57:                      } else {
58:                  
59:                          c = 0;
60:                      }
61:                      return (c);
62:                  }
9D00C95C  03E00008   JR RA
63:                  
64:                  
65:                  //flushes the send buffer to get it ready for new data
66:                  
67:                  void buffer_flush(ringBufCAN_t* _this, const int clearBuffer) {
9D00C6A8  27BDFFE8   ADDIU SP, SP, -24
9D00C6AC  AFBF0014   SW RA, 20(SP)
68:                      _this->count = 0;
9D00C698  AC800328   SW ZERO, 808(A0)
69:                      _this->head = 0;
9D00C69C  AC800320   SW ZERO, 800(A0)
70:                      _this->tail = 0;
71:                      if (clearBuffer) {
9D00C6A0  10A00008   BEQ A1, ZERO, .LCFI2
9D00C6A4  AC800324   SW ZERO, 804(A0)
72:                  
73:                          wipeBuffer(_this->buf, 0, sizeof (_this->buf));
9D00C6B0  00002821   ADDU A1, ZERO, ZERO
9D00C6B4  0F403259   JAL wipeBuffer
9D00C6B8  24060320   ADDIU A2, ZERO, 800
74:                      }
75:                  }
9D00C6BC  8FBF0014   LW RA, 20(SP)
76:                  
77:                  void wipeBuffer(int*buf, int val, uint16_t numVals) {
78:                      int i = 0;
79:                      for (i = 0; i < numVals; i++) {
9D00C964  18C00006   BLEZ A2, 0x9D00C980
80:                  
81:                          buf[i] = val;
82:                      }
83:                  }
84:                  
85:                  // increments counters for the buffer functions
86:                  
87:                  unsigned int buffer_modulo_inc(const unsigned int value, const unsigned int modulus) {
88:                      unsigned int my_value = value + 1;
9D00AE98  24650001   ADDIU A1, V1, 1
9D00AEC0  24650002   ADDIU A1, V1, 2
9D00AEDC  24630003   ADDIU V1, V1, 3
9D00AEFC  0B402BBA   J .LVL22, .LBE21, .LBE20
9D00BA40  24650001   ADDIU A1, V1, 1
9D00BA5C  24630002   ADDIU V1, V1, 2
9D00BA78  0B402E9A   J .LVL7, .LBE9, .LBE8
9D00C598  24630001   ADDIU V1, V1, 1
00000000  00000000   NOP
89:                      if (my_value >= modulus) {
9D00AE9C  2CA800C8   SLTIU T0, A1, 200
9D00AEC4  2CA600C8   SLTIU A2, A1, 200
9D00AEE0  2C6500C8   SLTIU A1, V1, 200
9D00BA44  2CA700C8   SLTIU A3, A1, 200
9D00BA60  2C6500C8   SLTIU A1, V1, 200
9D00C59C  2C6600C8   SLTIU A2, V1, 200
00000004  00000000   NOP
90:                  
91:                          my_value = 0;
9D00AEE4  0005180A   MOVZ V1, ZERO, A1
9D00BA64  0005180A   MOVZ V1, ZERO, A1
9D00C5A0  0006180A   MOVZ V1, ZERO, A2
92:                      }
93:                      return (my_value);
94:                  }
00000008  00000000   NOP
95:                  
96:                  //getter for send circular buffer. 
97:                  
98:                  unsigned int buffer_GetCount(ringBufCAN_t* _this) {
99:                  
100:                     return _this->count;
101:                 }
9D00CC7C  03E00008   JR RA
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/can_handler/can.c  
1:                   /* ************************************************************************** */
2:                   /** Descriptive File Name
3:                   
4:                     @Company
5:                       Company Name
6:                   
7:                     @File Name
8:                       filename.c
9:                   
10:                    @Summary
11:                      Brief description of the file.
12:                  
13:                    @Description
14:                      Describe the purpose of this file.
15:                   */
16:                  /* ************************************************************************** */
17:                  #include "CAN.h"
18:                  //#include <proc/p32mz2048efh.h>
19:                  #include "../../../../../framework/driver/can/drv_can.h"
20:                  #include "Definitions.h"
21:                  #include "Timers.h"
22:                  #include "CAN_Handler/CANFastTransfer.h"
23:                  
24:                  #define CHANNEL_0_CAN 0
25:                  #define CHANNEL_1_CAN 1
26:                  #define CHANNEL_2_CAN 2
27:                  #define CHANNEL_3_CAN 3
28:                  #define CHANNEL_4_CAN 4
29:                  
30:                  
31:                  typedef struct {
32:                      int rx_requested;
33:                      Data_t *callback;
34:                      uint16_t CANID;
35:                      uint16_t contentsID;
36:                  } rx_message_tracking_t;
37:                  
38:                  rx_message_tracking_t rx_message_requested[CAN_BUFFER_PACKET_LENGTH];
39:                  my_can_buffer_t CAN_tx_buffer;
40:                  my_can_buffer_t CAN_rx_buffer;
41:                  my_can_buffer_t tx_FT_buffer;
42:                  my_can_buffer_t rx_FT_buffer;
43:                  int lastMessageIndexSent = 0;
44:                  
45:                  bool transmitStallCAN = true;
46:                  bool transmitStallCAN_FT = true;
47:                  volatile bool CANRxAvailable = false;
48:                  volatile bool awaitingResponse = false;
49:                  volatile bool CANRxAvailable_FT = false;
50:                  
51:                  void copyMessageArrays(uint8_t * intoThis, uint8_t * fromThis);
52:                  
53:                  void initCANISRs(void) {
9D00A9FC  27BDFFE8   ADDIU SP, SP, -24
9D00AA00  AFBF0014   SW RA, 20(SP)
9D00AA04  AFB00010   SW S0, 16(SP)
54:                      CANwipeBuffer(&CAN_tx_buffer);
9D00AA08  3C048000   LUI A0, -32768
9D00AA0C  0F402E35   JAL CANwipeBuffer
9D00AA10  24843D3C   ADDIU A0, A0, 15676
55:                      CANwipeBuffer(&CAN_rx_buffer);
9D00AA14  3C048000   LUI A0, -32768
9D00AA18  0F402E35   JAL CANwipeBuffer
9D00AA1C  248412F4   ADDIU A0, A0, 4852
56:                      C1FIFOINT1bits.RXNEMPTYIE = 1; //Interrupt when the RX has something in it
9D00AA20  3C02BF88   LUI V0, -16504
9D00AA24  8C4303A0   LW V1, 928(V0)
9D00AA28  24100001   ADDIU S0, ZERO, 1
9D00AA2C  7E038404   INS V1, S0, 16, 1
9D00AA30  AC4303A0   SW V1, 928(V0)
57:                      //C1FIFOINT0bits.TXEMPTYIE    =   1;  //Interrupt when the TX has room available
58:                  
59:                  
60:                      CANwipeBuffer(&tx_FT_buffer);
9D00AA34  3C048000   LUI A0, -32768
9D00AA38  0F402E35   JAL CANwipeBuffer
9D00AA3C  2484274C   ADDIU A0, A0, 10060
61:                      CANwipeBuffer(&rx_FT_buffer);
9D00AA40  3C048000   LUI A0, -32768
9D00AA44  0F402E35   JAL CANwipeBuffer
9D00AA48  24843244   ADDIU A0, A0, 12868
62:                      C1FIFOINT3bits.RXNEMPTYIE = 1; //Interrupt when the RX has something in it
9D00AA4C  3C02BF88   LUI V0, -16504
9D00AA50  8C430420   LW V1, 1056(V0)
9D00AA54  7E038404   INS V1, S0, 16, 1
9D00AA58  AC430420   SW V1, 1056(V0)
9D00AA5C  3C028000   LUI V0, -32768
9D00AA60  24421DF4   ADDIU V0, V0, 7668
9D00AA64  3C038000   LUI V1, -32768
9D00AA68  24632754   ADDIU V1, V1, 10068
63:                      //C1FIFOINT0bits.TXEMPTYIE    =   1;  //Interrupt when the TX has room available
64:                  
65:                      //Init the rx request tracking holder
66:                      int i = 0;
67:                      for (i = 0; i < CAN_BUFFER_PACKET_LENGTH; i++) {
9D00AA78  5443FFFD   BNEL V0, V1, 0x9D00AA70
9D00AA7C  A4400000   SH ZERO, 0(V0)
68:                          rx_message_requested[i].CANID = 0;
9D00AA6C  A4400000   SH ZERO, 0(V0)
69:                          rx_message_requested[i].rx_requested = 0;
9D00AA70  AC40FFF8   SW ZERO, -8(V0)
9D00AA74  2442000C   ADDIU V0, V0, 12
70:                      }
71:                  
72:                      C1INTbits.RBIE = 1; //Enable all RX interrupts to trigger an interrupt
9D00AA80  3C02BF88   LUI V0, -16504
9D00AA84  8C430020   LW V1, 32(V0)
9D00AA88  24040001   ADDIU A0, ZERO, 1
9D00AA8C  7C838C44   INS V1, A0, 17, 1
9D00AA90  AC430020   SW V1, 32(V0)
73:                      C1INTbits.TBIE = 1; //Enable all transmit interrupts
9D00AA94  8C430020   LW V1, 32(V0)
9D00AA98  7C838404   INS V1, A0, 16, 1
9D00AA9C  AC430020   SW V1, 32(V0)
74:                  }
9D00AAA0  8FBF0014   LW RA, 20(SP)
75:                  
76:                  void CAN_ISR_CALLBACK(void) {
9D003918  27BDFFD0   ADDIU SP, SP, -48
9D00391C  AFBF002C   SW RA, 44(SP)
9D003920  AFB20028   SW S2, 40(SP)
9D003924  AFB10024   SW S1, 36(SP)
9D003928  AFB00020   SW S0, 32(SP)
77:                      /*** CAN FAST_TRANSFER RECEIVE (local & Global)***/
78:                      if (C1FIFOINT3bits.RXNEMPTYIF || C1FIFOINT4bits.RXNEMPTYIF) //RBIF
9D00392C  3C02BF88   LUI V0, -16504
9D003930  8C420420   LW V0, 1056(V0)
9D003934  30420001   ANDI V0, V0, 1
9D003938  14400007   BNE V0, ZERO, 0x9D003958
9D00393C  3C02BF88   LUI V0, -16504
9D003940  3C02BF88   LUI V0, -16504
9D003944  8C420460   LW V0, 1120(V0)
9D003948  30420001   ANDI V0, V0, 1
9D00394C  10400031   BEQ V0, ZERO, 0x9D003A14
9D003950  3C02BF88   LUI V0, -16504
79:                      {
80:                          int CHANNEL;
81:                          if (C1FIFOINT3bits.RXNEMPTYIF) {
9D003954  3C02BF88   LUI V0, -16504
9D003958  8C500420   LW S0, 1056(V0)
9D00395C  32100001   ANDI S0, S0, 1
82:                              //System Receive
83:                              CHANNEL = CHANNEL_3_CAN;
9D003960  24020003   ADDIU V0, ZERO, 3
9D003964  24030004   ADDIU V1, ZERO, 4
9D003968  0070100A   MOVZ V0, V1, S0
9D00396C  00408021   ADDU S0, V0, ZERO
84:                          } else {
85:                              //Global Receive
86:                              CHANNEL = CHANNEL_4_CAN;
87:                          }
88:                  
89:                          CAN_RX_MSG_BUFFER * RxMessage;
90:                          /* Get the channel RX status */
91:                  
92:                          CAN_CHANNEL_EVENT ChannelEvent;
93:                          ChannelEvent = PLIB_CAN_ChannelEventGet(CAN_ID_1, CHANNEL);
9D003970  00409021   ADDU S2, V0, ZERO
94:                  
95:                          /* Check if there is a message available to read. */
96:                          if ((ChannelEvent & CAN_RX_CHANNEL_NOT_EMPTY) == CAN_RX_CHANNEL_NOT_EMPTY) {
9D003984  30420001   ANDI V0, V0, 1
9D003988  5040000D   BEQL V0, ZERO, 0x9D0039C0
9D00398C  A3B00010   SB S0, 16(SP)
97:                              RxMessage = (CAN_RX_MSG_BUFFER *) PLIB_CAN_ReceivedMessageGet(CAN_ID_1, CHANNEL);
98:                          }
99:                          my_can_packet_t rxPacket;
100:                 
101:                         rxPacket.canChannel = CHANNEL;
9D0039BC  A3B00010   SB S0, 16(SP)
102:                         rxPacket.canAddress = (uint16_t) RxMessage->msgSID.sid;
9D0039C0  8CA20000   LW V0, 0(A1)
9D0039C4  7C425000   EXT V0, V0, 0, 11
9D0039C8  A7A20012   SH V0, 18(SP)
103:                         rxPacket.DLC_Code = RxMessage->msgEID.data_length_code;
9D0039CC  8CA20004   LW V0, 4(A1)
9D0039D0  7C421800   EXT V0, V0, 0, 4
9D0039D4  A3A20014   SB V0, 20(SP)
104:                         copyMessageArrays(rxPacket.messageContents, RxMessage->data);
9D0039D8  27A40015   ADDIU A0, SP, 21
9D0039DC  0F403262   JAL copyMessageArrays
9D0039E0  24A50008   ADDIU A1, A1, 8
105:                 
106:                         //CANbufPut(&rx_FT_buffer,rxPacket);
107:                         ReceiveCANFast(&rxPacket,(CHANNEL == CHANNEL_3_CAN? FT_LOCAL : FT_GLOBAL));
9D0039E4  3A050003   XORI A1, S0, 3
9D0039E8  27A40010   ADDIU A0, SP, 16
9D0039EC  0F40221A   JAL ReceiveCANFast
9D0039F0  0005282B   SLTU A1, ZERO, A1
108:                         /* Message processing is done, update the message buffer pointer. */
109:                         PLIB_CAN_ChannelUpdate(CAN_ID_1, CHANNEL);
110:                         CANRxAvailable_FT = true;
9D003A08  24020001   ADDIU V0, ZERO, 1
9D003A0C  A3828050   SB V0, -32688(GP)
111:                 
112:                     }
113:                     /*** CAN FAST_TRANSFER TRANSMIT ***/
114:                     if (C1FIFOINT2bits.TXEMPTYIF) //TBIF
9D003A10  3C02BF88   LUI V0, -16504
9D003A14  8C4203E0   LW V0, 992(V0)
9D003A18  30420100   ANDI V0, V0, 256
9D003A1C  1040000B   BEQ V0, ZERO, 0x9D003A4C
9D003A20  3C02BF88   LUI V0, -16504
115:                     {
116:                         my_can_packet_t sendingNext; // = CANbufGet(&tx_FT_buffer);
117:                         if (TransmitCANFast(&sendingNext))
9D003A24  0F4019B9   JAL TransmitCANFast
9D003A28  27A40010   ADDIU A0, SP, 16
9D003A2C  10400007   BEQ V0, ZERO, 0x9D003A4C
9D003A30  3C02BF88   LUI V0, -16504
118:                             DRV_CAN0_ChannelMessageTransmit(CHANNEL_2_CAN, sendingNext.canAddress, sendingNext.DLC_Code, sendingNext.messageContents);
9D003A34  24040002   ADDIU A0, ZERO, 2
9D003A38  97A50012   LHU A1, 18(SP)
9D003A3C  93A60014   LBU A2, 20(SP)
9D003A40  0F4026D8   JAL DRV_CAN0_ChannelMessageTransmit
9D003A44  27A70015   ADDIU A3, SP, 21
119:                 
120:                     }
121:                 
122:                     /*** MOTORS RECEIVE ***/
123:                     if (C1FIFOINT1bits.RXNEMPTYIF) //RBIF
9D003A48  3C02BF88   LUI V0, -16504
9D003A4C  8C4203A0   LW V0, 928(V0)
9D003A50  30420001   ANDI V0, V0, 1
9D003A54  104000B6   BEQ V0, ZERO, 0x9D003D30
9D003A58  3C02BF88   LUI V0, -16504
124:                     {
125:                 
126:                         CAN_RX_MSG_BUFFER * RxMessage;
127:                         /* Get the channel RX status */
128:                 
129:                         CAN_CHANNEL_EVENT ChannelEvent;
130:                         ChannelEvent = PLIB_CAN_ChannelEventGet(CAN_ID_1, CHANNEL_1_CAN);
131:                 
132:                         /* Check if there is a message available to read. */
133:                         if ((ChannelEvent & CAN_RX_CHANNEL_NOT_EMPTY) == CAN_RX_CHANNEL_NOT_EMPTY) {
9D003A64  30420001   ANDI V0, V0, 1
9D003A68  1040000C   BEQ V0, ZERO, 0x9D003A9C
9D003A6C  24020001   ADDIU V0, ZERO, 1
134:                             RxMessage = (CAN_RX_MSG_BUFFER *) PLIB_CAN_ReceivedMessageGet(CAN_ID_1, CHANNEL_1_CAN);
135:                         } else {
136:                 
137:                         }
138:                         my_can_packet_t rxPacket;
139:                 
140:                         rxPacket.canChannel = 1;
9D003A98  24020001   ADDIU V0, ZERO, 1
9D003A9C  A3A20010   SB V0, 16(SP)
141:                         rxPacket.canAddress = RxMessage->msgSID.sid;
9D003AA0  8E220000   LW V0, 0(S1)
9D003AA4  7C425000   EXT V0, V0, 0, 11
9D003AA8  A7A20012   SH V0, 18(SP)
142:                         copyMessageArrays(rxPacket.messageContents, RxMessage->data);
9D003AAC  27A40015   ADDIU A0, SP, 21
9D003AB0  0F403262   JAL copyMessageArrays
9D003AB4  26250008   ADDIU A1, S1, 8
143:                 
144:                         //Should contain the length identifier
145:                         rxPacket.DLC_Code = rxPacket.messageContents[0]; //RX contents ( 0x41=4 Byte, 0x43=4Byte, 0x4B=2 Byte, 0x4F=1 Byte) TX contents (0x60))
9D003AB8  93A30015   LBU V1, 21(SP)
9D003ABC  A3A30014   SB V1, 20(SP)
146:                 
147:                         //        printf("rxAddr %x\r",rxPacket.canAddress);
148:                         //        if((char)(rxPacket.canAddress & 0x007F)==0x7B)
149:                         //        {
150:                         //            printf("PlowMatch\r");
151:                         //            printf("%x, " rxPacket.canAddress);
152:                         //            int jk=0;
153:                         //            for(jk=0;jk<8;jk++)
154:                         //            {            
155:                         //                printf("%x,",rxPacket.messageContents[jk]);
156:                         //            }
157:                         //            printf("/r");
158:                         //        }
159:                 
160:                         //Look for requested data
161:                         uint16_t dataAddressPacket = (uint16_t) ((((uint16_t) rxPacket.messageContents[2]) << 8) + rxPacket.messageContents[1]);
9D003AC0  93A70017   LBU A3, 23(SP)
9D003B08  00073A00   SLL A3, A3, 8
9D003B0C  00C73021   ADDU A2, A2, A3
162:                         //        uint16_t dataAddressPacket = (uint16_t)((((uint16_t)rxPacket.messageContents[2])<<8) | rxPacket.messageContents[1]);  
163:                 
164:                         if ((rx_message_requested[lastMessageIndexSent].CANID == rxPacket.canAddress) && (rx_message_requested[lastMessageIndexSent].contentsID == dataAddressPacket)) {
9D003AC4  8F828054   LW V0, -32684(GP)
9D003AC8  00022080   SLL A0, V0, 2
9D003ACC  00022900   SLL A1, V0, 4
9D003AD0  00A42023   SUBU A0, A1, A0
9D003AD4  3C058000   LUI A1, -32768
9D003AD8  24A51DEC   ADDIU A1, A1, 7660
9D003ADC  00852021   ADDU A0, A0, A1
9D003AE0  94850008   LHU A1, 8(A0)
9D003AE4  97A40012   LHU A0, 18(SP)
9D003AE8  14A40045   BNE A1, A0, .LVL80, .LBE80, .LBB81, .LBB82, .LBB83
9D003AEC  93A60016   LBU A2, 22(SP)
9D003AF0  00022080   SLL A0, V0, 2
9D003AF4  00022900   SLL A1, V0, 4
9D003AF8  00A42023   SUBU A0, A1, A0
9D003AFC  3C058000   LUI A1, -32768
9D003B00  24A51DEC   ADDIU A1, A1, 7660
9D003B04  00852021   ADDU A0, A0, A1
9D003B10  9484000A   LHU A0, 10(A0)
9D003B14  30C6FFFF   ANDI A2, A2, -1
9D003B18  5486003A   BNEL A0, A2, 0x9D003C04
9D003B1C  24032000   ADDIU V1, ZERO, 8192
165:                             //Store a version of the address that we use (0x7_)
166:                             uint8_t comparableAddress = (uint8_t) (rxPacket.canAddress & 0x007F);
167:                 
168:                 
169:                             //Combine the data into a 32bit format
170:                             //            long dataCombination = (long)((((long)rxPacket.messageContents[7])<<24) +(((long)rxPacket.messageContents[6])<<16) + (((long)rxPacket.messageContents[5])<<8) + rxPacket.messageContents[4]);   
171:                 
172:                             long dataCombination = 0;
9D003B40  0B400EE7   J .LVL78
9D003B44  00003021   ADDU A2, ZERO, ZERO
9D003B58  0B400EE7   J .LVL78
9D003B5C  00003021   ADDU A2, ZERO, ZERO
173:                             switch (rxPacket.DLC_Code) {
9D003B20  24040043   ADDIU A0, ZERO, 67
9D003B24  1064000E   BEQ V1, A0, .LBB86, .LBB80
9D003B28  2C640044   SLTIU A0, V1, 68
9D003B2C  10800006   BEQ A0, ZERO, .LBB85, .LBB79
9D003B30  2404004B   ADDIU A0, ZERO, 75
9D003B34  24040041   ADDIU A0, ZERO, 65
9D003B38  5064000A   BEQL V1, A0, 0x9D003B64
9D003B3C  93A6001C   LBU A2, 28(SP)
9D003B48  10640010   BEQ V1, A0, .LVL76
9D003B4C  2404004F   ADDIU A0, ZERO, 79
9D003B50  50640012   BEQL V1, A0, .LVL78
9D003B54  93A60019   LBU A2, 25(SP)
174:                                 case 0x41:
175:                                 case 0x43:
176:                                     dataCombination = (long) ((((long) rxPacket.messageContents[7]) << 24) +(((long) rxPacket.messageContents[6]) << 16) + (((long) rxPacket.messageContents[5]) << 8) + rxPacket.messageContents[4]);
9D003B60  93A6001C   LBU A2, 28(SP)
9D003B64  00063600   SLL A2, A2, 24
9D003B68  93A3001B   LBU V1, 27(SP)
9D003B6C  00031C00   SLL V1, V1, 16
9D003B70  00C33021   ADDU A2, A2, V1
9D003B74  93A3001A   LBU V1, 26(SP)
9D003B78  00031A00   SLL V1, V1, 8
9D003B7C  00C33021   ADDU A2, A2, V1
9D003B80  93A30019   LBU V1, 25(SP)
177:                                     break;
9D003B84  0B400EE7   J .LVL78
9D003B88  00C33021   ADDU A2, A2, V1
178:                                 case 0x4B:
179:                                     dataCombination = (long) ((((int16_t) rxPacket.messageContents[5]) << 8) + rxPacket.messageContents[4]);
9D003B8C  93A6001A   LBU A2, 26(SP)
9D003B90  00063200   SLL A2, A2, 8
9D003B94  93A30019   LBU V1, 25(SP)
9D003B98  00C33021   ADDU A2, A2, V1
180:                                     break;
181:                                 case 0x4F:
182:                                     dataCombination = (long) rxPacket.messageContents[4];
183:                                     break;
184:                             }
185:                             //            printf("RXData: %d\r",dataCombination);
186:                             bool returnable = false;
187:                             if(rx_message_requested[lastMessageIndexSent].rx_requested != NO_DATA_REQUESTED && rx_message_requested[lastMessageIndexSent].callback != NULL)
9D003B9C  00022080   SLL A0, V0, 2
9D003BA0  00022900   SLL A1, V0, 4
9D003BA4  00A42023   SUBU A0, A1, A0
9D003BA8  3C038000   LUI V1, -32768
9D003BAC  24631DEC   ADDIU V1, V1, 7660
9D003BB0  7C64180A   LWX V1, A0(V1)
9D003BB4  10600013   BEQ V1, ZERO, 0x9D003C04
9D003BB8  24032000   ADDIU V1, ZERO, 8192
9D003BBC  3C038000   LUI V1, -32768
9D003BC0  24631DEC   ADDIU V1, V1, 7660
9D003BC4  00641021   ADDU V0, V1, A0
9D003BC8  8C420004   LW V0, 4(V0)
9D003BCC  1040000D   BEQ V0, ZERO, 0x9D003C04
9D003BD0  24032000   ADDIU V1, ZERO, 8192
188:                             {
189:                                 ((Data_t*)(rx_message_requested[lastMessageIndexSent].callback))->data = dataCombination;
9D003BD4  AC460000   SW A2, 0(V0)
190:                                 ((Data_t*)(rx_message_requested[lastMessageIndexSent].callback))->newDataFlag = true;
9D003BD8  8F828054   LW V0, -32684(GP)
9D003BDC  00021880   SLL V1, V0, 2
9D003BE0  00021100   SLL V0, V0, 4
9D003BE4  00431023   SUBU V0, V0, V1
9D003BE8  3C038000   LUI V1, -32768
9D003BEC  24631DEC   ADDIU V1, V1, 7660
9D003BF0  00621021   ADDU V0, V1, V0
9D003BF4  8C420004   LW V0, 4(V0)
9D003BF8  24030001   ADDIU V1, ZERO, 1
9D003BFC  A0430004   SB V1, 4(V0)
191:                             }
192:                             //If you wanted data back, store it according to the type requested
193:                 //            switch (rx_message_requested[lastMessageIndexSent].rx_requested) {
194:                 //                case NO_DATA_REQUESTED:
195:                 //
196:                 //                    break;
197:                 //                case ERROR_REQUESTED:
198:                 //                    switch (comparableAddress) {
199:                 //                        case RIGHTMOTORID:
200:                 //                            storeMotorError(&RightMotor, dataCombination);
201:                 //                            break;
202:                 //                        case LEFTMOTORID:
203:                 //                            storeMotorError(&LeftMotor, dataCombination);
204:                 //                            break;
205:                 //                        case DRUMMOTORID:
206:                 //                            storeMotorError(&DrumMotor, dataCombination);
207:                 //                            break;
208:                 //                        case ARMMOTORID:
209:                 //                            storeMotorError(&ArmMotor, dataCombination);
210:                 //                            break;
211:                 //                        case PLOWMOTORID:
212:                 //                            storeMotorError(&PlowMotor, dataCombination);
213:                 //                            break;
214:                 //                    }
215:                 //                    break;
216:                 //                case ENCODER_POSITION_REQUESTED:
217:                 //                case HALL_POSITION_REQUESTED:
218:                 //                case SSI_ENCODER_POSITION_REQUESTED:
219:                 //                    switch (comparableAddress) {
220:                 //                        case RIGHTMOTORID:
221:                 //                            storeMotorPosition(&RightMotor, dataCombination);
222:                 //                            break;
223:                 //                        case LEFTMOTORID:
224:                 //                            storeMotorPosition(&LeftMotor, dataCombination);
225:                 //                            break;
226:                 //                        case DRUMMOTORID:
227:                 //                            storeMotorPosition(&DrumMotor, dataCombination);
228:                 //                            break;
229:                 //                        case ARMMOTORID:
230:                 //                            storeMotorPosition(&ArmMotor, dataCombination);
231:                 //                            break;
232:                 //                        case PLOWMOTORID:
233:                 //                            storeMotorPosition(&PlowMotor, dataCombination);
234:                 //                            break;
235:                 //                    }
236:                 //                    //CANbufPut(&CAN_rx_buffer,rxPacket);
237:                 //                    break;
238:                 //
239:                 //                case ANALOG_0_REQUESTED:
240:                 //                    switch (comparableAddress) {
241:                 //                        case RIGHTMOTORID:
242:                 //                            storeMotorAnalog0(&RightMotor, (int16_t) dataCombination);
243:                 //                            break;
244:                 //                        case LEFTMOTORID:
245:                 //                            storeMotorAnalog0(&LeftMotor, (int16_t) dataCombination);
246:                 //                            break;
247:                 //                        case DRUMMOTORID:
248:                 //                            storeMotorAnalog0(&DrumMotor, (int16_t) dataCombination);
249:                 //                            break;
250:                 //                        case ARMMOTORID:
251:                 //                            storeMotorAnalog0(&ArmMotor, (int16_t) dataCombination);
252:                 //                            break;
253:                 //                        case PLOWMOTORID:
254:                 //                            storeMotorAnalog0(&PlowMotor, (int16_t) dataCombination);
255:                 //                            break;
256:                 //                    }
257:                 //                    break;
258:                 //                case ANALOG_1_REQUESTED:
259:                 //                    switch (comparableAddress) {
260:                 //                        case RIGHTMOTORID:
261:                 //                            storeMotorAnalog1(&RightMotor, (int16_t) dataCombination);
262:                 //                            break;
263:                 //                        case LEFTMOTORID:
264:                 //                            storeMotorAnalog1(&LeftMotor, (int16_t) dataCombination);
265:                 //                            break;
266:                 //                        case DRUMMOTORID:
267:                 //                            storeMotorAnalog1(&DrumMotor, (int16_t) dataCombination);
268:                 //                            break;
269:                 //                        case ARMMOTORID:
270:                 //                            storeMotorAnalog1(&ArmMotor, (int16_t) dataCombination);
271:                 //                            break;
272:                 //                        case PLOWMOTORID:
273:                 //                            storeMotorAnalog1(&PlowMotor, (int16_t) dataCombination);
274:                 //                            break;
275:                 //                    }
276:                 //                    break;
277:                 //                case DIGITAL_INPUT_REQUESTED:
278:                 //                    switch (comparableAddress) {
279:                 //                        case RIGHTMOTORID:
280:                 //                            storeMotorDigitalInputs(&RightMotor, (uint8_t) dataCombination);
281:                 //                            break;
282:                 //                        case LEFTMOTORID:
283:                 //                            storeMotorDigitalInputs(&LeftMotor, (uint8_t) dataCombination);
284:                 //                            break;
285:                 //                        case DRUMMOTORID:
286:                 //                            storeMotorDigitalInputs(&DrumMotor, (uint8_t) dataCombination);
287:                 //                            break;
288:                 //                        case ARMMOTORID:
289:                 //                            storeMotorDigitalInputs(&ArmMotor, (uint8_t) dataCombination);
290:                 //                            //                            printf("dataComb: %u\r",(uint8_t)dataCombination);      
291:                 //                            //                            printf("packet4: %u\r",(uint8_t)rxPacket.messageContents[4]);                          
292:                 //                            break;
293:                 //                        case PLOWMOTORID:
294:                 //                            storeMotorDigitalInputs(&PlowMotor, (uint8_t) dataCombination);
295:                 //                            break;
296:                 //                    }
297:                 //                    break;
298:                 //                case POSITION_REACHED_REQUESTED:
299:                 //                    if ((dataCombination & 0x10) > 0) {
300:                 //                        returnable = true;
301:                 //                    }
302:                 //                    switch (comparableAddress) {
303:                 //                        case RIGHTMOTORID:
304:                 //                            storeMotorPositionReached(&RightMotor, returnable);
305:                 //                            break;
306:                 //                        case LEFTMOTORID:
307:                 //                            storeMotorPositionReached(&LeftMotor, returnable);
308:                 //                            break;
309:                 //                        case DRUMMOTORID:
310:                 //                            storeMotorPositionReached(&DrumMotor, returnable);
311:                 //                            break;
312:                 //                        case ARMMOTORID:
313:                 //                            storeMotorPositionReached(&ArmMotor, returnable);
314:                 //                            break;
315:                 //                        case PLOWMOTORID:
316:                 //                            storeMotorPositionReached(&PlowMotor, returnable);
317:                 //                            break;
318:                 //                    }
319:                 //                    break;
320:                 //                case CURRENT_USAGE:
321:                 //                    switch (comparableAddress) {
322:                 //                        case RIGHTMOTORID:
323:                 //                            storeMotorCurrent(&RightMotor, (int16_t) dataCombination);
324:                 //                            break;
325:                 //                        case LEFTMOTORID:
326:                 //                            storeMotorCurrent(&LeftMotor, (int16_t) dataCombination);
327:                 //                            break;
328:                 //                        case DRUMMOTORID:
329:                 //                            storeMotorCurrent(&DrumMotor, (int16_t) dataCombination);
330:                 //                            break;
331:                 //                        case ARMMOTORID:
332:                 //                            storeMotorCurrent(&ArmMotor, (int16_t) dataCombination);
333:                 //                            break;
334:                 //                        case PLOWMOTORID:
335:                 //                            storeMotorCurrent(&PlowMotor, (int16_t) dataCombination);
336:                 //                            break;
337:                 //                    }
338:                 //                    break;
339:                 //            }
340:                         }
341:                 
342:                         /* Message processing is done, update the message buffer pointer. */
343:                         PLIB_CAN_ChannelUpdate(CAN_ID_1, CHANNEL_1_CAN);
344:                         CANRxAvailable = true;
9D003C0C  24020001   ADDIU V0, ZERO, 1
9D003C10  A3828052   SB V0, -32686(GP)
345:                 
346:                         //printf("1: ");
347:                         //If we are waiting to send TX messages 
348:                         if ((CAN_tx_buffer.count > 0) && (C1FIFOINT0bits.TXEMPTYIE == 0) && awaitingResponse) {
9D003C14  3C028000   LUI V0, -32768
9D003C18  94424830   LHU V0, 18480(V0)
9D003C1C  10400025   BEQ V0, ZERO, .LBB87
9D003C20  3C02BF88   LUI V0, -16504
9D003C24  8C420360   LW V0, 864(V0)
9D003C28  7C420600   EXT V0, V0, 24, 1
9D003C2C  14400021   BNE V0, ZERO, .LBB87
9D003C30  3C02BF88   LUI V0, -16504
9D003C34  93828051   LBU V0, -32687(GP)
9D003C38  304200FF   ANDI V0, V0, 255
9D003C3C  1040001D   BEQ V0, ZERO, .LBB87
9D003C40  3C02BF88   LUI V0, -16504
349:                             //printf("%d vs. %d\r",rx_message_requested[lastMessageIndexSent].CANID,rxPacket.canAddress);
350:                             //If the message was received as requested, move to sending the next
351:                             if (rx_message_requested[lastMessageIndexSent].CANID == rxPacket.canAddress) {
9D003C44  8F828054   LW V0, -32684(GP)
9D003C48  00021880   SLL V1, V0, 2
9D003C4C  00022100   SLL A0, V0, 4
9D003C50  00832023   SUBU A0, A0, V1
9D003C54  3C038000   LUI V1, -32768
9D003C58  24631DEC   ADDIU V1, V1, 7660
9D003C5C  00831821   ADDU V1, A0, V1
9D003C60  94640008   LHU A0, 8(V1)
9D003C64  97A30012   LHU V1, 18(SP)
9D003C68  54830031   BNEL A0, V1, 0x9D003D30
9D003C6C  3C02BF88   LUI V0, -16504
352:                                 //Wipe the buffer when finishing this section
353:                                 rx_message_requested[lastMessageIndexSent].rx_requested = NO_DATA_REQUESTED;
9D003C70  00021880   SLL V1, V0, 2
9D003C74  00021100   SLL V0, V0, 4
9D003C78  00431023   SUBU V0, V0, V1
9D003C7C  3C038000   LUI V1, -32768
9D003C80  24631DEC   ADDIU V1, V1, 7660
9D003C84  00431021   ADDU V0, V0, V1
9D003C88  AC400000   SW ZERO, 0(V0)
354:                                 rx_message_requested[lastMessageIndexSent].callback = NULL;
9D003C8C  AC400004   SW ZERO, 4(V0)
355:                                 rx_message_requested[lastMessageIndexSent].CANID = 0;
9D003C90  A4400008   SH ZERO, 8(V0)
356:                 
357:                                 C1FIFOINT0bits.TXEMPTYIE = 1;
9D003C94  3C02BF88   LUI V0, -16504
9D003C98  8C430360   LW V1, 864(V0)
9D003C9C  24040001   ADDIU A0, ZERO, 1
9D003CA0  7C83C604   INS V1, A0, 24, 1
9D003CA4  AC430360   SW V1, 864(V0)
358:                                 awaitingResponse = false;
9D003CA8  A3808051   SB ZERO, -32687(GP)
359:                             }
360:                         }
361:                         else if (C1FIFOINT0bits.TXEMPTYIE == 0 && awaitingResponse) {
9D003CB4  8C420360   LW V0, 864(V0)
9D003CB8  7C420600   EXT V0, V0, 24, 1
9D003CBC  14400011   BNE V0, ZERO, .LBB88
9D003CC0  8F828054   LW V0, -32684(GP)
9D003CC4  93828051   LBU V0, -32687(GP)
9D003CC8  304200FF   ANDI V0, V0, 255
9D003CCC  1040000D   BEQ V0, ZERO, .LBB88
9D003CD0  8F828054   LW V0, -32684(GP)
362:                             //printf("2: ");
363:                             if (rx_message_requested[lastMessageIndexSent].CANID == rxPacket.canAddress) {
9D003CD4  00021880   SLL V1, V0, 2
9D003CD8  00021100   SLL V0, V0, 4
9D003CDC  00431023   SUBU V0, V0, V1
9D003CE0  3C038000   LUI V1, -32768
9D003CE4  24631DEC   ADDIU V1, V1, 7660
9D003CE8  00431021   ADDU V0, V0, V1
9D003CEC  94430008   LHU V1, 8(V0)
9D003CF0  97A20012   LHU V0, 18(SP)
9D003CF4  5062000D   BEQL V1, V0, .LVL81, .LBE88
9D003CF8  A3808051   SB ZERO, -32687(GP)
364:                                 //printf("%d vs. %d\r",rx_message_requested[lastMessageIndexSent].CANID,rxPacket.canAddress);
365:                                 awaitingResponse = false;
366:                             }
367:                         } else {
368:                             //printf("3: ");
369:                             if (rx_message_requested[lastMessageIndexSent].CANID == rxPacket.canAddress) {
9D003D04  00021880   SLL V1, V0, 2
9D003D08  00021100   SLL V0, V0, 4
9D003D0C  00431023   SUBU V0, V0, V1
9D003D10  3C038000   LUI V1, -32768
9D003D14  24631DEC   ADDIU V1, V1, 7660
9D003D18  00431021   ADDU V0, V0, V1
9D003D1C  94430008   LHU V1, 8(V0)
9D003D20  97A20012   LHU V0, 18(SP)
9D003D24  50620001   BEQL V1, V0, .LVL81, .LBE88
9D003D28  A3808051   SB ZERO, -32687(GP)
370:                                 //printf("%d vs. %d\r",rx_message_requested[lastMessageIndexSent].CANID,rxPacket.canAddress);
371:                                 awaitingResponse = false;
372:                             }
373:                         }
374:                 
375:                     }
376:                     if (C1FIFOINT0bits.TXEMPTYIF) //TBIF
9D003CAC  0B400F4C   J 0x9D003D30
9D003CB0  3C02BF88   LUI V0, -16504
9D003CFC  0B400F4C   J 0x9D003D30
9D003D00  3C02BF88   LUI V0, -16504
9D003D2C  3C02BF88   LUI V0, -16504
9D003D30  8C420360   LW V0, 864(V0)
9D003D34  30420100   ANDI V0, V0, 256
9D003D38  1040002A   BEQ V0, ZERO, 0x9D003DE4
9D003D3C  3C028000   LUI V0, -32768
377:                     {
378:                         if (CAN_tx_buffer.count > 0 && !awaitingResponse) //More left to send
9D003D40  94424830   LHU V0, 18480(V0)
9D003D44  10400018   BEQ V0, ZERO, 0x9D003DA8
9D003D48  00000000   NOP
9D003D4C  93828051   LBU V0, -32687(GP)
9D003D50  304200FF   ANDI V0, V0, 255
9D003D54  14400014   BNE V0, ZERO, 0x9D003DA8
9D003D58  3C108000   LUI S0, -32768
379:                         {
9D003DA0  0B400F7A   J 0x9D003DE8
9D003DA4  8FBF002C   LW RA, 44(SP)
380:                             lastMessageIndexSent = buff_get_tail_index(&CAN_tx_buffer);
9D003D5C  0F403325   JAL buff_get_tail_index
9D003D60  26043D3C   ADDIU A0, S0, 15676
9D003D64  AF828054   SW V0, -32684(GP)
381:                             my_can_packet_t sendingNext = CANbufGet(&CAN_tx_buffer);
9D003D68  27A40010   ADDIU A0, SP, 16
9D003D6C  0F402BC5   JAL CANbufGet
9D003D70  26053D3C   ADDIU A1, S0, 15676
382:                             DRV_CAN0_ChannelMessageTransmit(sendingNext.canChannel, sendingNext.canAddress, sendingNext.DLC_Code, sendingNext.messageContents);
9D003D74  93A40010   LBU A0, 16(SP)
9D003D78  97A50012   LHU A1, 18(SP)
9D003D7C  93A60014   LBU A2, 20(SP)
9D003D80  0F4026D8   JAL DRV_CAN0_ChannelMessageTransmit
9D003D84  27A70015   ADDIU A3, SP, 21
383:                             C1FIFOINT0bits.TXEMPTYIE = 0;
9D003D88  3C02BF88   LUI V0, -16504
9D003D8C  8C430360   LW V1, 864(V0)
9D003D90  7C03C604   INS V1, ZERO, 24, 1
9D003D94  AC430360   SW V1, 864(V0)
384:                             awaitingResponse = true;
9D003D98  24020001   ADDIU V0, ZERO, 1
9D003D9C  A3828051   SB V0, -32687(GP)
385:                             //printf("send: %d\r",sendingNext.canAddress);
386:                         } else if (!awaitingResponse) {
9D003DA8  93828051   LBU V0, -32687(GP)
9D003DAC  304200FF   ANDI V0, V0, 255
9D003DB0  14400009   BNE V0, ZERO, 0x9D003DD8
9D003DB4  3C02BF88   LUI V0, -16504
387:                             transmitStallCAN = true;
9D003DB8  24020001   ADDIU V0, ZERO, 1
9D003DBC  A3828011   SB V0, -32751(GP)
388:                             C1FIFOINT0bits.TXEMPTYIE = 0;
9D003DC0  3C02BF88   LUI V0, -16504
9D003DC4  8C430360   LW V1, 864(V0)
9D003DC8  7C03C604   INS V1, ZERO, 24, 1
9D003DCC  AC430360   SW V1, 864(V0)
9D003DD0  0B400F7A   J 0x9D003DE8
9D003DD4  8FBF002C   LW RA, 44(SP)
389:                         } else {
390:                             C1FIFOINT0bits.TXEMPTYIE = 0;
9D003DD8  8C430360   LW V1, 864(V0)
9D003DDC  7C03C604   INS V1, ZERO, 24, 1
9D003DE0  AC430360   SW V1, 864(V0)
391:                         }
392:                     }
393:                 }
9D003DE4  8FBF002C   LW RA, 44(SP)
394:                 
395:                 void messageTransmit(my_can_packet_t packetToSend) {
00000000  00000000   NOP
396:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].rx_requested = NO_DATA_REQUESTED;
00000020  00000000   NOP
397:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].callback = NULL;
00000048  00000000   NOP
398:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].CANID = (packetToSend.canAddress & 0x000F) + 0x5F0;
00000064  00000000   NOP
399:                     CANbufPut(&CAN_tx_buffer, packetToSend);
0000008C  00000000   NOP
400:                     if (transmitStallCAN) {
000000A8  00000000   NOP
401:                         transmitStallCAN = false;
402:                         //DRV_CAN0_ChannelMessageTransmit(packetToSend.canChannel,packetToSend.canAddress,packetToSend.DLC_Code,packetToSend.messageContents); 
403:                     } else {
404:                         //awaitingResponse = true; 
405:                     }
406:                     C1FIFOINT0bits.TXEMPTYIE = 1;
000000B4  00000000   NOP
407:                 }
000000C8  00000000   NOP
408:                 
409:                 //responseType-
410:                 //A zero will not trigger a response
411:                 //This field will allow for messages to be auto sorted by response type
412:                 //Currently this field is under utilized
413:                 
414:                 void messageTransmitWithResponse(my_can_packet_t packetToSend, int responseType, Data_t *_callbackPtr) {
00000000  00000000   NOP
415:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].rx_requested = responseType;
00000020  00000000   NOP
416:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].callback = _callbackPtr;
0000004C  00000000   NOP
417:                     
418:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].CANID = (packetToSend.canAddress & 0x000F) + 0x5F0;
0000006C  00000000   NOP
419:                     rx_message_requested[buff_get_head_index(&CAN_tx_buffer)].contentsID = (((uint16_t) packetToSend.messageContents[2]) << 8) + packetToSend.messageContents[1];
00000094  00000000   NOP
420:                     CANbufPut(&CAN_tx_buffer, packetToSend);
000000C0  00000000   NOP
421:                 
422:                     if (transmitStallCAN) {
000000DC  00000000   NOP
423:                         transmitStallCAN = false;
424:                         //DRV_CAN0_ChannelMessageTransmit(packetToSend.canChannel,packetToSend.canAddress,packetToSend.DLC_Code,packetToSend.messageContents); 
425:                     } else {
426:                         //awaitingResponse = true; 
427:                     }
428:                     C1FIFOINT0bits.TXEMPTYIE = 1;
000000E8  00000000   NOP
429:                 }
000000FC  00000000   NOP
430:                 
431:                 void messageTransmitFT(my_can_packet_t packetToSend) {
00000000  00000000   NOP
432:                     CANbufPut(&tx_FT_buffer, packetToSend);
00000020  00000000   NOP
433:                 
434:                     if (transmitStallCAN_FT) {
0000003C  00000000   NOP
435:                         transmitStallCAN_FT = false;
436:                         //DRV_CAN0_ChannelMessageTransmit(packetToSend.canChannel,packetToSend.canAddress,packetToSend.DLC_Code,packetToSend.messageContents); 
437:                     } else {
438:                         //awaitingResponse = true; 
439:                     }
440:                     C1FIFOINT2bits.TXEMPTYIE = 1;
00000048  00000000   NOP
441:                 }
0000005C  00000000   NOP
442:                 
443:                 bool CANmessageAvailable(void) {
444:                     return CANRxAvailable;
00000000  00000000   NOP
445:                 }
00000004  00000000   NOP
446:                 
447:                 bool messageReceive(my_can_packet_t * packetToReceive) {
00000000  00000000   NOP
448:                     *packetToReceive = CANbufGet(&CAN_rx_buffer);
00000014  00000000   NOP
449:                     if (CAN_rx_buffer.count == 0) {
0000005C  00000000   NOP
450:                         CANRxAvailable = false;
451:                     }
452:                     if (packetToReceive->DLC_Code == 0)
0000006C  00000000   NOP
453:                         return false; //Should indicate that it wasn't populated 
454:                     else
455:                         return true;
456:                 }
00000070  00000000   NOP
457:                 
458:                 //typedef struct{
459:                 //    uint8_t canChannel;
460:                 //    uint16_t canAddress;
461:                 //    uint8_t DLC_Code;
462:                 //    uint8_t messageContents[8];
463:                 //}my_can_packet_t;
464:                 
465:                 void populateMotorPacketWrite(uint8_t * messageData, SDO_PACKET_t packetToSend) {
00000000  00000000   NOP
466:                     messageData[0] = 0x23;
0000000C  00000000   NOP
467:                     messageData[1] = packetToSend.objAddr;
00000014  00000000   NOP
468:                     messageData[2] = packetToSend.objAddr >> 8;
00000018  00000000   NOP
469:                     messageData[3] = packetToSend.subAddr;
00000020  00000000   NOP
470:                     messageData[4] = packetToSend.data;
00000028  00000000   NOP
471:                     messageData[5] = packetToSend.data >> 8;
0000002C  00000000   NOP
472:                     messageData[6] = packetToSend.data >> 16;
00000034  00000000   NOP
473:                     messageData[7] = packetToSend.data >> 24;
0000003C  00000000   NOP
474:                 }
475:                 
476:                 void populateMotorPacketRead(uint8_t * messageData, SDO_PACKET_t packetToSend) {
00000000  00000000   NOP
477:                     messageData[0] = 0x40;
0000000C  00000000   NOP
478:                     messageData[1] = packetToSend.objAddr;
00000014  00000000   NOP
479:                     messageData[2] = packetToSend.objAddr >> 8;
00000018  00000000   NOP
480:                     messageData[3] = packetToSend.subAddr;
00000020  00000000   NOP
481:                     messageData[4] = packetToSend.data;
00000028  00000000   NOP
482:                     messageData[5] = packetToSend.data >> 8;
0000002C  00000000   NOP
483:                     messageData[6] = packetToSend.data >> 16;
00000034  00000000   NOP
484:                     messageData[7] = packetToSend.data >> 24;
0000003C  00000000   NOP
485:                 }
486:                 
487:                 //we really dont want to wait for this data to be accepted, find a clever way of ensuring data success vs a while loop
488:                 
489:                 void sendMotorPacket(uint8_t motorAddress, uint16_t objectAddr, uint8_t subAddr, long data) {
00000000  00000000   NOP
490:                     my_can_packet_t sending;
491:                     sending.canChannel = 0;
00000008  00000000   NOP
492:                     sending.canAddress = 0x600 + motorAddress;
0000000C  00000000   NOP
493:                     sending.DLC_Code = DLC_VALUE;
00000014  00000000   NOP
494:                 
495:                     SDO_PACKET_t sendCommand = {objectAddr, subAddr, data};
0000001C  00000000   NOP
496:                     populateMotorPacketWrite(sending.messageContents, sendCommand);
00000024  00000000   NOP
497:                 
498:                     messageTransmit(sending);
00000034  00000000   NOP
499:                 }
00000048  00000000   NOP
500:                 
501:                 //This will trigger the message system to log the response into the rx buffer
502:                 //Should include some response sorting potentially
503:                 //Could have structures built with each motor to hold counts/position/etc.
504:                 
505:                 //void sendMotorPacketWithResponse(uint8_t motorAddress, uint16_t objectAddr, uint8_t subAddr, long data, int responseType) {
506:                 //    my_can_packet_t sending;
507:                 //    sending.canChannel = 0;
508:                 //    sending.canAddress = 0x600 + motorAddress;
509:                 //    sending.DLC_Code = DLC_VALUE;
510:                 //
511:                 //    SDO_PACKET_t sendCommand = {objectAddr, subAddr, data};
512:                 //    populateMotorPacketWrite(sending.messageContents, sendCommand);
513:                 //
514:                 //    messageTransmitWithResponse(sending, responseType);
515:                 //}
516:                 
517:                 void requestMotorPacketWithResponse(uint8_t motorAddress, uint16_t objectAddr, uint8_t subAddr, long data, int responseType, Data_t *_callback) {
00000000  00000000   NOP
518:                     my_can_packet_t sending;
519:                     sending.canChannel = 0;
00000008  00000000   NOP
520:                     sending.canAddress = 0x600 + motorAddress;
0000000C  00000000   NOP
521:                     sending.DLC_Code = DLC_VALUE;
00000014  00000000   NOP
522:                 
523:                     SDO_PACKET_t sendCommand = {objectAddr, subAddr, data};
0000001C  00000000   NOP
524:                     populateMotorPacketRead(sending.messageContents, sendCommand);
00000024  00000000   NOP
525:                 
526:                     messageTransmitWithResponse(sending, responseType, _callback);
00000034  00000000   NOP
527:                 }
00000058  00000000   NOP
528:                 
529:                 //we really dont MIND waiting for this data to be accepted, during init we can wait all day
530:                 
531:                 void sendMotorPacketInit(uint8_t motorAddress, uint16_t objectAddr, uint8_t subAddr, long data) {
00000000  00000000   NOP
532:                     my_can_packet_t sending;
533:                     sending.canChannel = 0;
00000008  00000000   NOP
534:                     sending.canAddress = 0x600 + motorAddress;
0000000C  00000000   NOP
535:                     sending.DLC_Code = DLC_VALUE;
00000014  00000000   NOP
536:                 
537:                     SDO_PACKET_t sendCommand = {objectAddr, subAddr, data};
0000001C  00000000   NOP
538:                     populateMotorPacketWrite(sending.messageContents, sendCommand);
00000024  00000000   NOP
539:                 
540:                     messageTransmit(sending);
00000034  00000000   NOP
541:                 
542:                     unsigned long i, j;
543:                     for (i = 0; i < 500000; i++) {
00000054  00000000   NOP
544:                         j++;
545:                     }
546:                 
547:                     //Pull the message out of the buffer for space saving and tidiness (hand it the variable we made earlier(dummy var))
548:                     messageReceive(&sending);
0000005C  00000000   NOP
549:                 }
00000064  00000000   NOP
550:                 
551:                 void copyMessageArrays(uint8_t * intoThis, uint8_t * fromThis) {
552:                     int i = 0;
553:                     for (i = 0; i < 8; i++) {
9D00C988  00001021   ADDU V0, ZERO, ZERO
9D00C98C  24070008   ADDIU A3, ZERO, 8
9D00C998  24420001   ADDIU V0, V0, 1
9D00C99C  1447FFFC   BNE V0, A3, .LVL52
9D00C9A0  A0660000   SB A2, 0(V1)
554:                         intoThis[i] = fromThis[i];
9D00C990  7CA2318A   LBUX A2, V0(A1)
9D00C994  00821821   ADDU V1, A0, V0
555:                     }
556:                 }
9D00C9A4  03E00008   JR RA
557:                 
558:                 /* *****************************************************************************
559:                  End of File
560:                  */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/bufferhandler.c  --
1:                   #include "bufferHandler.h"
2:                   
3:                   
4:                   unsigned int buff_modulo_inc(const unsigned int value, const unsigned int modulus);
5:                   
6:                   #ifdef StaticBuffers
7:                   bool initRingBuffer(RingBuffer_t *newBuff, uint8_t *ptr, int size)
8:                   {
9:                       
10:                      if(ptr == 0)
11:                          return false;
12:                      newBuff->buf = ptr;      //setting the pointer to the passed in array to be the buffer array 
13:                      
14:                      
15:                      newBuff->size = size;
16:                      if(newBuff->size == 0)
17:                          return 0;
18:                     
19:                      Buffer_Wipe(newBuff);
20:                      return true;
21:                  }
22:                  #else
23:                  RingBuffer_t* createRingBuffer(RingBuffer_t* rBuff, unsigned int s)
24:                  {
9D000110  27BDFFE0   ADDIU SP, SP, -32
9D000114  AFBF001C   SW RA, 28(SP)
9D000118  AFB10018   SW S1, 24(SP)
9D00011C  AFB00014   SW S0, 20(SP)
9D000120  00A08821   ADDU S1, A1, ZERO
25:                      //RingBuffer_t* rBuff = malloc(sizeof(RingBuffer_t) +s*sizeof(uint8_t*));
26:                      rBuff = malloc(sizeof(RingBuffer_t));
9D000124  0F4012F7   JAL malloc
9D000128  24040014   ADDIU A0, ZERO, 20
9D00012C  00408021   ADDU S0, V0, ZERO
27:                      rBuff->buf = malloc(sizeof(uint8_t) * s);
9D000130  0F4012F7   JAL malloc
9D000134  02202021   ADDU A0, S1, ZERO
28:                      
29:                      if(!rBuff){   
9D000138  16000008   BNE S0, ZERO, 0x9D00015C
9D00013C  AE020000   SW V0, 0(S0)
30:                          printf("Failure to malloc Buffer of size %u + %u", (unsigned int)(sizeof(RingBuffer_t*)), (unsigned int)(s*sizeof(uint8_t*)));
9D000140  3C049D01   LUI A0, -25343
9D000144  2484C7F0   ADDIU A0, A0, -14352
9D000148  24050004   ADDIU A1, ZERO, 4
9D00014C  0F403114   JAL _printf_cdnopuxX
9D000150  00113080   SLL A2, S1, 2
31:                          return NULL;
9D000154  0B40005B   J 0x9D00016C
9D000158  00001021   ADDU V0, ZERO, ZERO
32:                      }
33:                      rBuff->size = s;
9D00015C  AE110004   SW S1, 4(S0)
34:                      Buffer_Wipe(rBuff);
9D000160  0F4030F4   JAL Buffer_Wipe
9D000164  02002021   ADDU A0, S0, ZERO
35:                      
36:                      return rBuff;
9D000168  02001021   ADDU V0, S0, ZERO
37:                  }
9D00016C  8FBF001C   LW RA, 28(SP)
38:                  
39:                  #endif
40:                  void Buffer_Wipe(RingBuffer_t *ringBuffer)
41:                  {
42:                      ringBuffer->head = 0;
9D00C3D0  AC800008   SW ZERO, 8(A0)
43:                      ringBuffer->tail = 0;
9D00C3D4  AC80000C   SW ZERO, 12(A0)
44:                      ringBuffer->count = 0;
9D00C3D8  AC800010   SW ZERO, 16(A0)
45:                      int i;
46:                      for(i=0;i<ringBuffer->size;i++)
9D00C3DC  8C820004   LW V0, 4(A0)
9D00C3E0  18400009   BLEZ V0, .LVL4
9D00C3E4  00001021   ADDU V0, ZERO, ZERO
9D00C3F4  24420001   ADDIU V0, V0, 1
47:                      {
48:                          ringBuffer->buf[i]=0;
9D00C3E8  8C830000   LW V1, 0(A0)
9D00C3EC  00621821   ADDU V1, V1, V0
9D00C3F0  A0600000   SB ZERO, 0(V1)
49:                      }
50:                  }
51:                  void Buffer_Put(RingBuffer_t *_this, const uint8_t c)
52:                  {
53:                      const int BUFFER_SIZE = _this->size;
9D00B7E4  8C820004   LW V0, 4(A0)
54:                      if (_this->count < BUFFER_SIZE)
9D00B7E8  8C830010   LW V1, 16(A0)
9D00B7EC  0062182A   SLT V1, V1, V0
9D00B7F0  1060000D   BEQ V1, ZERO, .LVL21
9D00B7F4  8C860000   LW A2, 0(A0)
55:                      {
56:                          _this->buf[_this->head] = c;
9D00B7F8  8C830008   LW V1, 8(A0)
9D00B7FC  00C31821   ADDU V1, A2, V1
9D00B800  A0650000   SB A1, 0(V1)
57:                          _this->head = buff_modulo_inc(_this->head, BUFFER_SIZE);
9D00B814  AC830008   SW V1, 8(A0)
58:                          _this->count++;
9D00B818  8C820010   LW V0, 16(A0)
9D00B81C  24420001   ADDIU V0, V0, 1
9D00B820  03E00008   JR RA
9D00B824  AC820010   SW V0, 16(A0)
59:                          
60:                      } else
61:                      {
62:                          _this->buf[_this->head] = c;
9D00B828  8C830008   LW V1, 8(A0)
9D00B82C  00C31821   ADDU V1, A2, V1
9D00B830  A0650000   SB A1, 0(V1)
63:                          _this->head = buff_modulo_inc(_this->head, BUFFER_SIZE);
9D00B844  AC830008   SW V1, 8(A0)
64:                          _this->tail = buff_modulo_inc(_this->tail, BUFFER_SIZE);
9D00B858  03E00008   JR RA
65:                  
66:                      }
67:                  }
68:                  uint8_t Buffer_Get(RingBuffer_t* _this)
69:                  {
70:                      const int BUFFER_SIZE = _this->size;
71:                      uint8_t c;
72:                      if (_this->count > 0)
9D00C4CC  8C850010   LW A1, 16(A0)
9D00C4D0  18A0000B   BLEZ A1, .LVL37
9D00C4D4  8C860004   LW A2, 4(A0)
73:                      {
74:                          c = _this->buf[_this->tail];
9D00C4D8  8C83000C   LW V1, 12(A0)
9D00C4DC  8C820000   LW V0, 0(A0)
9D00C4E0  7C43118A   LBUX V0, V1(V0)
75:                          _this->tail = buff_modulo_inc(_this->tail, BUFFER_SIZE);
9D00C4F0  AC83000C   SW V1, 12(A0)
76:                          --_this->count;
9D00C4F4  24A5FFFF   ADDIU A1, A1, -1
9D00C4F8  03E00008   JR RA
9D00C4FC  AC850010   SW A1, 16(A0)
77:                      }else{
78:                          c = 0;
79:                      }
80:                      return (c);
81:                  }
9D00C500  03E00008   JR RA
82:                  int Buffer_Size(RingBuffer_t* _this)
83:                  {
84:                      return _this->count;
85:                  }
9D00CC8C  03E00008   JR RA
86:                  
87:                  unsigned int buff_modulo_inc(const unsigned int value, const unsigned int modulus)
88:                  {
89:                      unsigned int my_value = value + 1;
9D00AF78  24820001   ADDIU V0, A0, 1
9D00B804  8C830008   LW V1, 8(A0)
9D00B834  8C830008   LW V1, 8(A0)
9D00B848  8C83000C   LW V1, 12(A0)
9D00C4E4  24630001   ADDIU V1, V1, 1
00000000  00000000   NOP
0000005C  00000000   NOP
000000B4  00000000   NOP
000000C8  00000000   NOP
90:                      if (my_value >= modulus)
9D00AF7C  2C4400C8   SLTIU A0, V0, 200
9D00B80C  0062102B   SLTU V0, V1, V0
9D00B83C  0062282B   SLTU A1, V1, V0
9D00B850  0062102B   SLTU V0, V1, V0
9D00C4E8  0066302B   SLTU A2, V1, A2
00000004  00000000   NOP
00000060  00000000   NOP
000000B8  00000000   NOP
000000CC  00000000   NOP
91:                      {
92:                          my_value = 0;
9D00AF80  0004100A   MOVZ V0, ZERO, A0
9D00B810  0002180A   MOVZ V1, ZERO, V0
9D00B840  0005180A   MOVZ V1, ZERO, A1
9D00B854  0002180A   MOVZ V1, ZERO, V0
9D00C4EC  0006180A   MOVZ V1, ZERO, A2
00000064  00000000   NOP
000000BC  00000000   NOP
000000D0  00000000   NOP
93:                      }
94:                      return (my_value);
95:                  }
00000008  00000000   NOP
96:                  uint8_t Buffer_Peek(RingBuffer_t* _this)
97:                  {
98:                      return _this->buf[_this->tail];
9D00CC40  8C830000   LW V1, 0(A0)
9D00CC44  8C82000C   LW V0, 12(A0)
99:                  }
9D00CC48  03E00008   JR RA
100:                 
101:                 
102:                 //**************************************************************
103:                 //                   CAN BUFFER FUNCTIONS
104:                 //**************************************************************
105:                 
106:                 
107:                 
108:                 my_can_packet_t generateEmptyPacket(void);
109:                 /*=========================Generic UART Functions=============================*/
110:                 void CANwipeBuffer(my_can_buffer_t * canBuf)
111:                 {
9D00B8D4  27BDFFD8   ADDIU SP, SP, -40
9D00B8D8  AFBF0024   SW RA, 36(SP)
9D00B8DC  AFB00020   SW S0, 32(SP)
9D00B8E0  00808021   ADDU S0, A0, ZERO
112:                     my_can_packet_t wipePacket = generateEmptyPacket();
9D00B8E4  0F4031B3   JAL generateEmptyPacket
9D00B8E8  27A40010   ADDIU A0, SP, 16
9D00B8EC  00001821   ADDU V1, ZERO, ZERO
113:                     int i=0;
114:                     for(i=0;i<CAN_BUFFER_PACKET_LENGTH;i++)
9D00B8F0  24040AF0   ADDIU A0, ZERO, 2800
9D00B8F4  02031021   ADDU V0, S0, V1
9D00B924  1464FFF3   BNE V1, A0, .LVL67
9D00B928  A445000C   SH A1, 12(V0)
115:                     {
116:                         canBuf->buf[i]=wipePacket;
9D00B8F8  8FA70010   LW A3, 16(SP)
9D00B8FC  8FA60014   LW A2, 20(SP)
9D00B900  8FA50018   LW A1, 24(SP)
9D00B904  A8470003   SWL A3, 3(V0)
9D00B908  B8470000   SWR A3, 0(V0)
9D00B90C  A8460007   SWL A2, 7(V0)
9D00B910  B8460004   SWR A2, 4(V0)
9D00B914  A845000B   SWL A1, 11(V0)
9D00B918  B8450008   SWR A1, 8(V0)
9D00B91C  97A5001C   LHU A1, 28(SP)
9D00B920  2463000E   ADDIU V1, V1, 14
117:                     }
118:                     canBuf->head=0;
9D00B92C  A6000AF0   SH ZERO, 2800(S0)
119:                     canBuf->tail=0;
9D00B930  A6000AF2   SH ZERO, 2802(S0)
120:                     canBuf->count=0;
9D00B934  A6000AF4   SH ZERO, 2804(S0)
121:                 }
9D00B938  8FBF0024   LW RA, 36(SP)
122:                 
123:                 void CANbufPut(my_can_buffer_t * canBuf, my_can_packet_t p)
124:                 {
00000000  00000000   NOP
125:                      if (canBuf->count < CAN_BUFFER_PACKET_LENGTH)
0000000C  00000000   NOP
126:                     {
127:                         canBuf->buf[canBuf->head] = p;
0000001C  00000000   NOP
128:                         canBuf->head = buff_modulo_inc(canBuf->head, CAN_BUFFER_PACKET_LENGTH);
00000068  00000000   NOP
129:                         ++canBuf->count;
0000006C  00000000   NOP
130:                     } 
131:                      else
132:                     {
133:                         canBuf->buf[canBuf->head] = p;
00000078  00000000   NOP
134:                         canBuf->head = buff_modulo_inc(canBuf->head, CAN_BUFFER_PACKET_LENGTH);
000000C0  00000000   NOP
135:                         canBuf->tail = buff_modulo_inc(canBuf->tail, CAN_BUFFER_PACKET_LENGTH);
000000C4  00000000   NOP
000000D4  00000000   NOP
136:                 
137:                     }
138:                 }
139:                 unsigned int buff_get_tail_index(my_can_buffer_t * canBuf)
140:                 {
141:                     return canBuf->tail;
142:                 }
9D00CC94  03E00008   JR RA
143:                 unsigned int buff_get_head_index(my_can_buffer_t * canBuf)
144:                 {
145:                     return canBuf->head;
146:                 }
147:                 
148:                 unsigned int buff_get_last_index(my_can_buffer_t * canBuf)
149:                 {
150:                     if(canBuf->tail == 0)
00000000  00000000   NOP
151:                     {
152:                         return CAN_BUFFER_PACKET_LENGTH-2;
153:                     }
154:                     else
155:                     {
156:                         return canBuf->tail-1;
00000004  00000000   NOP
157:                     }
158:                 }
00000008  00000000   NOP
159:                 
160:                 my_can_packet_t CANbufGet(my_can_buffer_t * canBuf)
161:                 {
9D00AF14  27BDFFE8   ADDIU SP, SP, -24
9D00AF18  AFBF0014   SW RA, 20(SP)
9D00AF1C  AFB00010   SW S0, 16(SP)
162:                     my_can_packet_t p;
163:                     if (canBuf->count > 0)
9D00AF20  94A30AF4   LHU V1, 2804(A1)
9D00AF24  1060001B   BEQ V1, ZERO, .LVL76
9D00AF28  00808021   ADDU S0, A0, ZERO
164:                     {
165:                         p = canBuf->buf[canBuf->tail];
9D00AF2C  94A40AF2   LHU A0, 2802(A1)
9D00AF30  00041040   SLL V0, A0, 1
9D00AF34  00043100   SLL A2, A0, 4
9D00AF38  00C21023   SUBU V0, A2, V0
9D00AF3C  00A21021   ADDU V0, A1, V0
9D00AF40  944B0000   LHU T3, 0(V0)
9D00AF44  944A0002   LHU T2, 2(V0)
9D00AF48  94490004   LHU T1, 4(V0)
9D00AF4C  94480006   LHU T0, 6(V0)
9D00AF50  94470008   LHU A3, 8(V0)
9D00AF54  9446000A   LHU A2, 10(V0)
9D00AF58  9442000C   LHU V0, 12(V0)
9D00AF5C  A60B0000   SH T3, 0(S0)
9D00AF60  A60A0002   SH T2, 2(S0)
9D00AF64  A6090004   SH T1, 4(S0)
9D00AF68  A6080006   SH T0, 6(S0)
9D00AF6C  A6070008   SH A3, 8(S0)
9D00AF70  A606000A   SH A2, 10(S0)
9D00AF74  A602000C   SH V0, 12(S0)
166:                         canBuf->tail = buff_modulo_inc(canBuf->tail, CAN_BUFFER_PACKET_LENGTH);
9D00AF84  A4A20AF2   SH V0, 2802(A1)
167:                         --canBuf->count;
9D00AF88  2463FFFF   ADDIU V1, V1, -1
9D00AF8C  0B402BE7   J .LVL77
9D00AF90  A4A30AF4   SH V1, 2804(A1)
168:                     } 
169:                     else
170:                     {
171:                       
172:                         p =  generateEmptyPacket();
9D00AF94  0F4031B3   JAL generateEmptyPacket
9D00AF98  00000000   NOP
173:                     }
174:                     return (p);
175:                 }
9D00AF9C  02001021   ADDU V0, S0, ZERO
176:                 
177:                 my_can_packet_t generateEmptyPacket(void)
178:                 {
9D00C6CC  00801021   ADDU V0, A0, ZERO
179:                      my_can_packet_t wipePacket;
180:                     wipePacket.canChannel=0;
181:                     wipePacket.canAddress=0;
182:                     wipePacket.DLC_Code=0;
183:                     wipePacket.messageContents[0] = 0;
184:                     wipePacket.messageContents[1] = 0;
185:                     wipePacket.messageContents[2] = 0;
186:                     wipePacket.messageContents[3] = 0;
187:                     wipePacket.messageContents[4] = 0;
188:                     wipePacket.messageContents[5] = 0;
189:                     wipePacket.messageContents[6] = 0;
190:                     wipePacket.messageContents[7] = 0;
191:                     return wipePacket;
9D00C6D0  A0800000   SB ZERO, 0(A0)
9D00C6D4  A4800002   SH ZERO, 2(A0)
9D00C6D8  A0800004   SB ZERO, 4(A0)
9D00C6DC  A0800005   SB ZERO, 5(A0)
9D00C6E0  A0800006   SB ZERO, 6(A0)
9D00C6E4  A0800007   SB ZERO, 7(A0)
9D00C6E8  A0800008   SB ZERO, 8(A0)
9D00C6EC  A0800009   SB ZERO, 9(A0)
9D00C6F0  A080000A   SB ZERO, 10(A0)
9D00C6F4  A080000B   SB ZERO, 11(A0)
192:                 }
9D00C6F8  03E00008   JR RA
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/app.c  ------------
1:                   // *****************************************************************************
2:                   // *****************************************************************************
3:                   // Section: Included Files 
4:                   // *****************************************************************************
5:                   // *****************************************************************************
6:                   
7:                   #include "app.h"
8:                   #include "Macros.h"
9:                   #include "Comunications.h"
10:                  #include "FastTransfer.h"
11:                  #include "CAN_Handler/CANFastTransfer.h"
12:                  #include "Definitions.h"
13:                  #include "changeNotification.h"
14:                  #include "Timers.h"
15:                  #include "uart_Handler.h"
16:                  #include "CAN_Handler/CAN.h"
17:                  #include "Pozyx.h"
18:                  #include "Telemetry.h"
19:                  #include "PathFollowing.h"
20:                  #include "Macro_Handler/Macro_Mgr.h"
21:                  #include "DataPublishing.h"
22:                  // *****************************************************************************
23:                  // *****************************************************************************
24:                  // Section: Global Data Definitions
25:                  // *****************************************************************************
26:                  // *****************************************************************************
27:                  
28:                  // *****************************************************************************
29:                  
30:                  APP_DATA appData;
31:                  
32:                  
33:                  bool isLoaded = false;
34:                  
35:                  timers_t sec, ms100;
36:                  timers_t bootTimer, ledTime, watchDog, receiveTimer, BlinkTime;
37:                  
38:                  void APP_Initialize(void) {
9D0082D0  27BDFFC8   ADDIU SP, SP, -56
9D0082D4  AFBF0034   SW RA, 52(SP)
9D0082D8  AFB40030   SW S4, 48(SP)
9D0082DC  AFB3002C   SW S3, 44(SP)
9D0082E0  AFB20028   SW S2, 40(SP)
9D0082E4  AFB10024   SW S1, 36(SP)
9D0082E8  AFB00020   SW S0, 32(SP)
39:                  
40:                      /* Place the App state machine in its initial state. */
41:                      appData.state = APP_STATE_INIT;
42:                      initChangeNotification();
9D0082EC  0F402CAB   JAL initChangeNotification
9D0082F0  AF8081A8   SW ZERO, -32344(GP)
43:                  
44:                      LED1 = off;
9D0082F4  3C02BF86   LUI V0, -16506
9D0082F8  90430430   LBU V1, 1072(V0)
9D0082FC  24100001   ADDIU S0, ZERO, 1
9D008300  7E0339C4   INS V1, S0, 7, 1
9D008304  A0430430   SB V1, 1072(V0)
45:                      LED2 = off;
9D008308  90430430   LBU V1, 1072(V0)
9D00830C  7E033184   INS V1, S0, 6, 1
9D008310  A0430430   SB V1, 1072(V0)
46:                      LED3 = off;
9D008314  90430430   LBU V1, 1072(V0)
9D008318  7E032944   INS V1, S0, 5, 1
9D00831C  A0430430   SB V1, 1072(V0)
47:                      LED4 = off;
9D008320  90430430   LBU V1, 1072(V0)
9D008324  7E032104   INS V1, S0, 4, 1
9D008328  A0430430   SB V1, 1072(V0)
48:                  
49:                      /* Initializing Timers */
50:                      setTimerInterval(&bootTimer, 3000);
9D00832C  27848198   ADDIU A0, GP, -32360
9D008330  0F403306   JAL setTimerInterval
9D008334  24050BB8   ADDIU A1, ZERO, 3000
51:                      setTimerInterval(&watchDog, 100);
9D008338  278481C8   ADDIU A0, GP, -32312
9D00833C  0F403306   JAL setTimerInterval
9D008340  24050064   ADDIU A1, ZERO, 100
52:                      setTimerInterval(&BlinkTime, 700);
9D008344  278481A0   ADDIU A0, GP, -32352
9D008348  0F403306   JAL setTimerInterval
9D00834C  240502BC   ADDIU A1, ZERO, 700
53:                      setTimerInterval(&receiveTimer, 20);
9D008350  278481B8   ADDIU A0, GP, -32328
9D008354  0F403306   JAL setTimerInterval
9D008358  24050014   ADDIU A1, ZERO, 20
54:                      setTimerInterval(&sec, 1000);
9D00835C  278481C0   ADDIU A0, GP, -32320
9D008360  0F403306   JAL setTimerInterval
9D008364  240503E8   ADDIU A1, ZERO, 1000
55:                      setTimerInterval(&ms100, 100);
9D008368  278481D0   ADDIU A0, GP, -32304
9D00836C  0F403306   JAL setTimerInterval
9D008370  24050064   ADDIU A1, ZERO, 100
56:                      setTimerInterval(&ledTime, 50);
9D008374  278481B0   ADDIU A0, GP, -32336
9D008378  0F403306   JAL setTimerInterval
9D00837C  24050032   ADDIU A1, ZERO, 50
57:                  
58:                  
59:                      /* Turning on the Timer the Runs the System's timers_t */
60:                      DRV_TMR0_Start();
9D008380  0F40318A   JAL DRV_TMR0_Start
9D008384  3C149D01   LUI S4, -25343
61:                  
62:                      initCANISRs();
9D008388  0F402A7F   JAL initCANISRs
9D00838C  2694C4CC   ADDIU S4, S4, -15156
63:                      initCANFT();
9D008390  0F402F32   JAL initCANFT
9D008394  3C139D01   LUI S3, -25343
64:                  
65:                      InitFastTransferModule(&MotorFT, Motor_UART, MY_ADDRESS, Send_put, Buffer_Get, Buffer_Size, Buffer_Peek);
9D008398  AFB40010   SW S4, 16(SP)
9D00839C  2673CC8C   ADDIU S3, S3, -13172
9D0083A0  AFB30014   SW S3, 20(SP)
9D0083A4  3C129D01   LUI S2, -25343
9D0083A8  2652CC40   ADDIU S2, S2, -13248
9D0083AC  AFB20018   SW S2, 24(SP)
9D0083B0  3C048000   LUI A0, -32768
9D0083B4  24844834   ADDIU A0, A0, 18484
9D0083B8  00002821   ADDU A1, ZERO, ZERO
9D0083BC  24060005   ADDIU A2, ZERO, 5
9D0083C0  3C119D01   LUI S1, -25343
9D0083C4  0F402DD9   JAL InitFastTransferModule
9D0083C8  2627BC6C   ADDIU A3, S1, -17300
66:                      InitFastTransferModule(&GyroFT, Gyro_UART, MY_ADDRESS, Send_put, Buffer_Get, Buffer_Size, Buffer_Peek);
9D0083CC  AFB40010   SW S4, 16(SP)
9D0083D0  AFB30014   SW S3, 20(SP)
9D0083D4  AFB20018   SW S2, 24(SP)
9D0083D8  3C048000   LUI A0, -32768
9D0083DC  24844984   ADDIU A0, A0, 18820
9D0083E0  24050001   ADDIU A1, ZERO, 1
9D0083E4  24060005   ADDIU A2, ZERO, 5
9D0083E8  0F402DD9   JAL InitFastTransferModule
9D0083EC  2627BC6C   ADDIU A3, S1, -17300
67:                  
68:                      InitPozyx();
9D0083F0  0F402FB6   JAL InitPozyx
9D0083F4  00000000   NOP
69:                  
70:                  
71:                      DRV_CAN0_Open();
9D0083F8  0F4032C7   JAL DRV_CAN0_Open
9D0083FC  00000000   NOP
72:                      
73:                      InitializePathPlanning();
9D008400  0F4032C0   JAL InitializePathPlanning
9D008404  00000000   NOP
74:                  
75:                      isLoaded = true;
76:                  
77:                      /* Publish data on the global bus in a certain period */
78:                      InitDataPublishing();
9D008408  0F403298   JAL InitDataPublishing
9D00840C  A390809C   SB S0, -32612(GP)
79:                      //initGlobalData(DEVICE_STATUS, getLoadedState, 500);
80:                      initGlobalData(DEVICE_MACRO, getRunningMacros, 500);
9D008410  24040001   ADDIU A0, ZERO, 1
9D008414  3C059D01   LUI A1, -25343
9D008418  24A5C5F0   ADDIU A1, A1, -14864
9D00841C  0F402FA0   JAL initGlobalData
9D008420  240601F4   ADDIU A2, ZERO, 500
81:                  
82:                      /* Play pattern on the LEDs */
83:                      while (!timerDone(&bootTimer)) {
9D008424  0B40212B   J .LVL21
9D008428  3C10BF86   LUI S0, -16506
9D0084AC  0F403198   JAL timerDone
9D0084B0  27848198   ADDIU A0, GP, -32360
9D0084B4  1040FFDD   BEQ V0, ZERO, 0x9D00842C
9D0084B8  24040004   ADDIU A0, ZERO, 4
84:                          LED1 ^= 1;
9D00842C  8E030430   LW V1, 1072(S0)
9D008430  7C6301C0   EXT V1, V1, 7, 1
9D008434  38630001   XORI V1, V1, 1
9D008438  92020430   LBU V0, 1072(S0)
9D00843C  7C6239C4   INS V0, V1, 7, 1
9D008440  A2020430   SB V0, 1072(S0)
85:                          delay(50);
9D008444  0F403207   JAL delay
9D008448  24040032   ADDIU A0, ZERO, 50
86:                          LED2 ^= 1;
9D00844C  8E030430   LW V1, 1072(S0)
9D008450  7C630180   EXT V1, V1, 6, 1
9D008454  38630001   XORI V1, V1, 1
9D008458  92020430   LBU V0, 1072(S0)
9D00845C  7C623184   INS V0, V1, 6, 1
9D008460  A2020430   SB V0, 1072(S0)
87:                          delay(50);
9D008464  0F403207   JAL delay
9D008468  24040032   ADDIU A0, ZERO, 50
88:                          LED3 ^= 1;
9D00846C  8E030430   LW V1, 1072(S0)
9D008470  7C630140   EXT V1, V1, 5, 1
9D008474  38630001   XORI V1, V1, 1
9D008478  92020430   LBU V0, 1072(S0)
9D00847C  7C622944   INS V0, V1, 5, 1
9D008480  A2020430   SB V0, 1072(S0)
89:                          delay(50);
9D008484  0F403207   JAL delay
9D008488  24040032   ADDIU A0, ZERO, 50
90:                          LED4 ^= 1;
9D00848C  8E030430   LW V1, 1072(S0)
9D008490  7C630100   EXT V1, V1, 4, 1
9D008494  38630001   XORI V1, V1, 1
9D008498  92020430   LBU V0, 1072(S0)
9D00849C  7C622104   INS V0, V1, 4, 1
9D0084A0  A2020430   SB V0, 1072(S0)
91:                          delay(50);
9D0084A4  0F403207   JAL delay
9D0084A8  24040032   ADDIU A0, ZERO, 50
92:                      }
93:                      handleCANmacro(1<<2, 0);
9D0084BC  0F403069   JAL handleCANmacro
9D0084C0  00002821   ADDU A1, ZERO, ZERO
94:                  
95:                      appData.state = APP_STATE_INIT;
9D0084C4  AF8081A8   SW ZERO, -32344(GP)
96:                  }
9D0084C8  8FBF0034   LW RA, 52(SP)
97:                  
98:                  
99:                  
100:                 intPin_t* awaitPin;
101:                 int NEXT_APP_STATE = 0;
102:                 
103:                 void APP_Tasks(void) {
9D00A06C  27BDFFE8   ADDIU SP, SP, -24
9D00A070  AFBF0014   SW RA, 20(SP)
104:                 
105:                     /* Check the application's current state. */
106:                     switch (appData.state) {
9D00A074  8F8281A8   LW V0, -32344(GP)
9D00A078  2C420006   SLTIU V0, V0, 6
9D00A07C  10400031   BEQ V0, ZERO, 0x9D00A144
9D00A080  8F8381A8   LW V1, -32344(GP)
9D00A084  00031880   SLL V1, V1, 2
9D00A088  3C029D01   LUI V0, -25343
9D00A08C  2442A09C   ADDIU V0, V0, -24420
9D00A090  7C43100A   LWX V0, V1(V0)
9D00A094  00400008   JR V0
9D00A098  00000000   NOP
107:                             /* Application's initial state. */
108:                         case APP_STATE_INIT:
109:                         {
110:                             bool appInitialized = true;
111:                 
112:                             if (appInitialized) {
113:                                 appData.state = APP_STATE_WATCHDOG;
9D00A0B4  24020001   ADDIU V0, ZERO, 1
9D00A0B8  AF8281A8   SW V0, -32344(GP)
114:                                 MotorFT.ReceivedData[1] = 0;
9D00A0BC  3C028000   LUI V0, -32768
9D00A0C0  0B402851   J 0x9D00A144
9D00A0C4  A440483E   SH ZERO, 18494(V0)
115:                             }
116:                             break;
117:                         }
118:                         case APP_STATE_WATCHDOG:
119:                         {
120:                             //WatchDogToggle();
121:                             appData.state = APP_STATE_COMS_CHECK;
9D00A0C8  24020003   ADDIU V0, ZERO, 3
122:                             break;
9D00A0CC  0B402851   J 0x9D00A144
9D00A0D0  AF8281A8   SW V0, -32344(GP)
123:                         }
124:                         case APP_STATE_SERVICE_MACRO:
125:                         {
126:                             if (getRunningMacros() != 0) {
9D00A0D4  0F40317C   JAL getRunningMacros
9D00A0D8  00000000   NOP
9D00A0DC  50400009   BEQL V0, ZERO, 0x9D00A104
9D00A0E0  3C02BF86   LUI V0, -16506
127:                                 runMacros();
9D00A0E4  0F402CCF   JAL runMacros
9D00A0E8  00000000   NOP
128:                                 LED4 = on;
9D00A0EC  3C02BF86   LUI V0, -16506
9D00A0F0  90430430   LBU V1, 1072(V0)
9D00A0F4  7C032104   INS V1, ZERO, 4, 1
9D00A0F8  A0430430   SB V1, 1072(V0)
9D00A0FC  0B402846   J 0x9D00A118
9D00A100  24020005   ADDIU V0, ZERO, 5
129:                             } else {
130:                                 LED4 = off;
9D00A104  90430430   LBU V1, 1072(V0)
9D00A108  24040001   ADDIU A0, ZERO, 1
9D00A10C  7C832104   INS V1, A0, 4, 1
9D00A110  A0430430   SB V1, 1072(V0)
131:                             }
132:                             appData.state = APP_STATE_AWAITING_RESPONSE;
9D00A114  24020005   ADDIU V0, ZERO, 5
133:                             break;
9D00A118  0B402851   J 0x9D00A144
9D00A11C  AF8281A8   SW V0, -32344(GP)
134:                         }
135:                         case APP_STATE_COMS_CHECK:
136:                         {
137:                 
138:                             //            if (timerDone(&receiveTimer)) {
139:                             //                // CAN FastTransfer Receive
140:                             //                if (ReceiveDataCAN(FT_LOCAL)) {
141:                             //
142:                             //                    if (getNewDataFlagStatus(FT_LOCAL,0x02)) {
143:                             //                        resetTimer(&BlinkTime);
144:                             //                        while (!timerDone(&BlinkTime)) {
145:                             //                            while (!timerDone(&ms100));
146:                             //                            LED1 ^= 1;
147:                             //                            LED4 ^= 1;
148:                             //                        }
149:                             //
150:                             //                    }
151:                             //                    if (getNewDataFlagStatus(FT_LOCAL,1 << CAN_COMMAND_INDEX)) {
152:                             //                        handleCANmacro(getCANFastData(FT_LOCAL,CAN_COMMAND_INDEX), getCANFastData(FT_LOCAL,CAN_COMMAND_DATA_INDEX)); 
153:                             //                    }
154:                             //                }
155:                             //            }
156:                             handleMacroStatus();
9D00A120  0F402AD6   JAL handleMacroStatus
9D00A124  00000000   NOP
157:                             publishData();
9D00A128  0F402A51   JAL publishData
9D00A12C  00000000   NOP
158:                             appData.state = APP_STATE_SERVICE_MACRO;
9D00A130  24020002   ADDIU V0, ZERO, 2
159:                             break;
9D00A134  0B402851   J 0x9D00A144
9D00A138  AF8281A8   SW V0, -32344(GP)
160:                         }
161:                         case APP_STATE_AWAITING_RESPONSE:
162:                         {
163:                             appData.state = APP_STATE_WATCHDOG;
9D00A13C  24020001   ADDIU V0, ZERO, 1
9D00A140  AF8281A8   SW V0, -32344(GP)
164:                             break;
165:                         }
166:                 
167:                         default:
168:                         {
169:                             /* TODO: Handle error in application's state machine. */
170:                             break;
171:                         }
172:                     }
173:                 }
9D00A144  8FBF0014   LW RA, 20(SP)
174:                 
175:                 bool getLoadedState() {
176:                     return isLoaded;
177:                 }
9D00CC9C  03E00008   JR RA
178:                 
179:                 /*******************************************************************************
180:                  End of File
181:                  */
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/algorithms.c  -----
1:                   
2:                   #include "map.h"
3:                   #include "Algorithms.h"
4:                   
5:                   #include "A_Star.h"
6:                   #include <math.h>
7:                   #include <stdbool.h>
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  
11:                  
12:                  LL_t *start = NULL;
13:                  
14:                  ASPathNodeSource NodeSource;
15:                  
16:                  
17:                  bool isPointThroughObstacle();
18:                  static void PathNodeNeighbors(ASNeighborList neighbors, void *node, void *context);
19:                  static float PathNodeHeuristic(void *fromNode, void *toNode, void *context);
20:                  bool isPathPoint(ASPath _path, int x, int y);
21:                  bool isTangentLineIntersecting(int y1, int x1, int y2, int x2);
22:                  
23:                  
24:                  static const ASPathNodeSource PathNodeSource = {
25:                      sizeof (PathNode),
26:                      &PathNodeNeighbors,
27:                      &PathNodeHeuristic,
28:                      NULL,
29:                      NULL
30:                  };
31:                  
32:                  void printListdata(void* nodePtr) {
00000000  00000000   NOP
33:                      printf("X: %d, Y: %d \r\n", (int) *((int*) nodePtr), (int) *((int*) nodePtr + sizeof (int)));
0000000C  00000000   NOP
34:                  }
00000020  00000000   NOP
35:                  
36:                  /*
37:                   *   Looks to see if the node has any neighbors that are an obstacle
38:                   */
39:                  static void PathNodeNeighbors(ASNeighborList neighbors, void *node, void *context) {
9D0096B8  27BDFFC0   ADDIU SP, SP, -64
9D0096BC  AFBF003C   SW RA, 60(SP)
9D0096C0  AFB10038   SW S1, 56(SP)
9D0096C4  AFB00034   SW S0, 52(SP)
9D0096C8  00808821   ADDU S1, A0, ZERO
9D0096CC  00A08021   ADDU S0, A1, ZERO
40:                      PathNode *pathNode = (PathNode *) node;
41:                  
42:                      if (WorldAt(pathNode->x + 1, pathNode->y) == 0) {
9D0096D0  8CA40000   LW A0, 0(A1)
9D0096D4  24840001   ADDIU A0, A0, 1
9D0096D8  0F403274   JAL WorldAt
9D0096DC  8CA50004   LW A1, 4(A1)
9D0096E0  5440000C   BNEL V0, ZERO, 0x9D009714
9D0096E4  8E040000   LW A0, 0(S0)
43:                  
44:                          ASNeighborListAdd(neighbors, &(PathNode) {
9D0096F0  AFA20028   SW V0, 40(SP)
9D0096F4  8E020004   LW V0, 4(S0)
9D0096F8  AFA2002C   SW V0, 44(SP)
9D0096FC  02202021   ADDU A0, S1, ZERO
9D009700  27A50028   ADDIU A1, SP, 40
9D009704  3C029D01   LUI V0, -25343
9D009708  0F402A23   JAL ASNeighborListAdd
9D00970C  8C46BDB8   LW A2, -16968(V0)
45:                              pathNode->x + 1, pathNode->y
9D0096E8  8E020000   LW V0, 0(S0)
9D0096EC  24420001   ADDIU V0, V0, 1
46:                          }, 1);
47:                      }
48:                      if (WorldAt(pathNode->x - 1, pathNode->y) == 0) {
9D009710  8E040000   LW A0, 0(S0)
9D009714  2484FFFF   ADDIU A0, A0, -1
9D009718  0F403274   JAL WorldAt
9D00971C  8E050004   LW A1, 4(S0)
9D009720  5440000C   BNEL V0, ZERO, 0x9D009754
9D009724  8E050004   LW A1, 4(S0)
49:                  
50:                          ASNeighborListAdd(neighbors, &(PathNode) {
9D009730  AFA20020   SW V0, 32(SP)
9D009734  8E020004   LW V0, 4(S0)
9D009738  AFA20024   SW V0, 36(SP)
9D00973C  02202021   ADDU A0, S1, ZERO
9D009740  27A50020   ADDIU A1, SP, 32
9D009744  3C029D01   LUI V0, -25343
9D009748  0F402A23   JAL ASNeighborListAdd
9D00974C  8C46BDB8   LW A2, -16968(V0)
51:                              pathNode->x - 1, pathNode->y
9D009728  8E020000   LW V0, 0(S0)
9D00972C  2442FFFF   ADDIU V0, V0, -1
52:                          }, 1);
53:                      }
54:                      if (WorldAt(pathNode->x, pathNode->y + 1) == 0) {
9D009750  8E050004   LW A1, 4(S0)
9D009754  8E040000   LW A0, 0(S0)
9D009758  0F403274   JAL WorldAt
9D00975C  24A50001   ADDIU A1, A1, 1
9D009760  5440000C   BNEL V0, ZERO, 0x9D009794
9D009764  8E050004   LW A1, 4(S0)
55:                  
56:                          ASNeighborListAdd(neighbors, &(PathNode) {
9D009768  8E020000   LW V0, 0(S0)
9D00976C  AFA20018   SW V0, 24(SP)
9D009778  AFA2001C   SW V0, 28(SP)
9D00977C  02202021   ADDU A0, S1, ZERO
9D009780  27A50018   ADDIU A1, SP, 24
9D009784  3C029D01   LUI V0, -25343
9D009788  0F402A23   JAL ASNeighborListAdd
9D00978C  8C46BDB8   LW A2, -16968(V0)
57:                              pathNode->x, pathNode->y + 1
9D009770  8E020004   LW V0, 4(S0)
9D009774  24420001   ADDIU V0, V0, 1
58:                          }, 1);
59:                      }
60:                      if (WorldAt(pathNode->x, pathNode->y - 1) == 0) {
9D009790  8E050004   LW A1, 4(S0)
9D009794  8E040000   LW A0, 0(S0)
9D009798  0F403274   JAL WorldAt
9D00979C  24A5FFFF   ADDIU A1, A1, -1
9D0097A0  1440000C   BNE V0, ZERO, 0x9D0097D4
9D0097A4  8FBF003C   LW RA, 60(SP)
61:                  
62:                          ASNeighborListAdd(neighbors, &(PathNode) {
9D0097A8  8E020000   LW V0, 0(S0)
9D0097AC  AFA20010   SW V0, 16(SP)
9D0097B8  AFA20014   SW V0, 20(SP)
9D0097BC  02202021   ADDU A0, S1, ZERO
9D0097C0  27A50010   ADDIU A1, SP, 16
9D0097C4  3C029D01   LUI V0, -25343
9D0097C8  0F402A23   JAL ASNeighborListAdd
9D0097CC  8C46BDB8   LW A2, -16968(V0)
63:                              pathNode->x, pathNode->y - 1
9D0097B0  8E020004   LW V0, 4(S0)
9D0097B4  2442FFFF   ADDIU V0, V0, -1
64:                          }, 1);
65:                      }
66:                  }
9D0097D0  8FBF003C   LW RA, 60(SP)
67:                  
68:                  static float PathNodeHeuristic(void *fromNode, void *toNode, void *context) {
9D00BF2C  27BDFFE8   ADDIU SP, SP, -24
9D00BF30  AFBF0014   SW RA, 20(SP)
69:                      PathNode *from = (PathNode *) fromNode;
70:                      PathNode *to = (PathNode *) toNode;
71:                  
72:                      static int xd, yd;
73:                      double d;
74:                      xd = to->x - from->x;
9D00BF34  8CA30000   LW V1, 0(A1)
9D00BF38  8C820000   LW V0, 0(A0)
9D00BF3C  00621823   SUBU V1, V1, V0
75:                      yd = to->y - from->y;
9D00BF40  8CA50004   LW A1, 4(A1)
9D00BF44  8C820004   LW V0, 4(A0)
9D00BF48  00A21023   SUBU V0, A1, V0
76:                  
77:                      // Euclidian Distance
78:                      d = (double) (sqrt((double) (xd * xd)+(double) (yd * yd)));
9D00BF4C  70631802   MUL V1, V1, V1
9D00BF50  44830000   MTC1 V1, F0
9D00BF54  46800060   CVT.S.W F1, F0
9D00BF58  70422002   MUL A0, V0, V0
9D00BF5C  44841000   MTC1 A0, F2
9D00BF60  46801020   CVT.S.W F0, F2
9D00BF64  46000B00   ADD.S F12, F1, F0
79:                  
80:                      // Manhattan distance
81:                      //d=fabs(from->x - to->x) + fabs(from->y - to->y);
82:                  
83:                      // Chebyshev distance
84:                      //d=max(abs(xd), abs(yd));
85:                      // using the manhatten distance since this is a simple grid and you can only move in 4 directions
86:                      return d;
87:                  }
9D00BF70  46200020   CVT.S.D F0, F0
88:                  
89:                  bool isPathPoint(ASPath _path, int x, int y) {
00000000  00000000   NOP
90:                      int i;
91:                      for (i = 0; i < ASPathGetCount(_path); i++) {
00000024  00000000   NOP
0000004C  00000000   NOP
92:                          PathNode *pathNode = ASPathGetNode(_path, i);
0000002C  00000000   NOP
93:                          if (pathNode->x == x && pathNode->y == y)
00000034  00000000   NOP
94:                              return true;
95:                  
96:                      }
97:                      return false;
98:                  }
00000068  00000000   NOP
99:                  // This can be optimized so that we step throught the path points from starting point to current point and
100:                 // when there is a valid path that is where we will put our waypoint on the map. this is contrary to how it
101:                 // is currently done where we start with a current point and loop backwards towards the start point and set
102:                 // the way point on the first collision with a wall or obstical
103:                 
104:                 void printListH(void* nodePtr) {
00000000  00000000   NOP
105:                     printf("Heading: %d, Dist: %d \r\n", ((PathNode*) nodePtr)->x, ((PathNode*) nodePtr)->y);
0000000C  00000000   NOP
106:                 }
00000020  00000000   NOP
107:                 
108:                 //LL_t *RobotPathPoints;
109:                 
110:                 void getPolarPath(LL_t* finalPath, point_t _pathFrom, point_t _pathTo) {
9D006940  27BDFF98   ADDIU SP, SP, -104
9D006944  AFBF0034   SW RA, 52(SP)
9D006948  AFBE0030   SW FP, 48(SP)
9D00694C  AFB7002C   SW S7, 44(SP)
9D006950  AFB60028   SW S6, 40(SP)
9D006954  AFB50024   SW S5, 36(SP)
9D006958  AFB40020   SW S4, 32(SP)
9D00695C  AFB3001C   SW S3, 28(SP)
9D006960  AFB20018   SW S2, 24(SP)
9D006964  AFB10014   SW S1, 20(SP)
9D006968  AFB00010   SW S0, 16(SP)
9D00696C  F7B80058   SDC1 F24, 88(SP)
9D006970  F7B70050   SDC1 F23, 80(SP)
9D006974  F7B60048   SDC1 F22, 72(SP)
9D006978  F7B50040   SDC1 F21, 64(SP)
9D00697C  F7B40038   SDC1 F20, 56(SP)
9D006980  AFA40068   SW A0, 104(SP)
9D006984  AFA5006C   SW A1, 108(SP)
9D006988  AFA60070   SW A2, 112(SP)
9D00698C  AFA70074   SW A3, 116(SP)
111:                     int pathSize;
112:                 
113:                     //    RobotPathPoints = LL_init();
114:                     // Not that the start point CAN NOT be 0, 0
115:                     const ASPath path = ASPathCreate(&PathNodeSource, NULL, &_pathFrom, &_pathTo);
9D006990  3C049D01   LUI A0, -25343
9D006994  2484BDA4   ADDIU A0, A0, -16988
9D006998  00002821   ADDU A1, ZERO, ZERO
9D00699C  27A6006C   ADDIU A2, SP, 108
9D0069A0  0F4000AE   JAL ASPathCreate
9D0069A4  27A70074   ADDIU A3, SP, 116
9D0069A8  0040B021   ADDU S6, V0, ZERO
116:                 
117:                     pathSize = ASPathGetCount(path);
9D0069AC  0F4032EA   JAL ASPathGetCount
9D0069B0  00402021   ADDU A0, V0, ZERO
9D0069B4  0040B821   ADDU S7, V0, ZERO
118:                     // Make sure there is a path to examine
119:                     if (pathSize > 1) {
9D0069B8  28420002   SLTI V0, V0, 2
9D0069BC  14400062   BNE V0, ZERO, .LVL149
9D0069C0  02C02021   ADDU A0, S6, ZERO
120:                         point_t segmentEndNode = *((point_t*) ASPathGetNode(path, 0)); //pathSize - 1));
9D0069C4  0F403124   JAL ASPathGetNode
9D0069C8  00002821   ADDU A1, ZERO, ZERO
9D0069CC  8C500000   LW S0, 0(V0)
9D0069DC  0200A021   ADDU S4, S0, ZERO
121:                         point_t lastNode;
122:                         lastNode = segmentEndNode;
9D0069D8  03C0A821   ADDU S5, FP, ZERO
123:                         int i;
124:                 
125:                         // Pushing the Ending point onto the robot's new Path
126:                         //        LL_push(RobotPathPoints, &_pathFrom);
127:                 
128:                         point_t pathNode;
129:                 
130:                         // This starts at the destination node and looks for viable paths in reverse
131:                         for (i = 0; i < pathSize; i++)//(i=pathSize -1; i >=0; i--)
9D0069D0  1AE0005D   BLEZ S7, .LVL149
9D0069D4  8C5E0004   LW FP, 4(V0)
9D0069E0  00008821   ADDU S1, ZERO, ZERO
9D006B34  26310001   ADDIU S1, S1, 1
9D006B38  12F10003   BEQ S7, S1, .LVL149
9D006B3C  0260A821   ADDU S5, S3, ZERO
132:                         {
133:                             // Getting a node from the A* path
134:                             pathNode = *((point_t*) ASPathGetNode(path, i));
9D0069F4  02C02021   ADDU A0, S6, ZERO
9D0069F8  0F403124   JAL ASPathGetNode
9D0069FC  02202821   ADDU A1, S1, ZERO
9D006A00  8C520000   LW S2, 0(V0)
9D006A04  8C530004   LW S3, 4(V0)
135:                             // find the nodes intersecting the tangent path between the two nodes
136:                             // is the tangent line going through the obstacle have we reached the final node of comparison
137:                             // Or if we have reached the final node in the list
138:                             if (isTangentLineIntersecting(pathNode.y, pathNode.x, segmentEndNode.y, segmentEndNode.x) || (pathNode.x == _pathTo.x && pathNode.y == _pathTo.y)) {
9D006A08  02602021   ADDU A0, S3, ZERO
9D006A0C  02402821   ADDU A1, S2, ZERO
9D006A10  03C03021   ADDU A2, FP, ZERO
9D006A14  0F4017EF   JAL isTangentLineIntersecting
9D006A18  02803821   ADDU A3, S4, ZERO
9D006A1C  14400009   BNE V0, ZERO, .LVL123, .LBB37
9D006A20  8FA20074   LW V0, 116(SP)
9D006A24  8FB00074   LW S0, 116(SP)
9D006A28  56120043   BNEL S0, S2, 0x9D006B38
9D006A2C  26310001   ADDIU S1, S1, 1
9D006A30  8FA20078   LW V0, 120(SP)
9D006A34  54530040   BNEL V0, S3, 0x9D006B38
9D006A38  26310001   ADDIU S1, S1, 1
9D006A3C  0B401A96   J .LVL125
9D006A40  8FB50078   LW S5, 120(SP)
139:                 
140:                                 if ((pathNode.x == _pathTo.x && pathNode.y == _pathTo.y))//||(pathNode.x == _pathTo.x && pathNode.y == _pathTo.y))
9D006A44  14520004   BNE V0, S2, .LVL125
9D006A48  8FA30078   LW V1, 120(SP)
9D006A4C  00732026   XOR A0, V1, S3
9D006A50  0064A80A   MOVZ S5, V1, A0
9D006A54  0044800A   MOVZ S0, V0, A0
141:                                 {
142:                                     lastNode = pathNode;
143:                                 }
144:                                 if(segmentEndNode.x == lastNode.x && segmentEndNode.y == lastNode.y)
9D006A58  56140006   BNEL S0, S4, .LVL128
9D006A5C  02BEF023   SUBU FP, S5, FP
9D006A60  56BE0004   BNEL S5, FP, .LVL128
9D006A64  02BEF023   SUBU FP, S5, FP
145:                                     lastNode = pathNode;
9D006A68  0260A821   ADDU S5, S3, ZERO
9D006A6C  02408021   ADDU S0, S2, ZERO
146:                                 double tanFrac = (double) ((double) (lastNode.y - segmentEndNode.y) / (double) (lastNode.x - segmentEndNode.x));
9D006A70  02BEF023   SUBU FP, S5, FP
9D006A74  449E0000   MTC1 FP, F0
9D006A78  46800620   CVT.S.W F24, F0
9D006A7C  0214A023   SUBU S4, S0, S4
9D006A80  44940000   MTC1 S4, F0
9D006A84  46800520   CVT.S.W F20, F0
9D006A88  4614C303   DIV.S F12, F24, F20
147:                 
148:                                 double heading;
149:                                 if (tanFrac < 0)
9D006A8C  44800000   MTC1 ZERO, F0
9D006A90  4600603C   C.LT.S F12, F0
9D006A94  4500000A   BC1F .LVL134, .LBB27
9D006A98  00000000   NOP
150:                                     heading = 180 + atan((tanFrac)) * (180.0 / 3.14159);
9D006AA8  3C029D01   LUI V0, -25343
9D006AAC  C442BDBC   LWC1 F2, -16964(V0)
9D006AB0  3C029D01   LUI V0, -25343
9D006AB4  C441BDC0   LWC1 F1, -16960(V0)
9D006AB8  0B401AB4   J .LVL136
9D006ABC  4C2205E0   MADD.S F23, F1, F0, F2
151:                                 else
152:                                     heading = atan((tanFrac)) * (180.0 / 3.14159);
9D0069EC  3C029D01   LUI V0, -25343
9D0069F0  C455BDBC   LWC1 F21, -16964(V0)
9D006ACC  461505C2   MUL.S F23, F0, F21
153:                 
154:                                 waypoint_t *polarTmp = malloc(sizeof (waypoint_t));
9D006AD0  0F4012F7   JAL malloc
9D006AD4  24040010   ADDIU A0, ZERO, 16
9D006AD8  0040A021   ADDU S4, V0, ZERO
155:                                 polarTmp->heading = (double) heading;
9D006ADC  E4570008   SWC1 F23, 8(V0)
156:                                 polarTmp->Distance = (double) sqrt(pow(lastNode.x - segmentEndNode.x, 2) + pow(lastNode.y - segmentEndNode.y, 2));
9D006B04  4600A300   ADD.S F12, F20, F0
157:                                 polarTmp->Endpoint = (point_t) lastNode;
9D006B18  AE900000   SW S0, 0(S4)
9D006B1C  AE950004   SW S5, 4(S4)
158:                 
159:                                 // Add polar way-point to list
160:                                 LL_pushBack(finalPath, polarTmp);
9D006B20  8FA40068   LW A0, 104(SP)
9D006B24  0F402F04   JAL LL_pushBack
9D006B28  02802821   ADDU A1, S4, ZERO
161:                 
162:                                 segmentEndNode = lastNode;
9D006B2C  02A0F021   ADDU FP, S5, ZERO
9D006B30  0200A021   ADDU S4, S0, ZERO
163:                 
164:                                 //                point_t *tmp = (point_t*) malloc(sizeof (point_t));
165:                                 //                tmp->x = lastNode.x;
166:                                 //                tmp->y = lastNode.y;
167:                                 //                LL_push(RobotPathPoints, tmp);
168:                 
169:                             }
170:                             lastNode = pathNode;
9D006B40  0B401A7D   J .LVL117, .LBE20
9D006B44  02408021   ADDU S0, S2, ZERO
171:                         }
172:                     }
173:                 
174:                     //LL_each(RobotPathPoints, printListH);
175:                 
176:                     ASPathDestroy(path);
9D006B48  0F4032B9   JAL ASPathDestroy
9D006B4C  02C02021   ADDU A0, S6, ZERO
177:                     //    LL_destroy(RobotPathPoints);
178:                 }
9D006B50  0B401AD6   J 0x9D006B58
179:                 
180:                 bool isPointThroughObstacle(int _x, int _y) {
9D00C9F4  27BDFFE8   ADDIU SP, SP, -24
9D00C9F8  AFBF0014   SW RA, 20(SP)
181:                 
182:                     if (WorldAt(_x, _y) == 1) {
9D00C9FC  0F403274   JAL WorldAt
9D00CA00  00000000   NOP
9D00CA04  38420001   XORI V0, V0, 1
183:                         return true;
184:                     }
185:                 
186:                     return false;
187:                 }
9D00CA08  2C420001   SLTIU V0, V0, 1
188:                 
189:                 bool isTangentLineIntersecting(int y1, int x1, int y2, int x2) {
9D005FBC  27BDFFB8   ADDIU SP, SP, -72
9D005FC0  AFBF0044   SW RA, 68(SP)
9D005FC4  AFBE0040   SW FP, 64(SP)
9D005FC8  AFB7003C   SW S7, 60(SP)
9D005FCC  AFB60038   SW S6, 56(SP)
9D005FD0  AFB50034   SW S5, 52(SP)
9D005FD4  AFB40030   SW S4, 48(SP)
9D005FD8  AFB3002C   SW S3, 44(SP)
9D005FDC  AFB20028   SW S2, 40(SP)
9D005FE0  AFB10024   SW S1, 36(SP)
9D005FE4  AFB00020   SW S0, 32(SP)
9D005FE8  00808821   ADDU S1, A0, ZERO
9D005FEC  00A09021   ADDU S2, A1, ZERO
190:                     int i; // loop counter
191:                     int ystep, xstep; // the step on y and x axis
192:                     int error; // the error accumulated during the increment
193:                     int errorprev; // *vision the previous value of the error variable
194:                     int y = y1, x = x1; // the line points
195:                     int ddy, ddx; // compulsory variables: the double values of dy and dx
196:                     int dx = x2 - x1;
9D005FF0  00E5B823   SUBU S7, A3, A1
197:                     int dy = y2 - y1;
198:                     bool intersectingObj = false;
199:                     
200:                     /* For every instance that intersectingObj is 'or'ed ('|') with its self so that if it found true it will remain true*/
201:                     intersectingObj = intersectingObj | isPointThroughObstacle(y1, x1); // first point
9D005FF4  0F40327D   JAL isPointThroughObstacle
9D005FF8  00C4F023   SUBU FP, A2, A0
9D005FFC  00408021   ADDU S0, V0, ZERO
202:                     // NB the last point can't be here, because of its previous point (which has to be verified)
203:                     if (dy < 0) {
9D006004  07C10005   BGEZ FP, 0x9D00601C
9D006008  AFA20014   SW V0, 20(SP)
204:                         ystep = -1;
9D006010  2403FFFF   ADDIU V1, ZERO, -1
9D006014  AFA30014   SW V1, 20(SP)
205:                         dy = -dy;
9D00600C  001EF023   SUBU FP, ZERO, FP
206:                     } else
207:                         ystep = 1;
9D006000  24020001   ADDIU V0, ZERO, 1
208:                     if (dx < 0) {
9D00601C  06E10004   BGEZ S7, .LVL52
9D006020  AFA20018   SW V0, 24(SP)
209:                         xstep = -1;
9D006028  2403FFFF   ADDIU V1, ZERO, -1
9D00602C  AFA30018   SW V1, 24(SP)
210:                         dx = -dx;
9D006024  0017B823   SUBU S7, ZERO, S7
211:                     } else
212:                         xstep = 1;
9D006018  24020001   ADDIU V0, ZERO, 1
213:                     ddy = 2 * dy; // work with double values for full precision
9D006030  001EA040   SLL S4, FP, 1
214:                     ddx = 2 * dx;
9D006034  0017A840   SLL S5, S7, 1
215:                     if (ddx >= ddy) // first octant (0 <= slope <= 1)
9D006038  02B4102A   SLT V0, S5, S4
9D00603C  10400005   BEQ V0, ZERO, .LVL57
9D006040  03C01021   ADDU V0, FP, ZERO
216:                     {
217:                         // compulsory initialization (even for errorprev, needed when dx==dy)
218:                         errorprev = error = dx; // start in the middle of the square
219:                         for (i = 0; i < dx; i++) // do not use the first point (already done)
9D006054  1AE00066   BLEZ S7, .LVL104
9D006058  02E01021   ADDU V0, S7, ZERO
9D00605C  0000F021   ADDU FP, ZERO, ZERO
9D006110  27DE0001   ADDIU FP, FP, 1
9D006114  13D70036   BEQ FP, S7, .LVL104
9D006118  305000FF   ANDI S0, V0, 255
220:                         {
221:                             x += xstep;
9D006060  8FA30018   LW V1, 24(SP)
9D006064  0243B021   ADDU S6, S2, V1
9D00611C  02C09021   ADDU S2, S6, ZERO
9D006120  0B401818   J .LVL58
9D006124  02601021   ADDU V0, S3, ZERO
222:                             error += ddy;
9D006068  00549821   ADDU S3, V0, S4
223:                             if (error > ddx) // increment y if AFTER the middle ( > )
9D00606C  02B3182A   SLT V1, S5, S3
9D006070  10600024   BEQ V1, ZERO, 0x9D006104
9D006074  02202021   ADDU A0, S1, ZERO
224:                             {
225:                                 y += ystep;
9D006078  8FA30014   LW V1, 20(SP)
9D00607C  02231821   ADDU V1, S1, V1
9D006080  AFA30010   SW V1, 16(SP)
9D0060FC  8FB10010   LW S1, 16(SP)
226:                                 error -= ddx;
9D006084  02759823   SUBU S3, S3, S5
227:                                 // three cases (octant == right->right-top for directions below):
228:                                 if (error + errorprev < ddx) // bottom square also
9D006088  02621021   ADDU V0, S3, V0
9D00608C  0055182A   SLT V1, V0, S5
9D006090  10600008   BEQ V1, ZERO, .LVL67
9D006094  02A2102A   SLT V0, S5, V0
229:                                     intersectingObj = intersectingObj | isPointThroughObstacle(y - ystep, x);
9D006098  02202021   ADDU A0, S1, ZERO
9D00609C  0F40327D   JAL isPointThroughObstacle
9D0060A0  02C02821   ADDU A1, S6, ZERO
9D0060A4  00501025   OR V0, V0, S0
9D0060A8  305000FF   ANDI S0, V0, 255
9D0060AC  0B401840   J .LVL76
9D0060B0  8FB10010   LW S1, 16(SP)
230:                                 else if (error + errorprev > ddx) // left square also
9D0060B4  10400008   BEQ V0, ZERO, .LVL70
9D0060B8  02202021   ADDU A0, S1, ZERO
231:                                     intersectingObj = intersectingObj |isPointThroughObstacle(y, x - xstep);
9D0060BC  8FA40010   LW A0, 16(SP)
9D0060C0  0F40327D   JAL isPointThroughObstacle
9D0060C4  02402821   ADDU A1, S2, ZERO
9D0060C8  00501025   OR V0, V0, S0
9D0060CC  305000FF   ANDI S0, V0, 255
9D0060D0  0B401840   J .LVL76
9D0060D4  8FB10010   LW S1, 16(SP)
232:                                 else // corner: bottom and left squares also
233:                                 {
234:                                     intersectingObj = intersectingObj | isPointThroughObstacle(y - ystep, x);
9D0060D8  0F40327D   JAL isPointThroughObstacle
9D0060DC  02C02821   ADDU A1, S6, ZERO
9D0060E0  00408821   ADDU S1, V0, ZERO
9D0060F0  02221025   OR V0, S1, V0
235:                                     intersectingObj = intersectingObj | isPointThroughObstacle(y, x - xstep);
9D0060E4  8FA40010   LW A0, 16(SP)
9D0060E8  0F40327D   JAL isPointThroughObstacle
9D0060EC  02402821   ADDU A1, S2, ZERO
9D0060F4  02028025   OR S0, S0, V0
9D0060F8  321000FF   ANDI S0, S0, 255
236:                                 }
237:                             }
238:                             intersectingObj = intersectingObj | isPointThroughObstacle(y, x);
9D006100  02202021   ADDU A0, S1, ZERO
9D006104  0F40327D   JAL isPointThroughObstacle
9D006108  02C02821   ADDU A1, S6, ZERO
9D00610C  00501025   OR V0, V0, S0
239:                             errorprev = error;
240:                         }
241:                     } else // the same as above
242:                     {
243:                         errorprev = error = dy;
244:                         for (i = 0; i < dy; i++) {
9D006044  1FC00038   BGTZ FP, .LVL81
9D006048  0000B821   ADDU S7, ZERO, ZERO
9D0061D8  26F70001   ADDIU S7, S7, 1
9D0061DC  12FE0004   BEQ S7, FP, .LVL104
9D0061E0  305000FF   ANDI S0, V0, 255
245:                             y += ystep;
9D006128  8FA30014   LW V1, 20(SP)
9D00612C  0223B021   ADDU S6, S1, V1
9D0061E4  02C08821   ADDU S1, S6, ZERO
9D0061E8  0B40184A   J .LVL81
9D0061EC  02601021   ADDU V0, S3, ZERO
246:                             error += ddx;
9D006130  00559821   ADDU S3, V0, S5
247:                             if (error > ddy) {
9D006134  0293182A   SLT V1, S4, S3
9D006138  10600024   BEQ V1, ZERO, 0x9D0061CC
9D00613C  02C02021   ADDU A0, S6, ZERO
248:                                 x += xstep;
9D006140  8FA30018   LW V1, 24(SP)
9D006144  02431821   ADDU V1, S2, V1
9D006148  AFA30010   SW V1, 16(SP)
9D0061C4  8FB20010   LW S2, 16(SP)
249:                                 error -= ddy;
9D00614C  02749823   SUBU S3, S3, S4
250:                                 if (error + errorprev < ddy)
9D006150  02621021   ADDU V0, S3, V0
9D006154  0054182A   SLT V1, V0, S4
9D006158  10600008   BEQ V1, ZERO, .LVL90
9D00615C  0282102A   SLT V0, S4, V0
251:                                     intersectingObj = intersectingObj | isPointThroughObstacle(y, x - xstep);
9D006160  02C02021   ADDU A0, S6, ZERO
9D006164  0F40327D   JAL isPointThroughObstacle
9D006168  02402821   ADDU A1, S2, ZERO
9D00616C  00501025   OR V0, V0, S0
9D006170  305000FF   ANDI S0, V0, 255
9D006174  0B401872   J .LVL99
9D006178  8FB20010   LW S2, 16(SP)
252:                                 else if (error + errorprev > ddy)
9D00617C  10400008   BEQ V0, ZERO, .LVL93
9D006180  02C02021   ADDU A0, S6, ZERO
253:                                     intersectingObj = intersectingObj |isPointThroughObstacle(y - ystep, x);
9D006184  02202021   ADDU A0, S1, ZERO
9D006188  0F40327D   JAL isPointThroughObstacle
9D00618C  8FA50010   LW A1, 16(SP)
9D006190  00501025   OR V0, V0, S0
9D006194  305000FF   ANDI S0, V0, 255
9D006198  0B401872   J .LVL99
9D00619C  8FB20010   LW S2, 16(SP)
254:                                 else {
255:                                     intersectingObj = intersectingObj | isPointThroughObstacle(y, x - xstep);
9D0061A0  0F40327D   JAL isPointThroughObstacle
9D0061A4  02402821   ADDU A1, S2, ZERO
9D0061A8  00409021   ADDU S2, V0, ZERO
9D0061B8  02421025   OR V0, S2, V0
256:                                     intersectingObj = intersectingObj |isPointThroughObstacle(y - ystep, x);
9D0061AC  02202021   ADDU A0, S1, ZERO
9D0061B0  0F40327D   JAL isPointThroughObstacle
9D0061B4  8FA50010   LW A1, 16(SP)
9D0061BC  02028025   OR S0, S0, V0
9D0061C0  321000FF   ANDI S0, S0, 255
257:                                 }
258:                             }
259:                             intersectingObj = intersectingObj | isPointThroughObstacle(y, x);
9D0061C8  02C02021   ADDU A0, S6, ZERO
9D0061CC  0F40327D   JAL isPointThroughObstacle
9D0061D0  02402821   ADDU A1, S2, ZERO
9D0061D4  00501025   OR V0, V0, S0
260:                             errorprev = error;
261:                         }
262:                     }
263:                 
264:                    
265:                     return intersectingObj;
266:                     // assert ((y == y2) && (x == x2));  // the last point (y2,x2) has to be the same with the last point of the algorithm
267:                 }
9D00604C  0B40187D   J 0x9D0061F4
9D006050  02001021   ADDU V0, S0, ZERO
9D0061F0  02001021   ADDU V0, S0, ZERO
---  c:/microchip/harmony/v2_05_01/apps/master-controller/navicontroller/firmware/src/a_star.c  ---------
1:                   /*
2:                    Copyright (c) 2012, Sean Heber. All rights reserved.
3:                   
4:                    Redistribution and use in source and binary forms, with or without
5:                    modification, are permitted provided that the following conditions are met:
6:                   
7:                    1. Redistributions of source code must retain the above copyright
8:                    notice, this list of conditions and the following disclaimer.
9:                   
10:                   2. Redistributions in binary form must reproduce the above copyright notice,
11:                   this list of conditions and the following disclaimer in the documentation
12:                   and/or other materials provided with the distribution.
13:                  
14:                   3. Neither the name of Sean Heber nor the names of its contributors may
15:                   be used to endorse or promote products derived from this software without
16:                   specific prior written permission.
17:                  
18:                   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
19:                   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
20:                   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
21:                   DISCLAIMED. IN NO EVENT SHALL SEAN HEBER BE LIABLE FOR ANY DIRECT,
22:                   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
23:                   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
24:                   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
25:                   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
26:                   OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
27:                   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
28:                   */
29:                  
30:                  #include "A_Star.h"
31:                  #include <math.h>
32:                  #include <string.h>
33:                  #include <stdint.h>
34:                  
35:                  #define INFINITY 0xFFFFFF
36:                  
37:                  struct __ASNeighborList {
38:                      const ASPathNodeSource *source;
39:                      size_t capacity;
40:                      size_t count;
41:                      float *costs;
42:                      void *nodeKeys;
43:                  };
44:                  
45:                  
46:                  
47:                  typedef struct {
48:                      unsigned isClosed:1;
49:                      unsigned isOpen:1;
50:                      unsigned isGoal:1;
51:                      unsigned hasParent:1;
52:                      unsigned hasEstimatedCost:1;
53:                      float estimatedCost;
54:                      float cost;
55:                      size_t openIndex;
56:                      size_t parentIndex;
57:                      int8_t nodeKey[];
58:                  } NodeRecord;
59:                  
60:                  struct __VisitedNodes {
61:                      const ASPathNodeSource *source;
62:                      void *context;
63:                      size_t nodeRecordsCapacity;
64:                      size_t nodeRecordsCount;
65:                      void *nodeRecords;
66:                      size_t *nodeRecordsIndex;           // array of nodeRecords indexes, kept sorted by nodeRecords[i]->nodeKey using source->nodeComparator
67:                      size_t openNodesCapacity;
68:                      size_t openNodesCount;
69:                      size_t *openNodes;                  // binary heap of nodeRecords indexes, sorted by the nodeRecords[i]->rank
70:                  };
71:                  typedef struct __VisitedNodes *VisitedNodes;
72:                  
73:                  typedef struct {
74:                      VisitedNodes nodes;
75:                      size_t index;
76:                  } Node;
77:                  
78:                  static const Node NodeNull = {NULL, -1};
79:                  
80:                  /********************************************/
81:                  
82:                  static inline VisitedNodes VisitedNodesCreate(const ASPathNodeSource *source, void *context)
83:                  {
84:                      VisitedNodes nodes = calloc(1, sizeof(struct __VisitedNodes));
9D000320  0F403032   JAL calloc
85:                      nodes->source = source;
9D00032C  8FA20060   LW V0, 96(SP)
86:                      nodes->context = context;
9D000334  8FA30064   LW V1, 100(SP)
87:                      return nodes;
88:                  }
89:                  
90:                  static inline void VisitedNodesDestroy(VisitedNodes visitedNodes)
91:                  {
92:                      free(visitedNodes->nodeRecordsIndex);
9D0013D8  0F4031CD   JAL .LFB1, free
9D0013DC  8E440014   LW A0, 20(S2)
93:                      free(visitedNodes->nodeRecords);
9D0013E0  0F4031CD   JAL .LFB1, free
9D0013E4  8E440010   LW A0, 16(S2)
94:                      free(visitedNodes->openNodes);
9D0013E8  0F4031CD   JAL .LFB1, free
9D0013EC  8E440020   LW A0, 32(S2)
95:                      free(visitedNodes);
9D0013F0  0F4031CD   JAL .LFB1, free
9D0013F4  02402021   ADDU A0, S2, ZERO
96:                  }
97:                  
98:                  static inline int NodeIsNull(Node n)
99:                  {
100:                     return (n.nodes == NodeNull.nodes) && (n.index == NodeNull.index);
9D0006B4  56400356   BNEL S2, ZERO, .LVL252, .LBB1009, .LBB639
9D0006B8  8E420000   LW V0, 0(S2)
9D0006BC  2402FFFF   ADDIU V0, ZERO, -1
9D0006C0  8FA5001C   LW A1, 28(SP)
9D0006C4  54A20352   BNEL A1, V0, .LVL252, .LBB1009, .LBB639
9D0006C8  8E420000   LW V0, 0(S2)
9D0006E4  16400359   BNE S2, ZERO, .LVL255, .LBB1011, .LBB649
9D0006E8  8FA70018   LW A3, 24(SP)
9D0006EC  2404FFFF   ADDIU A0, ZERO, -1
9D0006F0  8FA60010   LW A2, 16(SP)
9D0006F4  14C40355   BNE A2, A0, .LVL255, .LBB1011, .LBB649
9D0006F8  00000000   NOP
9D000704  8FA7001C   LW A3, 28(SP)
9D000708  10E40003   BEQ A3, A0, .LVL68, .LBB659, .LBB660, .LBB661
9D00070C  44800000   MTC1 ZERO, F0
9D000910  164002E4   BNE S2, ZERO, .LVL258, .LBB1012, .LBB701, .LBB698
9D000914  8FA20010   LW V0, 16(SP)
9D000918  2403FFFF   ADDIU V1, ZERO, -1
9D00091C  544302E2   BNEL V0, V1, 0x9D0014A8
9D000920  8E430000   LW V1, 0(S2)
9D000924  0B4004B5   J 0x9D0012D4
9D000928  8FAB0018   LW T3, 24(SP)
9D000DD4  14C001BE   BNE A2, ZERO, .LVL260, .LBB1013, .LBB828
9D000DD8  8FA70018   LW A3, 24(SP)
9D000DDC  2403FFFF   ADDIU V1, ZERO, -1
9D000DE0  16C301BB   BNE S6, V1, .LVL260, .LBB1013, .LBB828
9D000DE4  00000000   NOP
9D000DE8  0B400383   J 0x9D000E0C
9D000DEC  278480E4   ADDIU A0, GP, -32540
9D000DF0  8FA5001C   LW A1, 28(SP)
9D000DF4  2407FFFF   ADDIU A3, ZERO, -1
9D000DF8  10A70003   BEQ A1, A3, .LVL159
9D000DFC  44800000   MTC1 ZERO, F0
9D0010FC  16400103   BNE S2, ZERO, .LVL264, .LBE1013, .LBB1014
9D001100  C79580DC   LWC1 F21, -32548(GP)
9D001104  8FA40010   LW A0, 16(SP)
9D001108  2405FFFF   ADDIU A1, ZERO, -1
9D00110C  14850100   BNE A0, A1, 0x9D001510
9D001110  92A20000   LBU V0, 0(S5)
9D0012B4  1640009E   BNE S2, ZERO, .LVL266, .LBB1015, .LBB960
9D0012B8  AFA20010   SW V0, 16(SP)
9D0012BC  240AFFFF   ADDIU T2, ZERO, -1
9D0012C0  544A009C   BNEL V0, T2, .LVL267
9D0012C4  8E420000   LW V0, 0(S2)
9D0012D0  8FAB0018   LW T3, 24(SP)
9D0012D4  1560000B   BNE T3, ZERO, .LVL233, .LBB974, .LBB976
9D0012D8  2402FFFF   ADDIU V0, ZERO, -1
9D0012DC  8FA3001C   LW V1, 28(SP)
9D0012E0  14620008   BNE V1, V0, .LVL233, .LBB974, .LBB976
9D0012E4  00000000   NOP
9D0012E8  0B400559   J .LVL268, .LBB1016, .LBB970
9D0012EC  00000000   NOP
9D0012F0  8FA40010   LW A0, 16(SP)
9D0012F4  5482009E   BNEL A0, V0, 0x9D001570
9D0012F8  8E420000   LW V0, 0(S2)
9D001304  564000A5   BNEL S2, ZERO, .LVL271, .LBB1017, .LBB978
9D001308  8E420000   LW V0, 0(S2)
9D00130C  2402FFFF   ADDIU V0, ZERO, -1
9D001310  8FA50010   LW A1, 16(SP)
9D001314  54A200A1   BNEL A1, V0, .LVL271, .LBB1017, .LBB978
9D001318  8E420000   LW V0, 0(S2)
9D001328  566000AB   BNEL S3, ZERO, .LVL272, .LBB1018, .LBB998, .LBB984
9D00132C  8E620000   LW V0, 0(S3)
9D001330  568400A9   BNEL S4, A0, .LVL272, .LBB1018, .LBB998, .LBB984
9D001334  8E620000   LW V0, 0(S3)
9D00144C  10E0FCAD   BEQ A3, ZERO, .LVL66, .LBB658, .LBB646
9D001450  2404FFFF   ADDIU A0, ZERO, -1
9D0014D0  10E0FE47   BEQ A3, ZERO, .LVL157, .LBE823, .LBB825
9D0014D4  8FA80018   LW T0, 24(SP)
9D001564  1240FF62   BEQ S2, ZERO, .LVL232, .LBE963, .LBB965, .LBB967
9D001568  2402FFFF   ADDIU V0, ZERO, -1
9D0015D0  0B4004CA   J .LVL235, .LBE982, .LBB987
9D0015D4  2404FFFF   ADDIU A0, ZERO, -1
101:                 }
102:                 
103:                 static inline Node NodeMake(VisitedNodes nodes, size_t index)
104:                 {
105:                     return (Node){nodes, index};
9D000C98  0B400364   J .LVL153, .LBE816
9D000C9C  02401021   ADDU V0, S2, ZERO
106:                 }
107:                 
108:                 static inline NodeRecord *NodeGetRecord(Node node)
109:                 {
110:                     return node.nodes->nodeRecords + (node.index * (node.nodes->source->nodeSize + sizeof(NodeRecord)));
9D000388  8C450000   LW A1, 0(V0)
9D0003B4  8C460000   LW A2, 0(V0)
9D0004C4  8E420000   LW V0, 0(S2)
9D0004C8  8C530000   LW S3, 0(V0)
9D0004CC  26730014   ADDIU S3, S3, 20
9D0004D0  8E420010   LW V0, 16(S2)
9D0004D4  72632002   MUL A0, S3, V1
9D0004D8  00829821   ADDU S3, A0, V0
9D000540  8C450000   LW A1, 0(V0)
9D000544  24A50014   ADDIU A1, A1, 20
9D000548  8E420010   LW V0, 16(S2)
9D00054C  70853002   MUL A2, A0, A1
9D000550  00C22021   ADDU A0, A2, V0
9D00056C  8C460000   LW A2, 0(V0)
9D000570  24C30014   ADDIU V1, A2, 20
9D000574  8E420010   LW V0, 16(S2)
9D000578  70832802   MUL A1, A0, V1
9D00057C  00A22021   ADDU A0, A1, V0
9D000678  8E420000   LW V0, 0(S2)
9D00067C  8C530000   LW S3, 0(V0)
9D000680  26730014   ADDIU S3, S3, 20
9D000684  8E420010   LW V0, 16(S2)
9D000688  72632002   MUL A0, S3, V1
9D00068C  00829821   ADDU S3, A0, V0
9D0006FC  0B4001C7   J 0x9D00071C
9D000700  8E420000   LW V0, 0(S2)
9D000710  0B400516   J 0x9D001458
9D000714  8C640000   LW A0, 0(V1)
9D000718  8E420000   LW V0, 0(S2)
9D00071C  8C430000   LW V1, 0(V0)
9D000720  24630014   ADDIU V1, V1, 20
9D000724  8E420010   LW V0, 16(S2)
9D000728  8FA40010   LW A0, 16(SP)
9D00072C  70832802   MUL A1, A0, V1
9D000730  00A21021   ADDU V0, A1, V0
9D000748  8E420000   LW V0, 0(S2)
9D00074C  8C560000   LW S6, 0(V0)
9D000750  26D60014   ADDIU S6, S6, 20
9D000754  8E420010   LW V0, 16(S2)
9D000758  8FA30010   LW V1, 16(SP)
9D00075C  70762002   MUL A0, V1, S6
9D000760  0082B021   ADDU S6, A0, V0
9D00083C  8E430010   LW V1, 16(S2)
9D000840  8E440000   LW A0, 0(S2)
9D000844  8C860000   LW A2, 0(A0)
9D000848  24C60014   ADDIU A2, A2, 20
9D00084C  7CE8200A   LWX A0, T0(A3)
9D000850  70C44802   MUL T1, A2, A0
9D000854  01232021   ADDU A0, T1, V1
9D000864  7CE5380A   LWX A3, A1(A3)
9D000868  70C74802   MUL T1, A2, A3
9D00086C  01231821   ADDU V1, T1, V1
9D0008DC  8E430000   LW V1, 0(S2)
9D0008E0  8C650000   LW A1, 0(V1)
9D0008E4  24A50014   ADDIU A1, A1, 20
9D0008E8  8E430010   LW V1, 16(S2)
9D0008EC  70853002   MUL A2, A0, A1
9D0008F0  00C32821   ADDU A1, A2, V1
9D000934  8E420000   LW V0, 0(S2)
9D000938  8C430000   LW V1, 0(V0)
9D00093C  24630014   ADDIU V1, V1, 20
9D000940  8E420010   LW V0, 16(S2)
9D000944  8FA40010   LW A0, 16(SP)
9D000948  70642802   MUL A1, V1, A0
9D00094C  00A21021   ADDU V0, A1, V0
9D000988  8E480010   LW T0, 16(S2)
9D00098C  8E450000   LW A1, 0(S2)
9D000990  8CA50000   LW A1, 0(A1)
9D000994  24A50014   ADDIU A1, A1, 20
9D000998  7CC2380A   LWX A3, V0(A2)
9D00099C  70A74802   MUL T1, A1, A3
9D0009A0  01283821   ADDU A3, T1, T0
9D0009A8  7CC4300A   LWX A2, A0(A2)
9D0009AC  70A64802   MUL T1, A1, A2
9D0009B0  01282821   ADDU A1, T1, T0
9D0009F8  8E480010   LW T0, 16(S2)
9D0009FC  8E450000   LW A1, 0(S2)
9D000A00  8CA50000   LW A1, 0(A1)
9D000A04  24A50014   ADDIU A1, A1, 20
9D000A08  7CC4380A   LWX A3, A0(A2)
9D000A0C  70A74802   MUL T1, A1, A3
9D000A10  01283821   ADDU A3, T1, T0
9D000A14  7CC3300A   LWX A2, V1(A2)
9D000A18  70A64802   MUL T1, A1, A2
9D000A1C  01282821   ADDU A1, T1, T0
9D000A70  8E480010   LW T0, 16(S2)
9D000A74  8E460000   LW A2, 0(S2)
9D000A78  8CC60000   LW A2, 0(A2)
9D000A7C  24C60014   ADDIU A2, A2, 20
9D000A84  7CE9480A   LWX T1, T1(A3)
9D000A88  70C95002   MUL T2, A2, T1
9D000A8C  01484821   ADDU T1, T2, T0
9D000AA0  7CE9380A   LWX A3, T1(A3)
9D000AA4  70C74802   MUL T1, A2, A3
9D000AA8  01283021   ADDU A2, T1, T0
9D000AD8  8E470010   LW A3, 16(S2)
9D000ADC  8E450000   LW A1, 0(S2)
9D000AE0  8CA50000   LW A1, 0(A1)
9D000AE4  24A50014   ADDIU A1, A1, 20
9D000AE8  7CC8400A   LWX T0, T0(A2)
9D000AEC  70A84802   MUL T1, A1, T0
9D000AF0  01274021   ADDU T0, T1, A3
9D000B04  7CC8300A   LWX A2, T0(A2)
9D000B08  70A64002   MUL T0, A1, A2
9D000B0C  01072821   ADDU A1, T0, A3
9D000B2C  8E420000   LW V0, 0(S2)
9D000B30  8C430000   LW V1, 0(V0)
9D000B34  24630014   ADDIU V1, V1, 20
9D000B5C  8E420000   LW V0, 0(S2)
9D000B60  8C450000   LW A1, 0(V0)
9D000B64  24A50014   ADDIU A1, A1, 20
9D000B68  8E420010   LW V0, 16(S2)
9D000B6C  8FA30010   LW V1, 16(SP)
9D000B70  70652002   MUL A0, V1, A1
9D000B74  00822821   ADDU A1, A0, V0
9D000BA0  8E420000   LW V0, 0(S2)
9D000BA4  8C430000   LW V1, 0(V0)
9D000BA8  24630014   ADDIU V1, V1, 20
9D000C20  8C450000   LW A1, 0(V0)
9D000C24  24A50014   ADDIU A1, A1, 20
9D000C28  8E420010   LW V0, 16(S2)
9D000C2C  70853002   MUL A2, A0, A1
9D000C30  00C22021   ADDU A0, A2, V0
9D000C4C  8C460000   LW A2, 0(V0)
9D000C50  24C30014   ADDIU V1, A2, 20
9D000C54  8E420010   LW V0, 16(S2)
9D000C58  70832802   MUL A1, A0, V1
9D000C5C  00A22021   ADDU A0, A1, V0
9D000D48  8E420000   LW V0, 0(S2)
9D000D4C  8C530000   LW S3, 0(V0)
9D000D50  26730014   ADDIU S3, S3, 20
9D000D54  8E420010   LW V0, 16(S2)
9D000D58  72761802   MUL V1, S3, S6
9D000D5C  00629821   ADDU S3, V1, V0
9D000DA0  8C430000   LW V1, 0(V0)
9D000DA4  8C650000   LW A1, 0(V1)
9D000DA8  24A50014   ADDIU A1, A1, 20
9D000DAC  8C440010   LW A0, 16(V0)
9D000DB0  72C51002   MUL V0, S6, A1
9D000DB4  00442021   ADDU A0, V0, A0
9D000E00  0B400536   J .LBE828, .LBB829, .LBB830
9D000E04  8FA80018   LW T0, 24(SP)
9D000E08  278480E4   ADDIU A0, GP, -32540
9D000E0C  8C830000   LW V1, 0(A0)
9D000E10  8C620000   LW V0, 0(V1)
9D000E14  8C450000   LW A1, 0(V0)
9D000E18  24A50014   ADDIU A1, A1, 20
9D000E1C  8C840004   LW A0, 4(A0)
9D000E20  8C620010   LW V0, 16(V1)
9D000E24  70A41802   MUL V1, A1, A0
9D000E28  00621021   ADDU V0, V1, V0
9D000E48  8C440000   LW A0, 0(V0)
9D000E4C  8C860000   LW A2, 0(A0)
9D000E50  24C60014   ADDIU A2, A2, 20
9D000E54  8C650004   LW A1, 4(V1)
9D000E58  8C440010   LW A0, 16(V0)
9D000E5C  70C53802   MUL A3, A2, A1
9D000E60  00E41821   ADDU V1, A3, A0
9D000EC0  8C490010   LW T1, 16(V0)
9D000EC4  8C460000   LW A2, 0(V0)
9D000EC8  8CC60000   LW A2, 0(A2)
9D000ECC  24C60014   ADDIU A2, A2, 20
9D000ED0  7CE3400A   LWX T0, V1(A3)
9D000ED4  70C85002   MUL T2, A2, T0
9D000ED8  01494021   ADDU T0, T2, T1
9D000EE0  7CE5380A   LWX A3, A1(A3)
9D000EE4  70C75002   MUL T2, A2, A3
9D000EE8  01493021   ADDU A2, T2, T1
9D000F30  8C490010   LW T1, 16(V0)
9D000F34  8C460000   LW A2, 0(V0)
9D000F38  8CC60000   LW A2, 0(A2)
9D000F3C  24C60014   ADDIU A2, A2, 20
9D000F40  7CE5400A   LWX T0, A1(A3)
9D000F44  70C85002   MUL T2, A2, T0
9D000F48  01494021   ADDU T0, T2, T1
9D000F4C  7CE4380A   LWX A3, A0(A3)
9D000F50  70C75002   MUL T2, A2, A3
9D000F54  01493021   ADDU A2, T2, T1
9D000FA8  8C490010   LW T1, 16(V0)
9D000FAC  8C470000   LW A3, 0(V0)
9D000FB0  8CE70000   LW A3, 0(A3)
9D000FB4  24E70014   ADDIU A3, A3, 20
9D000FBC  7D0A500A   LWX T2, T2(T0)
9D000FC0  70EA5802   MUL T3, A3, T2
9D000FC4  01695021   ADDU T2, T3, T1
9D000FD8  7D0A400A   LWX T0, T2(T0)
9D000FDC  70E85002   MUL T2, A3, T0
9D000FE0  01493821   ADDU A3, T2, T1
9D001010  8C480010   LW T0, 16(V0)
9D001014  8C460000   LW A2, 0(V0)
9D001018  8CC60000   LW A2, 0(A2)
9D00101C  24C60014   ADDIU A2, A2, 20
9D001020  7CE9480A   LWX T1, T1(A3)
9D001024  70C95002   MUL T2, A2, T1
9D001028  01484821   ADDU T1, T2, T0
9D00103C  7CE9380A   LWX A3, T1(A3)
9D001040  70C74802   MUL T1, A2, A3
9D001044  01283021   ADDU A2, T1, T0
9D00106C  8C620000   LW V0, 0(V1)
9D001070  8C450000   LW A1, 0(V0)
9D001074  24A50014   ADDIU A1, A1, 20
9D001078  8C840004   LW A0, 4(A0)
9D00107C  8C620010   LW V0, 16(V1)
9D001080  70A41802   MUL V1, A1, A0
9D001084  00621021   ADDU V0, V1, V0
9D0010C4  8E620000   LW V0, 0(S3)
9D0010C8  8C550000   LW S5, 0(V0)
9D0010CC  26B50014   ADDIU S5, S5, 20
9D0010D0  8E620010   LW V0, 16(S3)
9D0010D4  72B61802   MUL V1, S5, S6
9D0010D8  0062A821   ADDU S5, V1, V0
9D0011DC  8E630010   LW V1, 16(S3)
9D0011E0  8E640000   LW A0, 0(S3)
9D0011E4  8C860000   LW A2, 0(A0)
9D0011E8  24C60014   ADDIU A2, A2, 20
9D0011EC  7CE8200A   LWX A0, T0(A3)
9D0011F0  70C44802   MUL T1, A2, A0
9D0011F4  01232021   ADDU A0, T1, V1
9D001204  7CE5380A   LWX A3, A1(A3)
9D001208  70C74802   MUL T1, A2, A3
9D00120C  01231821   ADDU V1, T1, V1
9D001284  0B4002E9   J 0x9D000BA4
9D001288  8E420000   LW V0, 0(S2)
9D001354  8E020000   LW V0, 0(S0)
9D001358  8C450000   LW A1, 0(V0)
9D00135C  24A50014   ADDIU A1, A1, 20
9D001360  8E020010   LW V0, 16(S0)
9D001364  8FA30010   LW V1, 16(SP)
9D001368  70653802   MUL A3, V1, A1
9D00136C  00E22821   ADDU A1, A3, V0
9D00137C  8E020000   LW V0, 0(S0)
9D001380  8C430000   LW V1, 0(V0)
9D001384  24630014   ADDIU V1, V1, 20
9D001388  8E020010   LW V0, 16(S0)
9D00138C  8FA40010   LW A0, 16(SP)
9D001390  70832802   MUL A1, A0, V1
9D001394  00A21021   ADDU V0, A1, V0
9D001410  8C430000   LW V1, 0(V0)
9D001414  24630014   ADDIU V1, V1, 20
9D001454  8C640000   LW A0, 0(V1)
9D001458  24840014   ADDIU A0, A0, 20
9D00145C  8E430010   LW V1, 16(S2)
9D001460  8FA50010   LW A1, 16(SP)
9D001464  70A43002   MUL A2, A1, A0
9D001468  00C32021   ADDU A0, A2, V1
9D00146C  8FA70018   LW A3, 24(SP)
9D001470  8CE30000   LW V1, 0(A3)
9D001474  8C650000   LW A1, 0(V1)
9D001478  24A50014   ADDIU A1, A1, 20
9D00147C  8CE30010   LW V1, 16(A3)
9D001480  8FA6001C   LW A2, 28(SP)
9D001484  70C53802   MUL A3, A2, A1
9D001488  00E32821   ADDU A1, A3, V1
9D00149C  0B4001C7   J 0x9D00071C
9D0014A0  8E420000   LW V0, 0(S2)
9D0014A4  8E430000   LW V1, 0(S2)
9D0014A8  8C640000   LW A0, 0(V1)
9D0014AC  24840014   ADDIU A0, A0, 20
9D0014D8  8D030000   LW V1, 0(T0)
9D0014DC  8C650000   LW A1, 0(V1)
9D0014E0  24A50014   ADDIU A1, A1, 20
9D0014E4  8D030010   LW V1, 16(T0)
9D0014E8  8FA7001C   LW A3, 28(SP)
9D0014EC  70E54002   MUL T0, A3, A1
9D0014F0  01032821   ADDU A1, T0, V1
9D001530  8E420000   LW V0, 0(S2)
9D001534  8C430000   LW V1, 0(V0)
9D001538  24630014   ADDIU V1, V1, 20
9D00156C  8E420000   LW V0, 0(S2)
9D001570  8C430000   LW V1, 0(V0)
9D001574  24630014   ADDIU V1, V1, 20
9D00159C  8C430000   LW V1, 0(V0)
9D0015A0  24630014   ADDIU V1, V1, 20
9D0015D8  8C430000   LW V1, 0(V0)
9D0015DC  24630014   ADDIU V1, V1, 20
9D0015E0  8E620010   LW V0, 16(S3)
9D0015E4  72832802   MUL A1, S4, V1
9D0015E8  00A2A021   ADDU S4, A1, V0
9D001624  8E420000   LW V0, 0(S2)
9D001628  8C430000   LW V1, 0(V0)
9D00162C  24630014   ADDIU V1, V1, 20
111:                 }
112:                 
113:                 static inline void *GetNodeKey(Node node)
114:                 {
115:                     return NodeGetRecord(node)->nodeKey;
116:                 }
117:                 
118:                 static inline int NodeIsInOpenSet(Node n)
119:                 {
120:                     return NodeGetRecord(n)->isOpen;
9D000E64  8C640000   LW A0, 0(V1)
9D0010DC  8EA20000   LW V0, 0(S5)
121:                 }
122:                 
123:                 static inline int NodeIsInClosedSet(Node n)
124:                 {
125:                     return NodeGetRecord(n)->isClosed;
9D001088  8C430000   LW V1, 0(V0)
9D0010EC  8EA20000   LW V0, 0(S5)
126:                 }
127:                 
128:                 static inline void RemoveNodeFromClosedSet(Node n)
129:                 {
130:                     NodeGetRecord(n)->isClosed = 0;
9D0010AC  90430000   LBU V1, 0(V0)
9D0010B0  7C030004   INS V1, ZERO, 0, 1
9D0010B4  A0430000   SB V1, 0(V0)
9D0010B8  278280E4   ADDIU V0, GP, -32540
9D0010BC  8C530000   LW S3, 0(V0)
9D0010C0  8C560004   LW S6, 4(V0)
131:                 }
132:                 
133:                 static inline void AddNodeToClosedSet(Node n)
134:                 {
135:                     NodeGetRecord(n)->isClosed = 1;
9D000B38  8E420010   LW V0, 16(S2)
9D000B3C  8FA40010   LW A0, 16(SP)
9D000B40  70832802   MUL A1, A0, V1
9D000B44  00A21821   ADDU V1, A1, V0
9D000B48  90620000   LBU V0, 0(V1)
9D000B4C  24040001   ADDIU A0, ZERO, 1
9D000B50  7C820004   INS V0, A0, 0, 1
9D000B54  A0620000   SB V0, 0(V1)
136:                 }
137:                 
138:                 static inline float GetNodeRank(Node n)
139:                 {
140:                     NodeRecord *record = NodeGetRecord(n);
141:                     return record->estimatedCost + record->cost;
9D000858  C4810004   LWC1 F1, 4(A0)
9D00085C  C4800008   LWC1 F0, 8(A0)
9D000860  46000880   ADD.S F2, F1, F0
9D000870  C4610004   LWC1 F1, 4(V1)
9D000874  C4600008   LWC1 F0, 8(V1)
9D000878  46000800   ADD.S F0, F1, F0
9D000A90  C5210004   LWC1 F1, 4(T1)
9D000A94  C5200008   LWC1 F0, 8(T1)
9D000A98  46000840   ADD.S F1, F1, F0
9D000AAC  C4C20004   LWC1 F2, 4(A2)
9D000AB0  C4C00008   LWC1 F0, 8(A2)
9D000AB4  46001000   ADD.S F0, F2, F0
9D000AF4  C5010004   LWC1 F1, 4(T0)
9D000AF8  C5000008   LWC1 F0, 8(T0)
9D000AFC  46000840   ADD.S F1, F1, F0
9D000B10  C4A20004   LWC1 F2, 4(A1)
9D000B14  C4A00008   LWC1 F0, 8(A1)
9D000B18  46001000   ADD.S F0, F2, F0
9D000FC8  C5410004   LWC1 F1, 4(T2)
9D000FCC  C5400008   LWC1 F0, 8(T2)
9D000FD0  46000840   ADD.S F1, F1, F0
9D000FE4  C4E20004   LWC1 F2, 4(A3)
9D000FE8  C4E00008   LWC1 F0, 8(A3)
9D000FEC  46001000   ADD.S F0, F2, F0
9D00102C  C5210004   LWC1 F1, 4(T1)
9D001030  C5200008   LWC1 F0, 8(T1)
9D001034  46000840   ADD.S F1, F1, F0
9D001048  C4C20004   LWC1 F2, 4(A2)
9D00104C  C4C00008   LWC1 F0, 8(A2)
9D001050  46001000   ADD.S F0, F2, F0
9D0011F8  C4810004   LWC1 F1, 4(A0)
9D0011FC  C4800008   LWC1 F0, 8(A0)
9D001200  46000880   ADD.S F2, F1, F0
9D001210  C4610004   LWC1 F1, 4(V1)
9D001214  C4600008   LWC1 F0, 8(V1)
9D001218  46000800   ADD.S F0, F1, F0
142:                 }
143:                 
144:                 static inline float GetNodeCost(Node n)
145:                 {
146:                     return NodeGetRecord(n)->cost;
9D000BAC  8E420010   LW V0, 16(S2)
9D000BB0  8FA50010   LW A1, 16(SP)
9D000BB4  70A33002   MUL A2, A1, V1
9D000BB8  00C22021   ADDU A0, A2, V0
9D001630  8E420010   LW V0, 16(S2)
9D001634  8FA40010   LW A0, 16(SP)
9D001638  70832802   MUL A1, A0, V1
9D00163C  00A21021   ADDU V0, A1, V0
9D001640  C4400008   LWC1 F0, 8(V0)
147:                 }
148:                 
149:                 static inline float GetNodeEstimatedCost(Node n)
150:                 {
151:                     return NodeGetRecord(n)->estimatedCost;
152:                 }
153:                 
154:                 static inline void SetNodeEstimatedCost(Node n, float estimatedCost)
155:                 {
156:                     NodeRecord *record = NodeGetRecord(n);
157:                     record->estimatedCost = estimatedCost;
9D000734  E4400004   SWC1 F0, 4(V0)
9D000E2C  E4400004   SWC1 F0, 4(V0)
158:                     record->hasEstimatedCost = 1;
9D000738  90430000   LBU V1, 0(V0)
9D00073C  24040001   ADDIU A0, ZERO, 1
9D000740  7C832104   INS V1, A0, 4, 1
9D000744  A0430000   SB V1, 0(V0)
9D000E30  90430000   LBU V1, 0(V0)
9D000E34  24040001   ADDIU A0, ZERO, 1
9D000E38  7C832104   INS V1, A0, 4, 1
9D000E3C  A0430000   SB V1, 0(V0)
9D000E40  278380E4   ADDIU V1, GP, -32540
9D000E44  8C620000   LW V0, 0(V1)
159:                 }
160:                 
161:                 static inline int NodeHasEstimatedCost(Node n)
162:                 {
163:                     return NodeGetRecord(n)->hasEstimatedCost;
9D000DB8  8C820000   LW V0, 0(A0)
164:                 }
165:                 
166:                 static inline void SetNodeIsGoal(Node n)
167:                 {
168:                     if (!NodeIsNull(n)) {
169:                         NodeGetRecord(n)->isGoal = 1;
9D0006CC  0B4001B5   J .LVL64, .LBB642
9D0006D0  AFA00018   SW ZERO, 24(SP)
9D001418  8E420010   LW V0, 16(S2)
9D00141C  8FA4001C   LW A0, 28(SP)
9D001420  70832802   MUL A1, A0, V1
9D001424  00A21821   ADDU V1, A1, V0
9D001428  90620000   LBU V0, 0(V1)
9D00142C  24040001   ADDIU A0, ZERO, 1
9D001430  7C821084   INS V0, A0, 2, 1
9D001434  A0620000   SB V0, 0(V1)
9D001438  0B4001B5   J .LVL64, .LBB642
9D00143C  AFB20018   SW S2, 24(SP)
9D001444  0B4001B5   J .LVL64, .LBB642
9D001448  AFA00018   SW ZERO, 24(SP)
9D0014B0  8E430010   LW V1, 16(S2)
9D0014B4  70442802   MUL A1, V0, A0
9D0014B8  00A31821   ADDU V1, A1, V1
9D0014BC  90620000   LBU V0, 0(V1)
9D0014C0  24040001   ADDIU A0, ZERO, 1
9D0014C4  7C821084   INS V0, A0, 2, 1
9D0014C8  0B4004B4   J .LVL231, .LBB963
9D0014CC  A0620000   SB V0, 0(V1)
9D001578  8E420010   LW V0, 16(S2)
9D00157C  8FA40010   LW A0, 16(SP)
9D001580  70832802   MUL A1, A0, V1
9D001584  00A21821   ADDU V1, A1, V0
9D001588  90620000   LBU V0, 0(V1)
9D00158C  24040001   ADDIU A0, ZERO, 1
9D001590  7C821084   INS V0, A0, 2, 1
9D001594  0B4004C1   J .LVL233, .LBB974, .LBB976
9D001598  A0620000   SB V0, 0(V1)
170:                     }
171:                 }
172:                 
173:                 static inline int NodeIsGoal(Node n)
174:                 {
175:                     return !NodeIsNull(n) && NodeGetRecord(n)->isGoal;
9D00153C  8E420010   LW V0, 16(S2)
9D001540  8FA40010   LW A0, 16(SP)
9D001544  70642802   MUL A1, V1, A0
9D001548  00A21021   ADDU V0, A1, V0
9D00154C  8C420000   LW V0, 0(V0)
9D001550  30420004   ANDI V0, V0, 4
9D0015A4  8E420010   LW V0, 16(S2)
9D0015A8  8FA40010   LW A0, 16(SP)
9D0015AC  70832802   MUL A1, A0, V1
9D0015B0  00A21021   ADDU V0, A1, V0
9D0015B4  8C420000   LW V0, 0(V0)
9D0015B8  30420004   ANDI V0, V0, 4
176:                 }
177:                 
178:                 static inline Node GetParentNode(Node n)
179:                 {
180:                     NodeRecord *record = NodeGetRecord(n);
181:                     if (record->hasParent) {
9D001398  8C430000   LW V1, 0(V0)
9D00139C  30630008   ANDI V1, V1, 8
9D0013A0  50600004   BEQL V1, ZERO, .LVL241, .LBB1004, .LBB997
9D0013A4  AFB40010   SW S4, 16(SP)
9D0015EC  8E820000   LW V0, 0(S4)
9D0015F0  30420008   ANDI V0, V0, 8
9D0015F4  1440FF4B   BNE V0, ZERO, .LVL234, .LBB981, .LBB982
9D0015F8  26310001   ADDIU S1, S1, 1
182:                         return NodeMake(n.nodes, record->parentIndex);
9D001324  8E940010   LW S4, 16(S4)
9D0013A8  8C420010   LW V0, 16(V0)
9D0013AC  0B4004EE   J .LVL242, .LBE997
9D0013B0  AFA20010   SW V0, 16(SP)
183:                     } else {
184:                         return NodeNull;
9D0013B4  02608021   ADDU S0, S3, ZERO
9D0015FC  0080A021   ADDU S4, A0, ZERO
9D001600  0B4004CA   J .LVL235, .LBE982, .LBB987
9D001604  00009821   ADDU S3, ZERO, ZERO
185:                     }
186:                 }
187:                 
188:                 static inline int NodeRankCompare(Node n1, Node n2)
189:                 {
190:                     const float rank1 = GetNodeRank(n1);
191:                     const float rank2 = GetNodeRank(n2);
192:                     if (rank1 < rank2) {
9D00087C  4600113C   C.LT.S 1, F2, F0
9D000880  45070283   BC1TL 1, 0x9D001290
9D000884  3C023FFF   LUI V0, 16383
9D00121C  4600163C   C.LT.S 6, F2, F0
9D001220  45190012   BC1T 6, .LVL226
9D001224  8F9780E0   LW S7, -32544(GP)
193:                         return -1;
194:                     } else if (rank1 > rank2) {
195:                         return 1;
196:                     } else {
197:                         return 0;
198:                     }
199:                 }
200:                 
201:                 static inline float GetPathCostHeuristic(Node a, Node b)
202:                 {
203:                     if (a.nodes->source->pathCostHeuristic && !NodeIsNull(a) && !NodeIsNull(b)) {
9D0006D4  8E430000   LW V1, 0(S2)
9D0006D8  8C620008   LW V0, 8(V1)
9D0006DC  1040000E   BEQ V0, ZERO, .LVL68, .LBB659, .LBB660, .LBB661
9D0006E0  44800000   MTC1 ZERO, F0
9D000DC8  8C620008   LW V0, 8(V1)
9D000DCC  1040000E   BEQ V0, ZERO, .LVL159
9D000DD0  44800000   MTC1 ZERO, F0
204:                         return a.nodes->source->pathCostHeuristic(GetNodeKey(a), GetNodeKey(b), a.nodes->context);
9D00148C  24840014   ADDIU A0, A0, 20
9D001490  24A50014   ADDIU A1, A1, 20
9D001494  0040F809   JALR V0
9D001498  8E460004   LW A2, 4(S2)
9D0014F4  24840014   ADDIU A0, A0, 20
9D0014F8  24A50014   ADDIU A1, A1, 20
9D0014FC  0040F809   JALR V0
9D001500  8CC60004   LW A2, 4(A2)
9D001504  0B400383   J 0x9D000E0C
9D001508  278480E4   ADDIU A0, GP, -32540
205:                     } else {
206:                         return 0;
9D000F88  00602021   ADDU A0, V1, ZERO
207:                     }
208:                 }
209:                 
210:                 static inline int NodeKeyCompare(Node node, void *nodeKey)
211:                 {
212:                     if (node.nodes->source->nodeComparator) {
9D000378  8E420000   LW V0, 0(S2)
9D000530  8E420000   LW V0, 0(S2)
9D000534  8C430010   LW V1, 16(V0)
9D000538  1060000C   BEQ V1, ZERO, .LVL48, .LBB616, .LBB617
9D00053C  7C86200A   LWX A0, A2(A0)
9D000C10  8E420000   LW V0, 0(S2)
9D000C14  8C430010   LW V1, 16(V0)
9D000C18  1060000C   BEQ V1, ZERO, .LVL137, .LBB796, .LBB797
9D000C1C  7C96200A   LWX A0, S6(A0)
213:                         return node.nodes->source->nodeComparator(GetNodeKey(node), nodeKey, node.nodes->context);
9D00039C  24840014   ADDIU A0, A0, 20
9D000554  24840014   ADDIU A0, A0, 20
9D000558  8FA5006C   LW A1, 108(SP)
9D00055C  0060F809   JALR V1
9D000560  8E460004   LW A2, 4(S2)
9D000564  0B400163   J .LVL50, .LBE611
9D000568  00000000   NOP
9D000C34  24840014   ADDIU A0, A0, 20
9D000C38  02E02821   ADDU A1, S7, ZERO
9D000C3C  0060F809   JALR V1
9D000C40  8E460004   LW A2, 4(S2)
9D000C44  0B40031B   J .LVL139, .LBE791
9D000C48  00000000   NOP
214:                     } else {
215:                         return memcmp(GetNodeKey(node), nodeKey, node.nodes->source->nodeSize);
9D0003C8  24840014   ADDIU A0, A0, 20
9D000580  24840014   ADDIU A0, A0, 20
9D000584  0F402C60   JAL .LFE5, memcmp
9D000588  8FA5006C   LW A1, 108(SP)
9D000C60  24840014   ADDIU A0, A0, 20
9D000C64  0F402C60   JAL .LFE5, memcmp
9D000C68  02E02821   ADDU A1, S7, ZERO
216:                     }
217:                 }
218:                 
219:                 static inline Node GetNode(VisitedNodes nodes, void *nodeKey)
220:                 {
221:                     if (!nodeKey) {
9D000500  8FA5006C   LW A1, 108(SP)
9D000504  50A003CE   BEQL A1, ZERO, .LVL253, .LBB1010
9D000508  2406FFFF   ADDIU A2, ZERO, -1
9D000BE8  12E00068   BEQ S7, ZERO, .LVL152, .LBB816
9D000BEC  2416FFFF   ADDIU S6, ZERO, -1
222:                         return NodeNull;
9D000D8C  00001021   ADDU V0, ZERO, ZERO
9D001440  AFA6001C   SW A2, 28(SP)
223:                     }
224:                 
225:                     // looks it up in the index, if it's not found it inserts a new record in the sorted index and the nodeRecords array and returns a reference to it
226:                     size_t first = 0;
9D000360  0000B821   ADDU S7, ZERO, ZERO
9D000420  0000B821   ADDU S7, ZERO, ZERO
227:                 
228:                     if (nodes->nodeRecordsCount > 0) {
9D000350  8E56000C   LW S6, 12(S2)
9D000354  12C00032   BEQ S6, ZERO, .LVL31, .LBB606
9D000358  0040F021   ADDU FP, V0, ZERO
9D00050C  8E56000C   LW S6, 12(S2)
9D000510  12C00031   BEQ S6, ZERO, .LVL55, .LBB634
9D000514  0000B821   ADDU S7, ZERO, ZERO
9D000BF0  8E54000C   LW S4, 12(S2)
9D000BF4  1280002F   BEQ S4, ZERO, .LVL144, .LBB815
9D000BF8  0000A821   ADDU S5, ZERO, ZERO
229:                         size_t last = nodes->nodeRecordsCount-1;
9D00035C  26D6FFFF   ADDIU S6, S6, -1
9D000518  26D6FFFF   ADDIU S6, S6, -1
9D000BFC  2694FFFF   ADDIU S4, S4, -1
230:                 
231:                         while (first <= last) {
9D0003F4  0B400104   J 0x9D000410
9D0003F8  02D7102B   SLTU V0, S6, S7
9D00040C  02D7102B   SLTU V0, S6, S7
9D000410  1040FFD5   BEQ V0, ZERO, 0x9D000368
9D000414  02D79821   ADDU S3, S6, S7
9D0005AC  0B400172   J 0x9D0005C8
9D0005B0  02D7102B   SLTU V0, S6, S7
9D0005C4  02D7102B   SLTU V0, S6, S7
9D0005C8  1040FFD5   BEQ V0, ZERO, 0x9D000520
9D0005CC  02D79821   ADDU S3, S6, S7
9D000C8C  0B400329   J 0x9D000CA4
9D000C90  0295102B   SLTU V0, S4, S5
9D000CA0  0295102B   SLTU V0, S4, S5
9D000CA4  1040FFD7   BEQ V0, ZERO, 0x9D000C04
9D000CA8  02959821   ADDU S3, S4, S5
232:                             const size_t mid = (first + last) / 2;
9D000364  02D79821   ADDU S3, S6, S7
9D000368  00139842   SRL S3, S3, 1
9D00051C  02D79821   ADDU S3, S6, S7
9D000520  00139842   SRL S3, S3, 1
9D000C00  02959821   ADDU S3, S4, S5
9D000C04  00139842   SRL S3, S3, 1
233:                             const int comp = NodeKeyCompare(NodeMake(nodes, nodes->nodeRecordsIndex[mid]), nodeKey);
9D00036C  00132880   SLL A1, S3, 2
9D000370  AFA50010   SW A1, 16(SP)
9D000374  8E440014   LW A0, 20(S2)
9D000524  00133080   SLL A2, S3, 2
9D000528  AFA60014   SW A2, 20(SP)
9D00052C  8E440014   LW A0, 20(S2)
9D000C08  0013B080   SLL S6, S3, 2
9D000C0C  8E440014   LW A0, 20(S2)
234:                 
235:                             if (comp < 0) {
9D0003D4  04410003   BGEZ V0, .LBB603, .LBB594, .LBB591
9D0003D8  00000000   NOP
9D00058C  04410003   BGEZ V0, .LBB631, .LBB621, .LBB619
9D000590  00000000   NOP
9D000C6C  04410003   BGEZ V0, .LBB812, .LBB801, .LBB799
9D000C70  00000000   NOP
236:                                 first = mid + 1;
9D0003DC  0B400103   J .LVL30, .LBB605, .LBB596
9D0003E0  26770001   ADDIU S7, S3, 1
9D000594  0B400171   J .LVL54, .LBB633, .LBB623
9D000598  26770001   ADDIU S7, S3, 1
9D000C74  0B400328   J .LBB814, .LBB803
9D000C78  26750001   ADDIU S5, S3, 1
237:                             } else if (comp > 0 && mid > 0) {
9D0003E4  58400005   BLEZL V0, .LBB604, .LBB595, .LBB592
9D0003E8  8E420014   LW V0, 20(S2)
9D0003EC  1260000D   BEQ S3, ZERO, .LVL32
9D0003F0  2676FFFF   ADDIU S6, S3, -1
9D00059C  58400005   BLEZL V0, .LBB632, .LBB622, .LBB620
9D0005A0  8E420014   LW V0, 20(S2)
9D0005A4  1260000C   BEQ S3, ZERO, .LVL55, .LBB634
9D0005A8  2676FFFF   ADDIU S6, S3, -1
9D000C7C  58400005   BLEZL V0, .LBB813, .LBB802, .LBB800
9D000C80  8E420014   LW V0, 20(S2)
9D000C84  1260000B   BEQ S3, ZERO, .LVL144, .LBB815
9D000C88  2674FFFF   ADDIU S4, S3, -1
238:                                 last = mid - 1;
239:                             } else if (comp > 0) {
240:                                 break;
241:                             } else {
242:                                 return NodeMake(nodes, nodes->nodeRecordsIndex[mid]);
9D0003FC  8FA60010   LW A2, 16(SP)
9D000400  7C46100A   LWX V0, A2(V0)
9D000404  0B400140   J .LVL40, .LBE606, .LBB607
9D000408  AFA20010   SW V0, 16(SP)
9D0005B4  8FA60014   LW A2, 20(SP)
9D0005B8  7C46100A   LWX V0, A2(V0)
9D0005BC  0B4001AD   J .LVL63, .LBE634, .LBB635, .LBB637
9D0005C0  AFA2001C   SW V0, 28(SP)
9D000C94  7C56B00A   LWX S6, S6(V0)
243:                             }
244:                         }
245:                     }
246:                 
247:                     if (nodes->nodeRecordsCount == nodes->nodeRecordsCapacity) {
9D000418  0B40010A   J 0x9D000428
9D00041C  8E42000C   LW V0, 12(S2)
9D000424  8E42000C   LW V0, 12(S2)
9D000428  8E430008   LW V1, 8(S2)
9D00042C  54430011   BNEL V0, V1, 0x9D000474
9D000430  8E42000C   LW V0, 12(S2)
9D0005D0  0B400177   J 0x9D0005DC
9D0005D4  8E42000C   LW V0, 12(S2)
9D0005D8  8E42000C   LW V0, 12(S2)
9D0005DC  8E430008   LW V1, 8(S2)
9D0005E0  54430011   BNEL V0, V1, 0x9D000628
9D0005E4  8E42000C   LW V0, 12(S2)
9D000CAC  0B40032E   J 0x9D000CB8
9D000CB0  8E42000C   LW V0, 12(S2)
9D000CB4  8E42000C   LW V0, 12(S2)
9D000CB8  8E430008   LW V1, 8(S2)
9D000CBC  54430011   BNEL V0, V1, 0x9D000D04
9D000CC0  8E56000C   LW S6, 12(S2)
248:                         nodes->nodeRecordsCapacity = 1 + (nodes->nodeRecordsCapacity * 2);
9D000434  00021040   SLL V0, V0, 1
9D000438  24420001   ADDIU V0, V0, 1
9D00043C  AE420008   SW V0, 8(S2)
9D0005E8  00021040   SLL V0, V0, 1
9D0005EC  24420001   ADDIU V0, V0, 1
9D0005F0  AE420008   SW V0, 8(S2)
9D000CC4  00021040   SLL V0, V0, 1
9D000CC8  24420001   ADDIU V0, V0, 1
9D000CCC  AE420008   SW V0, 8(S2)
249:                         nodes->nodeRecords = realloc(nodes->nodeRecords, nodes->nodeRecordsCapacity * (sizeof(NodeRecord) + nodes->source->nodeSize));
9D000440  8E430000   LW V1, 0(S2)
9D000444  8C650000   LW A1, 0(V1)
9D000448  24A50014   ADDIU A1, A1, 20
9D00044C  8E440010   LW A0, 16(S2)
9D000450  0F40250B   JAL realloc
9D000454  70452802   MUL A1, V0, A1
9D000458  AE420010   SW V0, 16(S2)
9D0005F4  8E430000   LW V1, 0(S2)
9D0005F8  8C650000   LW A1, 0(V1)
9D0005FC  24A50014   ADDIU A1, A1, 20
9D000600  8E440010   LW A0, 16(S2)
9D000604  0F40250B   JAL realloc
9D000608  70452802   MUL A1, V0, A1
9D00060C  AE420010   SW V0, 16(S2)
9D000CD0  8E430000   LW V1, 0(S2)
9D000CD4  8C650000   LW A1, 0(V1)
9D000CD8  24A50014   ADDIU A1, A1, 20
9D000CDC  8E440010   LW A0, 16(S2)
9D000CE0  0F40250B   JAL realloc
9D000CE4  70452802   MUL A1, V0, A1
9D000CE8  AE420010   SW V0, 16(S2)
250:                         nodes->nodeRecordsIndex = realloc(nodes->nodeRecordsIndex, nodes->nodeRecordsCapacity * sizeof(size_t));
9D00045C  8E450008   LW A1, 8(S2)
9D000460  8E440014   LW A0, 20(S2)
9D000464  0F40250B   JAL realloc
9D000468  00052880   SLL A1, A1, 2
9D00046C  AE420014   SW V0, 20(S2)
9D000610  8E450008   LW A1, 8(S2)
9D000614  8E440014   LW A0, 20(S2)
9D000618  0F40250B   JAL realloc
9D00061C  00052880   SLL A1, A1, 2
9D000620  AE420014   SW V0, 20(S2)
9D000CEC  8E450008   LW A1, 8(S2)
9D000CF0  8E440014   LW A0, 20(S2)
9D000CF4  0F40250B   JAL realloc
9D000CF8  00052880   SLL A1, A1, 2
9D000CFC  AE420014   SW V0, 20(S2)
251:                     }
252:                 
253:                     Node node = NodeMake(nodes, nodes->nodeRecordsCount);
9D000470  8E42000C   LW V0, 12(S2)
9D000474  AFA20010   SW V0, 16(SP)
9D000624  8E42000C   LW V0, 12(S2)
9D000628  AFA2001C   SW V0, 28(SP)
9D000D00  8E56000C   LW S6, 12(S2)
254:                     nodes->nodeRecordsCount++;
9D000478  24420001   ADDIU V0, V0, 1
9D00047C  AE42000C   SW V0, 12(S2)
9D00062C  24420001   ADDIU V0, V0, 1
9D000630  AE42000C   SW V0, 12(S2)
9D000D04  26C20001   ADDIU V0, S6, 1
9D000D08  AE42000C   SW V0, 12(S2)
255:                 
256:                     memmove(&nodes->nodeRecordsIndex[first+1], &nodes->nodeRecordsIndex[first], (nodes->nodeRecordsCapacity - first - 1) * sizeof(size_t));
9D000480  8E450014   LW A1, 20(S2)
9D000484  26E40001   ADDIU A0, S7, 1
9D000488  00042080   SLL A0, A0, 2
9D00048C  2493FFFC   ADDIU S3, A0, -4
9D000490  8E460008   LW A2, 8(S2)
9D000494  3C023FFF   LUI V0, 16383
9D000498  3442FFFF   ORI V0, V0, -1
9D00049C  00C23021   ADDU A2, A2, V0
9D0004A0  00D73023   SUBU A2, A2, S7
9D0004A4  00A42021   ADDU A0, A1, A0
9D0004A8  00B32821   ADDU A1, A1, S3
9D0004AC  0F402ED4   JAL memmove
9D0004B0  00063080   SLL A2, A2, 2
9D000634  8E450014   LW A1, 20(S2)
9D000638  26E40001   ADDIU A0, S7, 1
9D00063C  00042080   SLL A0, A0, 2
9D000640  2493FFFC   ADDIU S3, A0, -4
9D000644  8E460008   LW A2, 8(S2)
9D000648  3C023FFF   LUI V0, 16383
9D00064C  3442FFFF   ORI V0, V0, -1
9D000650  00C23021   ADDU A2, A2, V0
9D000654  00D73023   SUBU A2, A2, S7
9D000658  00A42021   ADDU A0, A1, A0
9D00065C  00B32821   ADDU A1, A1, S3
9D000660  0F402ED4   JAL memmove
9D000664  00063080   SLL A2, A2, 2
9D000D0C  8E450014   LW A1, 20(S2)
9D000D10  26A40001   ADDIU A0, S5, 1
9D000D14  00042080   SLL A0, A0, 2
9D000D18  2493FFFC   ADDIU S3, A0, -4
9D000D1C  8E420008   LW V0, 8(S2)
9D000D20  8FA30014   LW V1, 20(SP)
9D000D24  00431021   ADDU V0, V0, V1
9D000D28  00553023   SUBU A2, V0, S5
9D000D2C  00A42021   ADDU A0, A1, A0
9D000D30  00B32821   ADDU A1, A1, S3
9D000D34  0F402ED4   JAL memmove
9D000D38  00063080   SLL A2, A2, 2
9D00128C  3C023FFF   LUI V0, 16383
9D001290  3442FFFF   ORI V0, V0, -1
9D001294  AFA20014   SW V0, 20(SP)
257:                     nodes->nodeRecordsIndex[first] = node.index;
9D0004B4  8E420014   LW V0, 20(S2)
9D0004B8  00539821   ADDU S3, V0, S3
9D0004BC  8FA30010   LW V1, 16(SP)
9D0004C0  AE630000   SW V1, 0(S3)
9D000668  8E420014   LW V0, 20(S2)
9D00066C  00539821   ADDU S3, V0, S3
9D000670  8FA3001C   LW V1, 28(SP)
9D000674  AE630000   SW V1, 0(S3)
9D000D3C  8E420014   LW V0, 20(S2)
9D000D40  00539821   ADDU S3, V0, S3
9D000D44  AE760000   SW S6, 0(S3)
258:                 
259:                     NodeRecord *record = NodeGetRecord(node);
260:                     memset(record, 0, sizeof(NodeRecord));
9D0004DC  02602021   ADDU A0, S3, ZERO
9D0004E0  00002821   ADDU A1, ZERO, ZERO
9D0004E4  0F402AAC   JAL .LFE327, memset
9D0004E8  24060014   ADDIU A2, ZERO, 20
9D000690  02602021   ADDU A0, S3, ZERO
9D000694  00002821   ADDU A1, ZERO, ZERO
9D000698  0F402AAC   JAL .LFE327, memset
9D00069C  24060014   ADDIU A2, ZERO, 20
9D000D60  02602021   ADDU A0, S3, ZERO
9D000D64  00002821   ADDU A1, ZERO, ZERO
9D000D68  0F402AAC   JAL .LFE327, memset
9D000D6C  24060014   ADDIU A2, ZERO, 20
261:                     memcpy(record->nodeKey, nodeKey, nodes->source->nodeSize);
9D0004EC  8E420000   LW V0, 0(S2)
9D0004F0  26640014   ADDIU A0, S3, 20
9D0004F4  8FA50068   LW A1, 104(SP)
9D0004F8  0F40245E   JAL .LFE0, memcpy
9D0004FC  8C460000   LW A2, 0(V0)
9D0006A0  8E420000   LW V0, 0(S2)
9D0006A4  26640014   ADDIU A0, S3, 20
9D0006A8  8FA5006C   LW A1, 108(SP)
9D0006AC  0F40245E   JAL .LFE0, memcpy
9D0006B0  8C460000   LW A2, 0(V0)
9D000D70  8E420000   LW V0, 0(S2)
9D000D74  26640014   ADDIU A0, S3, 20
9D000D78  02E02821   ADDU A1, S7, ZERO
9D000D7C  0F40245E   JAL .LFE0, memcpy
9D000D80  8C460000   LW A2, 0(V0)
262:                 
263:                     return node;
9D000D84  0B400364   J .LVL153, .LBE816
9D000D88  02401021   ADDU V0, S2, ZERO
264:                 }
265:                 
266:                 static inline void SwapOpenSetNodesAtIndexes(VisitedNodes nodes, size_t index1, size_t index2)
267:                 {
268:                     if (index1 != index2) {
9D000888  1262000D   BEQ S3, V0, .LVL87, .LBE684, .LBE682, .LBE685
9D00088C  00000000   NOP
9D00097C  10830035   BEQ A0, V1, .LVL112, .LBE767, .LBB770, .LBB761, .LBB754
9D000980  00031080   SLL V0, V1, 2
9D000EB4  10A40035   BEQ A1, A0, .LVL185, .LBE904, .LBB905, .LBB898, .LBB891
9D000EB8  00041880   SLL V1, A0, 2
9D001228  1282000D   BEQ S4, V0, .LVL224, .LBE940, .LBE938, .LBE941
9D00122C  00000000   NOP
269:                         NodeRecord *record1 = NodeGetRecord(NodeMake(nodes, nodes->openNodes[index1]));
9D000984  8E460020   LW A2, 32(S2)
9D0009F0  8E460020   LW A2, 32(S2)
9D0009F4  00022080   SLL A0, V0, 2
9D000EBC  8C470020   LW A3, 32(V0)
9D000F28  8C470020   LW A3, 32(V0)
9D000F2C  00032880   SLL A1, V1, 2
270:                         NodeRecord *record2 = NodeGetRecord(NodeMake(nodes, nodes->openNodes[index2]));
9D0009A4  00042080   SLL A0, A0, 2
9D000EDC  00052880   SLL A1, A1, 2
271:                 
272:                         const size_t tempOpenIndex = record1->openIndex;
9D000890  8C86000C   LW A2, 12(A0)
9D0009B4  8CE6000C   LW A2, 12(A3)
9D000A20  8CE6000C   LW A2, 12(A3)
9D000EEC  8D07000C   LW A3, 12(T0)
9D000F58  8D07000C   LW A3, 12(T0)
9D001230  8C86000C   LW A2, 12(A0)
273:                         record1->openIndex = record2->openIndex;
9D000894  8C67000C   LW A3, 12(V1)
9D000898  AC87000C   SW A3, 12(A0)
9D0009B8  8CA8000C   LW T0, 12(A1)
9D0009BC  ACE8000C   SW T0, 12(A3)
9D000A24  8CA8000C   LW T0, 12(A1)
9D000A28  ACE8000C   SW T0, 12(A3)
9D000EF0  8CC9000C   LW T1, 12(A2)
9D000EF4  AD09000C   SW T1, 12(T0)
9D000F5C  8CC9000C   LW T1, 12(A2)
9D000F60  AD09000C   SW T1, 12(T0)
9D001234  8C67000C   LW A3, 12(V1)
9D001238  AC87000C   SW A3, 12(A0)
274:                         record2->openIndex = tempOpenIndex;
9D00089C  AC66000C   SW A2, 12(V1)
9D0009C0  ACA6000C   SW A2, 12(A1)
9D000A2C  ACA6000C   SW A2, 12(A1)
9D000EF8  ACC7000C   SW A3, 12(A2)
9D000F64  ACC7000C   SW A3, 12(A2)
9D00123C  AC66000C   SW A2, 12(V1)
275:                 
276:                         const size_t tempNodeIndex = nodes->openNodes[index1];
9D0008A0  8E430020   LW V1, 32(S2)
9D0008A4  00684021   ADDU T0, V1, T0
9D0008A8  8D040000   LW A0, 0(T0)
9D0009C4  8E450020   LW A1, 32(S2)
9D0009C8  00A21021   ADDU V0, A1, V0
9D0009CC  8C460000   LW A2, 0(V0)
9D000A30  8E450020   LW A1, 32(S2)
9D000A34  00A42021   ADDU A0, A1, A0
9D000A38  8C860000   LW A2, 0(A0)
9D000EFC  8C460020   LW A2, 32(V0)
9D000F00  00C31821   ADDU V1, A2, V1
9D000F04  8C670000   LW A3, 0(V1)
9D000F68  8C460020   LW A2, 32(V0)
9D000F6C  00C52821   ADDU A1, A2, A1
9D000F70  8CA70000   LW A3, 0(A1)
9D001240  8E630020   LW V1, 32(S3)
9D001244  00684021   ADDU T0, V1, T0
9D001248  8D040000   LW A0, 0(T0)
277:                         nodes->openNodes[index1] = nodes->openNodes[index2];
9D0008AC  7C65180A   LWX V1, A1(V1)
9D0008B0  AD030000   SW V1, 0(T0)
9D0009D0  7CA4280A   LWX A1, A0(A1)
9D0009D4  AC450000   SW A1, 0(V0)
9D000A3C  7CA3280A   LWX A1, V1(A1)
9D000A40  AC850000   SW A1, 0(A0)
9D000F08  7CC5300A   LWX A2, A1(A2)
9D000F0C  AC660000   SW A2, 0(V1)
9D000F74  7CC4300A   LWX A2, A0(A2)
9D000F78  ACA60000   SW A2, 0(A1)
9D00124C  7C65180A   LWX V1, A1(V1)
9D001250  AD030000   SW V1, 0(T0)
278:                         nodes->openNodes[index2] = tempNodeIndex;
9D0008B4  8E430020   LW V1, 32(S2)
9D0008B8  00652821   ADDU A1, V1, A1
9D0008BC  ACA40000   SW A0, 0(A1)
9D0009D8  8E420020   LW V0, 32(S2)
9D0009DC  00442021   ADDU A0, V0, A0
9D0009E0  0B400295   J .LVL112, .LBE767, .LBB770, .LBB761, .LBB754
9D0009E4  AC860000   SW A2, 0(A0)
9D000A44  8E440020   LW A0, 32(S2)
9D000A48  00831821   ADDU V1, A0, V1
9D000A4C  AC660000   SW A2, 0(V1)
9D000F10  8C430020   LW V1, 32(V0)
9D000F14  00652821   ADDU A1, V1, A1
9D000F18  0B4003E3   J .LVL185, .LBE904, .LBB905, .LBB898, .LBB891
9D000F1C  ACA70000   SW A3, 0(A1)
9D000F7C  8C450020   LW A1, 32(V0)
9D000F80  00A42021   ADDU A0, A1, A0
9D000F84  AC870000   SW A3, 0(A0)
9D001254  8E630020   LW V1, 32(S3)
9D001258  00652821   ADDU A1, V1, A1
9D00125C  ACA40000   SW A0, 0(A1)
279:                     }
280:                 }
281:                 
282:                 static inline void DidRemoveFromOpenSetAtIndex(VisitedNodes nodes, size_t index)
283:                 {
284:                     size_t smallestIndex = index;
285:                 
286:                     do {
287:                         if (smallestIndex != index) {
9D0009E8  10620019   BEQ V1, V0, .LVL111, .LBE719, .LBE718, .LBE717, .LBE760, .LBE766, .LBB767
9D0009EC  00031880   SLL V1, V1, 2
9D000F20  10830019   BEQ A0, V1, .LVL184, .LBE856, .LBE855, .LBE854, .LBE897, .LBE903, .LBB904
9D000F24  00042080   SLL A0, A0, 2
288:                             SwapOpenSetNodesAtIndexes(nodes, smallestIndex, index);
289:                             index = smallestIndex;
290:                         }
291:                 
292:                         const size_t leftIndex = (2 * index) + 1;
9D000A54  00032040   SLL A0, V1, 1
9D000A58  24820001   ADDIU V0, A0, 1
9D000F8C  00042840   SLL A1, A0, 1
9D000F90  24A30001   ADDIU V1, A1, 1
293:                         const size_t rightIndex = (2 * index) + 2;
294:                 
295:                         if (leftIndex < nodes->openNodesCount && NodeRankCompare(NodeMake(nodes, nodes->openNodes[leftIndex]), NodeMake(nodes, nodes->openNodes[smallestIndex])) < 0) {
9D000A5C  8E45001C   LW A1, 28(S2)
9D000A60  0045302B   SLTU A2, V0, A1
9D000A64  10C00017   BEQ A2, ZERO, .LVL118, .LBB771, .LBB762, .LBB755
9D000A68  24840002   ADDIU A0, A0, 2
9D000A6C  8E470020   LW A3, 32(S2)
9D000A80  00024880   SLL T1, V0, 2
9D000A9C  00034880   SLL T1, V1, 2
9D000AB8  46000E3C   C.LT.S 6, F1, F0
9D000ABC  0B4002B2   J .LVL119
9D000AC0  00781001   MOVF V0, V1, 6
9D000AC4  00601021   ADDU V0, V1, ZERO
9D000F94  8C46001C   LW A2, 28(V0)
9D000F98  0066382B   SLTU A3, V1, A2
9D000F9C  10E00017   BEQ A3, ZERO, .LVL191, .LBB906, .LBB899, .LBB892
9D000FA0  24A50002   ADDIU A1, A1, 2
9D000FA4  8C480020   LW T0, 32(V0)
9D000FB8  00035080   SLL T2, V1, 2
9D000FD4  00045080   SLL T2, A0, 2
9D000FF0  4600083C   C.LT.S F1, F0
9D000FF4  0B400400   J .LVL192
9D000FF8  00801801   MOVF V1, A0, 0
9D000FFC  00801821   ADDU V1, A0, ZERO
296:                             smallestIndex = leftIndex;
297:                         }
298:                 
299:                         if (rightIndex < nodes->openNodesCount && NodeRankCompare(NodeMake(nodes, nodes->openNodes[rightIndex]), NodeMake(nodes, nodes->openNodes[smallestIndex])) < 0) {
9D000AC8  0085282B   SLTU A1, A0, A1
9D000ACC  10A00015   BEQ A1, ZERO, .LVL123, .LBE755
9D000AD0  00044080   SLL T0, A0, 2
9D000AD4  8E460020   LW A2, 32(S2)
9D000B00  00024080   SLL T0, V0, 2
9D001000  00A6302B   SLTU A2, A1, A2
9D001004  10C00015   BEQ A2, ZERO, .LVL196, .LBE892
9D001008  00054880   SLL T1, A1, 2
9D00100C  8C470020   LW A3, 32(V0)
9D001038  00034880   SLL T1, V1, 2
300:                             smallestIndex = rightIndex;
9D000B1C  46000F3C   C.LT.S 7, F1, F0
9D000B20  009D1001   MOVT V0, A0, 7
9D001054  4600093C   C.LT.S 1, F1, F0
9D001058  00A51801   MOVT V1, A1, 1
301:                         }
302:                     } while (smallestIndex != index);
9D000B24  1462FFB0   BNE V1, V0, .LVL103, .LBB766, .LBB760, .LBB715, .LBB717
9D000B28  00000000   NOP
9D00105C  1483FFB0   BNE A0, V1, .LVL176, .LBB903, .LBB897, .LBB852, .LBB854
9D001060  00000000   NOP
9D001064  278480E4   ADDIU A0, GP, -32540
9D001068  8C830000   LW V1, 0(A0)
303:                 }
304:                 
305:                 static inline void RemoveNodeFromOpenSet(Node n)
306:                 {
307:                     NodeRecord *record = NodeGetRecord(n);
308:                 
309:                     if (record->isOpen) {
9D000950  8C430000   LW V1, 0(V0)
9D000954  30630002   ANDI V1, V1, 2
9D000958  50600075   BEQL V1, ZERO, 0x9D000B30
9D00095C  8E420000   LW V0, 0(S2)
9D000E88  8C640000   LW A0, 0(V1)
9D000E8C  30840002   ANDI A0, A0, 2
9D000E90  10800075   BEQ A0, ZERO, 0x9D001068
9D000E94  278480E4   ADDIU A0, GP, -32540
310:                         record->isOpen = 0;
9D000960  90430000   LBU V1, 0(V0)
9D000964  7C030844   INS V1, ZERO, 1, 1
9D000968  A0430000   SB V1, 0(V0)
9D000E98  90640000   LBU A0, 0(V1)
9D000E9C  7C040844   INS A0, ZERO, 1, 1
9D000EA0  A0640000   SB A0, 0(V1)
311:                         n.nodes->openNodesCount--;
9D00096C  8E44001C   LW A0, 28(S2)
9D000970  2484FFFF   ADDIU A0, A0, -1
9D000974  AE44001C   SW A0, 28(S2)
9D000EA4  8C45001C   LW A1, 28(V0)
9D000EA8  24A5FFFF   ADDIU A1, A1, -1
9D000EAC  AC45001C   SW A1, 28(V0)
312:                 
313:                         const size_t index = record->openIndex;
9D000978  8C43000C   LW V1, 12(V0)
9D000EB0  8C64000C   LW A0, 12(V1)
314:                         SwapOpenSetNodesAtIndexes(n.nodes, index, n.nodes->openNodesCount);
315:                         DidRemoveFromOpenSetAtIndex(n.nodes, index);
316:                     }
317:                 }
318:                 
319:                 static inline void DidInsertIntoOpenSetAtIndex(VisitedNodes nodes, size_t index)
320:                 {
321:                     while (index > 0) {
9D0007D4  126002AD   BEQ S3, ZERO, .LVL227, .LBB953
9D0007D8  AEC00008   SW ZERO, 8(S6)
9D0008C0  10400272   BEQ V0, ZERO, .LVL227, .LBB953
9D0008C4  00409821   ADDU S3, V0, ZERO
9D00117C  1280003A   BEQ S4, ZERO, .LVL225, .LBE945, .LBE952
9D001180  E6B50008   SWC1 F21, 8(S5)
9D001260  1440FFC9   BNE V0, ZERO, .LVL211
9D001264  0040A021   ADDU S4, V0, ZERO
322:                         const size_t parentIndex = floorf((index-1) / 2);
9D0007DC  3C029D01   LUI V0, -25343
9D0007E0  C454CC84   LWC1 F20, -13180(V0)
9D0007E4  3C168000   LUI S6, -32768
9D0007E8  2662FFFF   ADDIU V0, S3, -1
9D0007EC  0002A042   SRL S4, V0, 1
9D0007F0  0000A821   ADDU S5, ZERO, ZERO
9D0007F4  44940000   MTC1 S4, F0
9D0007F8  44F50000   MTHC1 S5, F0
9D0007FC  46A00320   CVT.S.L F12, F0
9D00080C  4600A03E   C.LE.S F20, F0
9D000810  45030004   BC1TL .LBB689, .LBB687, .LBB685
9D000814  46140001   SUB.S F0, F0, F20
9D000818  4600000D   TRUNC.W.S F0, F0
9D00081C  0B40020C   J .LVL76
9D000820  44020000   MFC1 V0, F0
9D000824  4600000D   TRUNC.W.S F0, F0
9D000828  44020000   MFC1 V0, F0
9D00082C  00561025   OR V0, V0, S6
9D0008C8  0B4001FB   J 0x9D0007EC
9D0008CC  2662FFFF   ADDIU V0, S3, -1
9D001184  3C158000   LUI S5, -32768
9D001188  2682FFFF   ADDIU V0, S4, -1
9D00118C  00028042   SRL S0, V0, 1
9D001190  00008821   ADDU S1, ZERO, ZERO
9D001194  44900000   MTC1 S0, F0
9D001198  44F10000   MTHC1 S1, F0
9D00119C  46A00320   CVT.S.L F12, F0
9D0011AC  4600A53E   C.LE.S 5, F20, F0
9D0011B0  45170004   BC1TL 5, .LBB952, .LBB945, .LBB941
9D0011B4  46140001   SUB.S F0, F0, F20
9D0011B8  4600000D   TRUNC.W.S F0, F0
9D0011BC  0B400474   J .LVL213
9D0011C0  44020000   MFC1 V0, F0
9D0011C4  4600000D   TRUNC.W.S F0, F0
9D0011C8  44020000   MFC1 V0, F0
9D0011CC  00551025   OR V0, V0, S5
9D001298  3C029D01   LUI V0, -25343
9D00129C  C454CC84   LWC1 F20, -13180(V0)
323:                 
324:                         if (NodeRankCompare(NodeMake(nodes, nodes->openNodes[parentIndex]), NodeMake(nodes, nodes->openNodes[index])) < 0) {
9D000830  8E470020   LW A3, 32(S2)
9D000834  00024080   SLL T0, V0, 2
9D000838  00132880   SLL A1, S3, 2
9D0011D0  8E670020   LW A3, 32(S3)
9D0011D4  00024080   SLL T0, V0, 2
9D0011D8  00142880   SLL A1, S4, 2
325:                             break;
326:                         } else {
327:                             SwapOpenSetNodesAtIndexes(nodes, parentIndex, index);
328:                             index = parentIndex;
329:                         }
330:                     }
331:                 }
332:                 
333:                 static inline void AddNodeToOpenSet(Node n, float cost, Node parent)
334:                 {
335:                     NodeRecord *record = NodeGetRecord(n);
336:                 
337:                     if (!NodeIsNull(parent)) {
338:                         record->hasParent = 1;
9D00150C  92A20000   LBU V0, 0(S5)
9D001510  24090001   ADDIU T1, ZERO, 1
9D001514  7D2218C4   INS V0, T1, 3, 1
9D001518  A2A20000   SB V0, 0(S5)
339:                         record->parentIndex = parent.index;
9D00151C  8FAA0010   LW T2, 16(SP)
9D001520  0B400447   J .LBB951
9D001524  AEAA0010   SW T2, 16(S5)
340:                     } else {
341:                         record->hasParent = 0;
9D000764  92C20000   LBU V0, 0(S6)
9D000768  7C0218C4   INS V0, ZERO, 3, 1
9D00076C  A2C20000   SB V0, 0(S6)
9D001114  0B40054A   J .LVL265
9D001118  7C0218C4   INS V0, ZERO, 3, 1
9D001528  0B400447   J .LBB951
9D00152C  A2A20000   SB V0, 0(S5)
342:                     }
343:                 
344:                     if (n.nodes->openNodesCount == n.nodes->openNodesCapacity) {
9D000770  8E42001C   LW V0, 28(S2)
9D000774  8E430018   LW V1, 24(S2)
9D000778  54430009   BNEL V0, V1, .LVL72
9D00077C  8E53001C   LW S3, 28(S2)
9D00111C  8E62001C   LW V0, 28(S3)
9D001120  8E630018   LW V1, 24(S3)
9D001124  54430009   BNEL V0, V1, .LVL209
9D001128  8E74001C   LW S4, 28(S3)
345:                         n.nodes->openNodesCapacity = 1 + (n.nodes->openNodesCapacity * 2);
9D000780  00021040   SLL V0, V0, 1
9D000784  24450001   ADDIU A1, V0, 1
9D000788  AE450018   SW A1, 24(S2)
9D00112C  00021040   SLL V0, V0, 1
9D001130  24450001   ADDIU A1, V0, 1
9D001134  AE650018   SW A1, 24(S3)
346:                         n.nodes->openNodes = realloc(n.nodes->openNodes, n.nodes->openNodesCapacity * sizeof(size_t));
9D00078C  8E440020   LW A0, 32(S2)
9D000790  0F40250B   JAL realloc
9D000794  00052880   SLL A1, A1, 2
9D000798  AE420020   SW V0, 32(S2)
9D001138  8E640020   LW A0, 32(S3)
9D00113C  0F40250B   JAL realloc
9D001140  00052880   SLL A1, A1, 2
9D001144  AE620020   SW V0, 32(S3)
347:                     }
348:                 
349:                     const size_t openIndex = n.nodes->openNodesCount;
9D00079C  8E53001C   LW S3, 28(S2)
9D001148  8E74001C   LW S4, 28(S3)
350:                     n.nodes->openNodes[openIndex] = n.index;
9D0007A0  8E430020   LW V1, 32(S2)
9D0007A4  00131080   SLL V0, S3, 2
9D0007A8  00621021   ADDU V0, V1, V0
9D0007AC  8FA50010   LW A1, 16(SP)
9D0007B0  AC450000   SW A1, 0(V0)
9D00114C  8E630020   LW V1, 32(S3)
9D001150  00141080   SLL V0, S4, 2
9D001154  00621021   ADDU V0, V1, V0
9D001158  AC560000   SW S6, 0(V0)
351:                     n.nodes->openNodesCount++;
9D0007B4  8E42001C   LW V0, 28(S2)
9D0007B8  24420001   ADDIU V0, V0, 1
9D0007BC  AE42001C   SW V0, 28(S2)
9D00115C  8E62001C   LW V0, 28(S3)
9D001160  24420001   ADDIU V0, V0, 1
9D001164  AE62001C   SW V0, 28(S3)
352:                 
353:                     record->openIndex = openIndex;
9D0007C0  AED3000C   SW S3, 12(S6)
9D001168  AEB4000C   SW S4, 12(S5)
354:                     record->isOpen = 1;
9D0007C4  92C20000   LBU V0, 0(S6)
9D0007C8  24030001   ADDIU V1, ZERO, 1
9D0007CC  7C620844   INS V0, V1, 1, 1
9D0007D0  A2C20000   SB V0, 0(S6)
9D00116C  92A20000   LBU V0, 0(S5)
9D001170  24060001   ADDIU A2, ZERO, 1
9D001174  7CC20844   INS V0, A2, 1, 1
9D001178  A2A20000   SB V0, 0(S5)
355:                     record->cost = cost;
356:                 
357:                     DidInsertIntoOpenSetAtIndex(n.nodes, openIndex);
358:                 }
359:                 
360:                 static inline int HasOpenNode(VisitedNodes nodes)
361:                 {
362:                     return nodes->openNodesCount > 0;
363:                 }
364:                 
365:                 static inline Node GetOpenNode(VisitedNodes nodes)
366:                 {
367:                     return NodeMake(nodes, nodes->openNodes[0]);
9D000A50  00401821   ADDU V1, V0, ZERO
9D0012AC  8E420020   LW V0, 32(S2)
9D0012B0  8C420000   LW V0, 0(V0)
368:                 }
369:                 
370:                 static inline ASNeighborList NeighborListCreate(const ASPathNodeSource *source)
371:                 {
372:                     ASNeighborList list = calloc(1, sizeof(struct __ASNeighborList));
9D00033C  24040001   ADDIU A0, ZERO, 1
373:                     list->source = source;
9D000348  8FA40060   LW A0, 96(SP)
374:                     return list;
375:                 }
376:                 
377:                 static inline void NeighborListDestroy(ASNeighborList list)
378:                 {
379:                     free(list->costs);
9D0013C0  0F4031CD   JAL .LFB1, free
9D0013C4  8FC4000C   LW A0, 12(FP)
380:                     free(list->nodeKeys);
9D0013C8  0F4031CD   JAL .LFB1, free
9D0013CC  8FC40010   LW A0, 16(FP)
381:                     free(list);
9D0013D0  0F4031CD   JAL .LFB1, free
9D0013D4  03C02021   ADDU A0, FP, ZERO
382:                 }
383:                 
384:                 static inline float NeighborListGetEdgeCost(ASNeighborList list, size_t index)
385:                 {
386:                     return list->costs[index];
9D000BBC  8FC3000C   LW V1, 12(FP)
9D000BC0  00171080   SLL V0, S7, 2
387:                 }
388:                 
389:                 static void *NeighborListGetNodeKey(ASNeighborList list, size_t index)
390:                 {
391:                     return list->nodeKeys + (index * list->source->nodeSize);
9D000BD4  8FC20000   LW V0, 0(FP)
9D000BD8  8C430000   LW V1, 0(V0)
9D000BDC  8FC20010   LW V0, 16(FP)
9D000BE0  72E32002   MUL A0, S7, V1
9D000BE4  0082B821   ADDU S7, A0, V0
392:                 }
393:                 
394:                 /********************************************/
395:                 
396:                 void ASNeighborListAdd(ASNeighborList list, void *node, float edgeCost)
397:                 {
9D00A88C  27BDFFD0   ADDIU SP, SP, -48
9D00A890  AFBF001C   SW RA, 28(SP)
9D00A894  AFB10018   SW S1, 24(SP)
9D00A898  AFB00014   SW S0, 20(SP)
9D00A89C  F7B40020   SDC1 F20, 32(SP)
9D00A8A0  00808021   ADDU S0, A0, ZERO
9D00A8A4  00A08821   ADDU S1, A1, ZERO
398:                     if (list->count == list->capacity) {
9D00A8A8  8C820008   LW V0, 8(A0)
9D00A8AC  8C830004   LW V1, 4(A0)
9D00A8B0  1443000F   BNE V0, V1, 0x9D00A8F0
9D00A8B4  4486A000   MTC1 A2, F20
399:                         list->capacity = 1 + (list->capacity * 2);
9D00A8B8  00021040   SLL V0, V0, 1
9D00A8BC  24450001   ADDIU A1, V0, 1
9D00A8C0  AC850004   SW A1, 4(A0)
400:                         list->costs = realloc(list->costs, sizeof(float) * list->capacity);
9D00A8C4  8C84000C   LW A0, 12(A0)
9D00A8C8  0F40250B   JAL realloc
9D00A8CC  00052880   SLL A1, A1, 2
9D00A8D0  AE02000C   SW V0, 12(S0)
401:                         list->nodeKeys = realloc(list->nodeKeys, list->source->nodeSize * list->capacity);
9D00A8D4  8E020000   LW V0, 0(S0)
9D00A8D8  8E050004   LW A1, 4(S0)
9D00A8DC  8C420000   LW V0, 0(V0)
9D00A8E0  8E040010   LW A0, 16(S0)
9D00A8E4  0F40250B   JAL realloc
9D00A8E8  70A22802   MUL A1, A1, V0
9D00A8EC  AE020010   SW V0, 16(S0)
402:                     }
403:                     list->costs[list->count] = edgeCost;
9D00A8F0  8E020008   LW V0, 8(S0)
9D00A8F4  8E03000C   LW V1, 12(S0)
9D00A8F8  00021080   SLL V0, V0, 2
9D00A8FC  4C43A008   SWXC1 F20, 3(V0)
404:                     memcpy(list->nodeKeys + (list->count * list->source->nodeSize), node, list->source->nodeSize);
9D00A900  8E020000   LW V0, 0(S0)
9D00A904  8C460000   LW A2, 0(V0)
9D00A908  8E040008   LW A0, 8(S0)
9D00A90C  8E020010   LW V0, 16(S0)
9D00A910  70C41802   MUL V1, A2, A0
9D00A914  00622021   ADDU A0, V1, V0
9D00A918  0F40245E   JAL .LFE0, memcpy
9D00A91C  02202821   ADDU A1, S1, ZERO
405:                     list->count++;
9D00A920  8E020008   LW V0, 8(S0)
9D00A924  24420001   ADDIU V0, V0, 1
9D00A928  AE020008   SW V0, 8(S0)
406:                 }
9D00A92C  8FBF001C   LW RA, 28(SP)
407:                 size_t n;
408:                         float cost;
409:                         Node neighbor;
410:                 ASPath ASPathCreate(const ASPathNodeSource *source, void *context, void *startNodeKey, void *goalNodeKey)
411:                 {
9D0002B8  27BDFFA0   ADDIU SP, SP, -96
9D0002BC  AFBF0044   SW RA, 68(SP)
9D0002C0  AFBE0040   SW FP, 64(SP)
9D0002C4  AFB7003C   SW S7, 60(SP)
9D0002C8  AFB60038   SW S6, 56(SP)
9D0002CC  AFB50034   SW S5, 52(SP)
9D0002D0  AFB40030   SW S4, 48(SP)
9D0002D4  AFB3002C   SW S3, 44(SP)
9D0002D8  AFB20028   SW S2, 40(SP)
9D0002DC  AFB10024   SW S1, 36(SP)
9D0002E0  AFB00020   SW S0, 32(SP)
9D0002E4  F7B50050   SDC1 F21, 80(SP)
9D0002E8  F7B40048   SDC1 F20, 72(SP)
9D0002EC  AFA40060   SW A0, 96(SP)
9D0002F0  AFA50064   SW A1, 100(SP)
9D0002F4  AFA60068   SW A2, 104(SP)
412:                     if (!startNodeKey || !source || !source->nodeNeighbors || source->nodeSize == 0) {
9D0002F8  10C00441   BEQ A2, ZERO, .LVL251
9D0002FC  AFA7006C   SW A3, 108(SP)
9D000300  108004D4   BEQ A0, ZERO, .LVL281
9D000304  00001021   ADDU V0, ZERO, ZERO
9D000308  8C820004   LW V0, 4(A0)
9D00030C  104004D1   BEQ V0, ZERO, .LVL281
9D000310  00001021   ADDU V0, ZERO, ZERO
9D000314  8C820000   LW V0, 0(A0)
9D000318  1040043B   BEQ V0, ZERO, 0x9D001408
9D00031C  24040001   ADDIU A0, ZERO, 1
413:                         return NULL;
9D001400  0B400595   J .LVL281
9D001404  00001021   ADDU V0, ZERO, ZERO
9D001408  0B400595   J .LVL281
9D00140C  00001021   ADDU V0, ZERO, ZERO
414:                     }
415:                 
416:                     VisitedNodes visitedNodes = VisitedNodesCreate(source, context);
417:                     ASNeighborList neighborList = NeighborListCreate(source);
418:                     Node current = GetNode(visitedNodes, startNodeKey);
419:                     Node goalNode = GetNode(visitedNodes, goalNodeKey);
420:                     ASPath path = NULL;
9D0012FC  0B4004F0   J .LVL243, .LBE1004, .LBB1005
9D001300  0000A821   ADDU S5, ZERO, ZERO
9D00131C  0B4004F0   J .LVL243, .LBE1004, .LBB1005
9D001320  0000A821   ADDU S5, ZERO, ZERO
421:                 
422:                     // mark the goal node as the goal
423:                     SetNodeIsGoal(goalNode);
424:                 
425:                     // set the starting node's estimate cost to the goal and add it to the open set
426:                     SetNodeEstimatedCost(current,  GetPathCostHeuristic(current, goalNode));
427:                     AddNodeToOpenSet(current, 0, NodeNull);
428:                 
429:                     // perform the A* algorithm
430:                     while (HasOpenNode(visitedNodes) && !NodeIsGoal((current = GetOpenNode(visitedNodes)))) {
9D0012A0  8E42001C   LW V0, 28(S2)
9D0012A4  1040000B   BEQ V0, ZERO, 0x9D0012D4
9D0012A8  8FAB0018   LW T3, 24(SP)
9D001554  1040FCDE   BEQ V0, ZERO, .LVL89
9D001558  8FAA0060   LW T2, 96(SP)
9D00155C  0B4004B5   J 0x9D0012D4
9D001560  8FAB0018   LW T3, 24(SP)
431:                         if (source->earlyExit) {
9D0008D0  8D42000C   LW V0, 12(T2)
9D0008D4  10400017   BEQ V0, ZERO, .LVL94, .LBE702, .LBB703, .LBB705
9D0008D8  8FA40010   LW A0, 16(SP)
9D0012C8  0B400234   J .LVL89
9D0012CC  8FAA0060   LW T2, 96(SP)
432:                             const int shouldExit = source->earlyExit(visitedNodes->nodeRecordsCount, GetNodeKey(current), goalNodeKey, context);
9D0008F4  8E44000C   LW A0, 12(S2)
9D0008F8  24A50014   ADDIU A1, A1, 20
9D0008FC  8FA6006C   LW A2, 108(SP)
9D000900  0040F809   JALR V0
9D000904  8FA70064   LW A3, 100(SP)
433:                 
434:                             if (shouldExit > 0) {
9D000908  18400008   BLEZ V0, .LVL93, .LBB702
9D00090C  00000000   NOP
435:                                 SetNodeIsGoal(current);
436:                                 break;
437:                             } else if (shouldExit < 0) {
9D00092C  04400269   BLTZ V0, 0x9D0012D4
9D000930  8FAB0018   LW T3, 24(SP)
438:                                 break;
439:                             }
440:                         }
441:                 
442:                         RemoveNodeFromOpenSet(current);
443:                         AddNodeToClosedSet(current);
444:                 
445:                         neighborList->count = 0;
9D000B58  AFC00008   SW ZERO, 8(FP)
446:                         source->nodeNeighbors(neighborList, GetNodeKey(current), context);
9D000B78  8FA60060   LW A2, 96(SP)
9D000B7C  8CC20004   LW V0, 4(A2)
9D000B80  03C02021   ADDU A0, FP, ZERO
9D000B84  24A50014   ADDIU A1, A1, 20
9D000B88  0040F809   JALR V0
9D000B8C  8FA60064   LW A2, 100(SP)
447:                         
448:                         for ( n=0; n<neighborList->count; n++) {
9D000B90  AF8080E0   SW ZERO, -32544(GP)
9D000B94  8FC20008   LW V0, 8(FP)
9D000B98  104001C1   BEQ V0, ZERO, .LVL228, .LBE942, .LBE946, .LBE954
9D000B9C  0000B821   ADDU S7, ZERO, ZERO
9D001268  8F9780E0   LW S7, -32544(GP)
9D00126C  26F70001   ADDIU S7, S7, 1
9D001270  AF9780E0   SW S7, -32544(GP)
9D001274  8FC20008   LW V0, 8(FP)
9D001278  02E2102B   SLTU V0, S7, V0
9D00127C  50400009   BEQL V0, ZERO, 0x9D0012A4
9D001280  8E42001C   LW V0, 28(S2)
449:                             cost = GetNodeCost(current) + NeighborListGetEdgeCost(neighborList, n);
9D000BC4  C4800008   LWC1 F0, 8(A0)
9D000BC8  4C430040   LWXC1 F1, 3(V0)
9D000BCC  46010000   ADD.S F0, F0, F1
9D000BD0  E78080DC   SWC1 F0, -32548(GP)
450:                             neighbor = GetNode(visitedNodes, NeighborListGetNodeKey(neighborList, n));
9D000D90  278380E4   ADDIU V1, GP, -32540
9D000D94  AC620000   SW V0, 0(V1)
9D000D98  AC760004   SW S6, 4(V1)
9D000D9C  00403021   ADDU A2, V0, ZERO
451:                 
452:                             if (!NodeHasEstimatedCost(neighbor)) {
9D000DBC  7C420100   EXT V0, V0, 4, 1
9D000DC0  54400020   BNEL V0, ZERO, 0x9D000E44
9D000DC4  278380E4   ADDIU V1, GP, -32540
453:                                 SetNodeEstimatedCost(neighbor, GetPathCostHeuristic(neighbor, goalNode));
454:                             }
455:                 //
456:                             if (NodeIsInOpenSet(neighbor) && cost < GetNodeCost(neighbor)) {
9D000E68  7C840040   EXT A0, A0, 1, 1
9D000E6C  1080007E   BEQ A0, ZERO, 0x9D001068
9D000E70  278480E4   ADDIU A0, GP, -32540
9D000E74  C4600008   LWC1 F0, 8(V1)
9D000E78  C78180DC   LWC1 F1, -32548(GP)
9D000E7C  46000F3C   C.LT.S 7, F1, F0
9D000E80  451E007A   BC1FL 7, .LVL198, .LBE899, .LBE906, .LBB907, .LBB909
9D000E84  8C830000   LW V1, 0(A0)
457:                                 RemoveNodeFromOpenSet(neighbor);
458:                             }
459:                 //
460:                             if (NodeIsInClosedSet(neighbor) && cost < GetNodeCost(neighbor)) {
9D00108C  30630001   ANDI V1, V1, 1
9D001090  5060000A   BEQL V1, ZERO, 0x9D0010BC
9D001094  278280E4   ADDIU V0, GP, -32540
9D001098  C4400008   LWC1 F0, 8(V0)
9D00109C  C78180DC   LWC1 F1, -32548(GP)
9D0010A0  46000C3C   C.LT.S 4, F1, F0
9D0010A4  45120005   BC1FL 4, 0x9D0010BC
9D0010A8  278280E4   ADDIU V0, GP, -32540
461:                                 RemoveNodeFromClosedSet(neighbor);
462:                             }
463:                 //
464:                             if (!NodeIsInOpenSet(neighbor) && !NodeIsInClosedSet(neighbor)) {
9D0010E0  7C420040   EXT V0, V0, 1, 1
9D0010E4  14400061   BNE V0, ZERO, .LVL226
9D0010E8  8F9780E0   LW S7, -32544(GP)
9D0010F0  30420001   ANDI V0, V0, 1
9D0010F4  1440005E   BNE V0, ZERO, 0x9D001270
9D0010F8  26F70001   ADDIU S7, S7, 1
465:                                 AddNodeToOpenSet(neighbor, cost, current);
466:                             }
467:                         }
468:                     }
469:                 
470:                     if (NodeIsNull(goalNode)) {
471:                         SetNodeIsGoal(current);
472:                     }
473:                 
474:                     if (NodeIsGoal(current)) {
9D0015BC  1040FF80   BEQ V0, ZERO, .LVL243, .LBE1004, .LBB1005
9D0015C0  0000A821   ADDU S5, ZERO, ZERO
9D0015C4  0080A021   ADDU S4, A0, ZERO
9D0015C8  02409821   ADDU S3, S2, ZERO
9D0015CC  00008821   ADDU S1, ZERO, ZERO
475:                         size_t count = 0;
476:                         Node n = current;
477:                 
478:                         while (!NodeIsNull(n)) {
479:                             count++;
480:                             n = GetParentNode(n);
481:                         }
482:                 
483:                         path = malloc(sizeof(struct __ASPath) + (count * source->nodeSize));
9D001338  0B400582   J .LVL275, .LBB1019
9D00133C  8FA60060   LW A2, 96(SP)
9D001608  8CD00000   LW S0, 0(A2)
9D00160C  72302002   MUL A0, S1, S0
9D001610  0F4012F7   JAL malloc
9D001614  2484000C   ADDIU A0, A0, 12
9D001618  0040A821   ADDU S5, V0, ZERO
484:                         path->nodeSize = source->nodeSize;
9D00161C  AC500000   SW S0, 0(V0)
485:                         path->count = count;
9D001620  AC510004   SW S1, 4(V0)
486:                         path->cost = GetNodeCost(current);
487:                 
488:                         n = current;
9D00164C  0B4004D0   J .LVL236, .LBB1003
9D001650  02408021   ADDU S0, S2, ZERO
489:                         int i;
490:                         for (i=count; i>0; i--) {
9D0013B8  1620FFE2   BNE S1, ZERO, .LVL237
9D0013BC  2631FFFF   ADDIU S1, S1, -1
9D001644  1A20FF5E   BLEZ S1, .LVL243, .LBE1004, .LBB1005
9D001648  E6A00008   SWC1 F0, 8(S5)
491:                             memcpy(path->nodeKeys + ((i - 1) * source->nodeSize), GetNodeKey(n), source->nodeSize);
9D001340  2631FFFF   ADDIU S1, S1, -1
9D001344  8FA70060   LW A3, 96(SP)
9D001348  8CE60000   LW A2, 0(A3)
9D00134C  72261002   MUL V0, S1, A2
9D001350  00552021   ADDU A0, V0, S5
9D001370  2484000C   ADDIU A0, A0, 12
9D001374  0F40245E   JAL .LFE0, memcpy
9D001378  24A50014   ADDIU A1, A1, 20
492:                             n = GetParentNode(n);
493:                         }
494:                     }
495:                 
496:                     NeighborListDestroy(neighborList);
497:                     VisitedNodesDestroy(visitedNodes);
498:                 
499:                     return path;
9D0013F8  0B400595   J .LVL281
9D0013FC  02A01021   ADDU V0, S5, ZERO
500:                 }
9D001654  8FBF0044   LW RA, 68(SP)
501:                 
502:                 void ASPathDestroy(ASPath path)
503:                 {
9D00CAE4  27BDFFE8   ADDIU SP, SP, -24
9D00CAE8  AFBF0014   SW RA, 20(SP)
504:                     free(path);
9D00CAEC  0F4031CD   JAL .LFB1, free
9D00CAF0  00000000   NOP
505:                 }
9D00CAF4  8FBF0014   LW RA, 20(SP)
506:                 
507:                 ASPath ASPathCopy(ASPath path)
508:                 {
00000000  00000000   NOP
509:                     if (path) {
00000014  00000000   NOP
510:                         const size_t size = sizeof(struct __ASPath) + (path->count * path->nodeSize);
0000001C  00000000   NOP
511:                         ASPath newPath = malloc(size);
0000002C  00000000   NOP
512:                         memcpy(newPath, path, size);
00000038  00000000   NOP
513:                         return newPath;
00000048  00000000   NOP
514:                     } else {
515:                         return NULL;
00000050  00000000   NOP
516:                     }
517:                 }
00000054  00000000   NOP
518:                 
519:                 float ASPathGetCost(ASPath path)
520:                 {
521:                     return path? path->cost : INFINITY;
00000000  00000000   NOP
522:                 }
00000010  00000000   NOP
523:                 
524:                 size_t ASPathGetCount(ASPath path)
525:                 {
526:                     return path? path->count : 0;
9D00CBA8  10800003   BEQ A0, ZERO, 0x9D00CBB8
9D00CBAC  00000000   NOP
9D00CBB0  03E00008   JR RA
9D00CBB4  8C820004   LW V0, 4(A0)
527:                 }
9D00CBB8  03E00008   JR RA
528:                 
529:                 void *ASPathGetNode(ASPath path, size_t index)
530:                 {
531:                     return (path && index < path->count)? (path->nodeKeys + (index * path->nodeSize)) : NULL;
9D00C490  1080000A   BEQ A0, ZERO, 0x9D00C4BC
9D00C494  00000000   NOP
9D00C498  8C820004   LW V0, 4(A0)
9D00C49C  00A2102B   SLTU V0, A1, V0
9D00C4A0  10400008   BEQ V0, ZERO, 0x9D00C4C4
9D00C4A4  00000000   NOP
9D00C4A8  8C820000   LW V0, 0(A0)
9D00C4AC  70A21802   MUL V1, A1, V0
9D00C4B0  00641021   ADDU V0, V1, A0
9D00C4B4  03E00008   JR RA
9D00C4B8  2442000C   ADDIU V0, V0, 12
9D00C4BC  03E00008   JR RA
9D00C4C0  00001021   ADDU V0, ZERO, ZERO
532:                 }
9D00C4C4  03E00008   JR RA
533:                 
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PT21-JOB1/src/pic32m-gcc/gcc/libgcc/libgcc2.c  ------
9D003DFC  00C04021   ADDU T0, A2, ZERO
9D004260  00C04021   ADDU T0, A2, ZERO
9D003E00  00804821   ADDU T1, A0, ZERO
9D004264  00801021   ADDU V0, A0, ZERO
9D003E04  14E0003B   BNE A3, ZERO, 0x9D003EF4
9D003E08  00A01821   ADDU V1, A1, ZERO
9D004268  14E0003F   BNE A3, ZERO, 0x9D004368
9D00426C  00A04821   ADDU T1, A1, ZERO
9D003E0C  00A6102B   SLTU V0, A1, A2
9D003E10  10400048   BEQ V0, ZERO, 0x9D003F34
9D003E14  70C21020   CLZ V0, A2
9D004270  00A6182B   SLTU V1, A1, A2
9D004274  10600047   BEQ V1, ZERO, 0x9D004394
9D004278  70C31820   CLZ V1, A2
9D003E18  50400008   BEQL V0, ZERO, 0x9D003E3C
9D003E1C  00083402   SRL A2, T0, 16
9D00427C  50600008   BEQL V1, ZERO, 0x9D0042A0
9D004280  00081C02   SRL V1, T0, 16
9D003E2C  00464004   SLLV T0, A2, V0
9D004290  00664004   SLLV T0, A2, V1
9D003E20  00021823   SUBU V1, ZERO, V0
9D003E24  00452804   SLLV A1, A1, V0
9D003E28  00641806   SRLV V1, A0, V1
9D003E30  00651825   OR V1, V1, A1
9D004284  00034823   SUBU T1, ZERO, V1
9D004288  00652804   SLLV A1, A1, V1
9D00428C  01244806   SRLV T1, A0, T1
9D004294  01254825   OR T1, T1, A1
9D003E34  00444804   SLLV T1, A0, V0
9D004298  00641004   SLLV V0, A0, V1
9D003E38  00083402   SRL A2, T0, 16
9D003E3C  0066001B   DIVU V1, A2
9D003E40  00C001F4   TEQ A2, ZERO
9D003E44  00002010   MFHI A0
9D003E48  00005812   MFLO T3
9D003E4C  310CFFFF   ANDI T4, T0, -1
9D003E50  00095402   SRL T2, T1, 16
9D003E54  716C5802   MUL T3, T3, T4
9D003E58  00042400   SLL A0, A0, 16
9D003E5C  008A5025   OR T2, A0, T2
9D003E60  014B682B   SLTU T5, T2, T3
9D003E64  0066001B   DIVU V1, A2
9D003E68  00C001F4   TEQ A2, ZERO
9D003E6C  51A00009   BEQL T5, ZERO, 0x9D003E94
9D003E70  014B5023   SUBU T2, T2, T3
9D003E74  01485021   ADDU T2, T2, T0
9D003E78  0148182B   SLTU V1, T2, T0
9D003E7C  54600005   BNEL V1, ZERO, 0x9D003E94
9D003E80  014B5023   SUBU T2, T2, T3
9D003E84  014B202B   SLTU A0, T2, T3
9D003E88  01481821   ADDU V1, T2, T0
9D003E8C  0064500B   MOVN T2, V1, A0
9D003E90  014B5023   SUBU T2, T2, T3
9D003E94  3123FFFF   ANDI V1, T1, -1
9D003E98  0146001B   DIVU T2, A2
9D003E9C  00C001F4   TEQ A2, ZERO
9D003EA0  00004810   MFHI T1
9D003EA4  00002012   MFLO A0
9D003EA8  708C2002   MUL A0, A0, T4
9D003EAC  00094C00   SLL T1, T1, 16
9D003EB0  01234825   OR T1, T1, V1
9D003EB4  0124182B   SLTU V1, T1, A0
9D003EB8  0146001B   DIVU T2, A2
9D003EBC  00C001F4   TEQ A2, ZERO
9D003EC0  50600009   BEQL V1, ZERO, .LBE15
9D003EC4  01244823   SUBU T1, T1, A0
9D003EC8  01284821   ADDU T1, T1, T0
9D003ECC  0128182B   SLTU V1, T1, T0
9D003ED0  54600005   BNEL V1, ZERO, .LBE15
9D003ED4  01244823   SUBU T1, T1, A0
9D003ED8  0124182B   SLTU V1, T1, A0
9D003EDC  01284021   ADDU T0, T1, T0
9D003EE0  0103480B   MOVN T1, T0, V1
9D003EE4  01244823   SUBU T1, T1, A0
9D00429C  00081C02   SRL V1, T0, 16
9D0042A0  0123001B   DIVU T1, V1
9D0042A4  006001F4   TEQ V1, ZERO
9D0042A8  00006010   MFHI T4
9D0042AC  00005812   MFLO T3
9D0042B0  310AFFFF   ANDI T2, T0, -1
9D0042B4  00022402   SRL A0, V0, 16
9D0042B8  00003012   MFLO A2
9D0042BC  716A3802   MUL A3, T3, T2
9D0042C0  000C6400   SLL T4, T4, 16
9D0042C4  01842025   OR A0, T4, A0
9D0042C8  0087602B   SLTU T4, A0, A3
9D0042CC  0123001B   DIVU T1, V1
9D0042D0  006001F4   TEQ V1, ZERO
9D0042D4  1180000B   BEQ T4, ZERO, 0x9D004304
9D0042D8  00872823   SUBU A1, A0, A3
9D0042DC  00882021   ADDU A0, A0, T0
9D0042E0  0088282B   SLTU A1, A0, T0
9D0042E4  14A00006   BNE A1, ZERO, 0x9D004300
9D0042E8  2566FFFF   ADDIU A2, T3, -1
9D0042EC  0087282B   SLTU A1, A0, A3
9D0042F0  10A00004   BEQ A1, ZERO, 0x9D004304
9D0042F4  00872823   SUBU A1, A0, A3
9D0042F8  2566FFFE   ADDIU A2, T3, -2
9D0042FC  00882021   ADDU A0, A0, T0
9D004300  00872823   SUBU A1, A0, A3
9D004304  3042FFFF   ANDI V0, V0, -1
9D004308  00A3001B   DIVU A1, V1
9D00430C  006001F4   TEQ V1, ZERO
9D004310  00004810   MFHI T1
9D004314  00003812   MFLO A3
9D004318  00002012   MFLO A0
9D00431C  70EA5002   MUL T2, A3, T2
9D004320  00094C00   SLL T1, T1, 16
9D004324  01221025   OR V0, T1, V0
9D004328  004A482B   SLTU T1, V0, T2
9D00432C  00A3001B   DIVU A1, V1
9D004330  006001F4   TEQ V1, ZERO
9D004334  51200009   BEQL T1, ZERO, 0x9D00435C
9D004338  00061400   SLL V0, A2, 16
9D00433C  00481021   ADDU V0, V0, T0
9D004340  0048402B   SLTU T0, V0, T0
9D004344  15000004   BNE T0, ZERO, 0x9D004358
9D004348  24E4FFFF   ADDIU A0, A3, -1
9D00434C  004A502B   SLTU T2, V0, T2
9D004350  24E7FFFE   ADDIU A3, A3, -2
9D004354  00EA200B   MOVN A0, A3, T2
9D004358  00061400   SLL V0, A2, 16
9D00435C  00821025   OR V0, A0, V0
9D004360  03E00008   JR RA
9D004364  00001821   ADDU V1, ZERO, ZERO
9D003F34  14C00006   BNE A2, ZERO, 0x9D003F50
9D003F38  71021020   CLZ V0, T0
9D004394  14C00006   BNE A2, ZERO, 0x9D0043B0
9D004398  71031820   CLZ V1, T0
9D003F3C  24020001   ADDIU V0, ZERO, 1
9D003F40  0046001B   DIVU V0, A2
9D003F44  00C001F4   TEQ A2, ZERO
9D003F48  00004012   MFLO T0
9D00439C  24030001   ADDIU V1, ZERO, 1
9D0043A0  0066001B   DIVU V1, A2
9D0043A4  00C001F4   TEQ A2, ZERO
9D0043A8  00004012   MFLO T0
9D003F4C  71021020   CLZ V0, T0
9D0043AC  71031820   CLZ V1, T0
9D003F50  5440007D   BNEL V0, ZERO, 0x9D004148
9D003F54  00484004   SLLV T0, T0, V0
9D0043B0  5460007B   BNEL V1, ZERO, 0x9D0045A0
9D0043B4  00684004   SLLV T0, T0, V1
9D003F58  00A82823   SUBU A1, A1, T0
9D003F5C  00081C02   SRL V1, T0, 16
9D003F60  3107FFFF   ANDI A3, T0, -1
9D0043B8  00A82023   SUBU A0, A1, T0
9D0043BC  00083C02   SRL A3, T0, 16
9D0043C0  310BFFFF   ANDI T3, T0, -1
9D0043C4  24030001   ADDIU V1, ZERO, 1
9D004148  24090020   ADDIU T1, ZERO, 32
9D00414C  01224823   SUBU T1, T1, V0
9D0045A0  24020020   ADDIU V0, ZERO, 32
9D0045A4  00431023   SUBU V0, V0, V1
9D004150  01255006   SRLV T2, A1, T1
9D0045A8  00454806   SRLV T1, A1, V0
9D00416C  00452804   SLLV A1, A1, V0
9D004170  01244806   SRLV T1, A0, T1
9D004174  01252825   OR A1, T1, A1
9D0045C4  00652804   SLLV A1, A1, V1
9D0045C8  00441006   SRLV V0, A0, V0
9D0045CC  00452825   OR A1, V0, A1
9D00417C  00444804   SLLV T1, A0, V0
9D0045D4  00641004   SLLV V0, A0, V1
9D004154  00081C02   SRL V1, T0, 16
9D004158  0143001B   DIVU T2, V1
9D00415C  006001F4   TEQ V1, ZERO
9D004160  00003010   MFHI A2
9D004164  00005812   MFLO T3
9D004168  3107FFFF   ANDI A3, T0, -1
9D004178  00056402   SRL T4, A1, 16
9D004180  71675802   MUL T3, T3, A3
9D004184  00063400   SLL A2, A2, 16
9D004188  01863025   OR A2, T4, A2
9D00418C  00CB202B   SLTU A0, A2, T3
9D004190  0143001B   DIVU T2, V1
9D004194  006001F4   TEQ V1, ZERO
9D004198  50800006   BEQL A0, ZERO, 0x9D0041B4
9D00419C  00CB3023   SUBU A2, A2, T3
9D0041A0  00C83021   ADDU A2, A2, T0
9D0041A4  00C8202B   SLTU A0, A2, T0
9D0041A8  10800024   BEQ A0, ZERO, 0x9D00423C
9D0041AC  00CB502B   SLTU T2, A2, T3
9D0041B0  00CB3023   SUBU A2, A2, T3
9D0041B4  30AAFFFF   ANDI T2, A1, -1
9D0041B8  00C3001B   DIVU A2, V1
9D0041BC  006001F4   TEQ V1, ZERO
9D0041C0  00002010   MFHI A0
9D0041C4  00002812   MFLO A1
9D0041C8  70A72802   MUL A1, A1, A3
9D0041CC  00042400   SLL A0, A0, 16
9D0041D0  008A2025   OR A0, A0, T2
9D0041D4  0085502B   SLTU T2, A0, A1
9D0041D8  00C3001B   DIVU A2, V1
9D0041DC  006001F4   TEQ V1, ZERO
9D0041E0  5140FF60   BEQL T2, ZERO, .LBB17
9D0041E4  00852823   SUBU A1, A0, A1
9D0041E8  00882021   ADDU A0, A0, T0
9D0041EC  0088302B   SLTU A2, A0, T0
9D0041F0  54C0FF5C   BNEL A2, ZERO, .LBB17
9D0041F4  00852823   SUBU A1, A0, A1
9D0041F8  0085502B   SLTU T2, A0, A1
9D0041FC  00883021   ADDU A2, A0, T0
9D004200  00CA200B   MOVN A0, A2, T2
9D004204  0B400FD9   J .LBB17
9D004208  00852823   SUBU A1, A0, A1
9D00423C  00C82021   ADDU A0, A2, T0
9D004240  0B40106C   J 0x9D0041B0
9D004244  008A300B   MOVN A2, A0, T2
9D0045AC  00083C02   SRL A3, T0, 16
9D0045B0  0127001B   DIVU T1, A3
9D0045B4  00E001F4   TEQ A3, ZERO
9D0045B8  00003010   MFHI A2
9D0045BC  00006012   MFLO T4
9D0045C0  310BFFFF   ANDI T3, T0, -1
9D0045D0  00056C02   SRL T5, A1, 16
9D0045D8  00001812   MFLO V1
9D0045DC  718B5002   MUL T2, T4, T3
9D0045E0  00063400   SLL A2, A2, 16
9D0045E4  01A63025   OR A2, T5, A2
9D0045E8  00CA202B   SLTU A0, A2, T2
9D0045EC  0127001B   DIVU T1, A3
9D0045F0  00E001F4   TEQ A3, ZERO
9D0045F4  5080000B   BEQL A0, ZERO, 0x9D004624
9D0045F8  00CA3023   SUBU A2, A2, T2
9D0045FC  00C83021   ADDU A2, A2, T0
9D004600  00C8202B   SLTU A0, A2, T0
9D004604  14800006   BNE A0, ZERO, 0x9D004620
9D004608  2583FFFF   ADDIU V1, T4, -1
9D00460C  00CA202B   SLTU A0, A2, T2
9D004610  50800004   BEQL A0, ZERO, 0x9D004624
9D004614  00CA3023   SUBU A2, A2, T2
9D004618  2583FFFE   ADDIU V1, T4, -2
9D00461C  00C83021   ADDU A2, A2, T0
9D004620  00CA3023   SUBU A2, A2, T2
9D004624  30ACFFFF   ANDI T4, A1, -1
9D004628  00C7001B   DIVU A2, A3
9D00462C  00E001F4   TEQ A3, ZERO
9D004630  00002010   MFHI A0
9D004634  00005012   MFLO T2
9D004638  00004812   MFLO T1
9D00463C  714B2802   MUL A1, T2, T3
9D004640  00042400   SLL A0, A0, 16
9D004644  008C2025   OR A0, A0, T4
9D004648  0085602B   SLTU T4, A0, A1
9D00464C  00C7001B   DIVU A2, A3
9D004650  00E001F4   TEQ A3, ZERO
9D004654  5180000B   BEQL T4, ZERO, 0x9D004684
9D004658  00031C00   SLL V1, V1, 16
9D00465C  00882021   ADDU A0, A0, T0
9D004660  0088302B   SLTU A2, A0, T0
9D004664  14C00006   BNE A2, ZERO, 0x9D004680
9D004668  2549FFFF   ADDIU T1, T2, -1
9D00466C  0085302B   SLTU A2, A0, A1
9D004670  50C00004   BEQL A2, ZERO, 0x9D004684
9D004674  00031C00   SLL V1, V1, 16
9D004678  2549FFFE   ADDIU T1, T2, -2
9D00467C  00882021   ADDU A0, A0, T0
9D004680  00031C00   SLL V1, V1, 16
9D004684  00852023   SUBU A0, A0, A1
9D004688  0B4010F2   J .LBB16
9D00468C  01231825   OR V1, T1, V1
9D003F64  00092402   SRL A0, T1, 16
9D003F68  00A3001B   DIVU A1, V1
9D003F6C  006001F4   TEQ V1, ZERO
9D003F70  00005010   MFHI T2
9D003F74  00003012   MFLO A2
9D003F78  70C73002   MUL A2, A2, A3
9D003F7C  000A5400   SLL T2, T2, 16
9D003F80  01442025   OR A0, T2, A0
9D003F84  0086502B   SLTU T2, A0, A2
9D003F88  00A3001B   DIVU A1, V1
9D003F8C  006001F4   TEQ V1, ZERO
9D003F90  51400009   BEQL T2, ZERO, 0x9D003FB8
9D003F94  00862023   SUBU A0, A0, A2
9D003F98  00882021   ADDU A0, A0, T0
9D003F9C  0088282B   SLTU A1, A0, T0
9D003FA0  54A00005   BNEL A1, ZERO, 0x9D003FB8
9D003FA4  00862023   SUBU A0, A0, A2
9D003FA8  0086502B   SLTU T2, A0, A2
9D003FAC  00882821   ADDU A1, A0, T0
9D003FB0  00AA200B   MOVN A0, A1, T2
9D003FB4  00862023   SUBU A0, A0, A2
9D003FB8  3126FFFF   ANDI A2, T1, -1
9D003FBC  0083001B   DIVU A0, V1
9D003FC0  006001F4   TEQ V1, ZERO
9D003FC4  00004810   MFHI T1
9D003FC8  00002812   MFLO A1
9D003FCC  70A72802   MUL A1, A1, A3
9D003FD0  00094C00   SLL T1, T1, 16
9D003FD4  01264825   OR T1, T1, A2
9D003FD8  0125302B   SLTU A2, T1, A1
9D003FDC  0083001B   DIVU A0, V1
9D003FE0  006001F4   TEQ V1, ZERO
9D003FE4  50C00009   BEQL A2, ZERO, .LBE17
9D003FE8  01254823   SUBU T1, T1, A1
9D003FEC  01284821   ADDU T1, T1, T0
9D003FF0  0128182B   SLTU V1, T1, T0
9D003FF4  54600005   BNEL V1, ZERO, .LBE17
9D003FF8  01254823   SUBU T1, T1, A1
9D003FFC  0125182B   SLTU V1, T1, A1
9D004000  01284021   ADDU T0, T1, T0
9D004004  0103480B   MOVN T1, T0, V1
9D004008  01254823   SUBU T1, T1, A1
9D0043C8  00023402   SRL A2, V0, 16
9D0043CC  0087001B   DIVU A0, A3
9D0043D0  00E001F4   TEQ A3, ZERO
9D0043D4  00006810   MFHI T5
9D0043D8  00006012   MFLO T4
9D0043DC  00004812   MFLO T1
9D0043E0  718B5002   MUL T2, T4, T3
9D0043E4  000D6C00   SLL T5, T5, 16
9D0043E8  01A63025   OR A2, T5, A2
9D0043EC  00CA682B   SLTU T5, A2, T2
9D0043F0  0087001B   DIVU A0, A3
9D0043F4  00E001F4   TEQ A3, ZERO
9D0043F8  11A00009   BEQ T5, ZERO, 0x9D004420
9D0043FC  00CA2823   SUBU A1, A2, T2
9D004400  00C83021   ADDU A2, A2, T0
9D004404  00C8202B   SLTU A0, A2, T0
9D004408  14800004   BNE A0, ZERO, 0x9D00441C
9D00440C  2589FFFF   ADDIU T1, T4, -1
9D004410  00CA202B   SLTU A0, A2, T2
9D004414  548000A6   BNEL A0, ZERO, 0x9D0046B0
9D004418  2589FFFE   ADDIU T1, T4, -2
9D00441C  00CA2823   SUBU A1, A2, T2
9D004420  3042FFFF   ANDI V0, V0, -1
9D004424  00A7001B   DIVU A1, A3
9D004428  00E001F4   TEQ A3, ZERO
9D00442C  00005010   MFHI T2
9D004430  00003012   MFLO A2
9D004434  00002012   MFLO A0
9D004438  70CB5802   MUL T3, A2, T3
9D00443C  000A5400   SLL T2, T2, 16
9D004440  01421025   OR V0, T2, V0
9D004444  004B502B   SLTU T2, V0, T3
9D004448  00A7001B   DIVU A1, A3
9D00444C  00E001F4   TEQ A3, ZERO
9D004450  51400009   BEQL T2, ZERO, .LBE16
9D004454  00091400   SLL V0, T1, 16
9D004458  00481021   ADDU V0, V0, T0
9D00445C  0048402B   SLTU T0, V0, T0
9D004460  15000004   BNE T0, ZERO, 0x9D004474
9D004464  24C4FFFF   ADDIU A0, A2, -1
9D004468  004B582B   SLTU T3, V0, T3
9D00446C  24C6FFFE   ADDIU A2, A2, -2
9D004470  00CB200B   MOVN A0, A2, T3
9D004474  00091400   SLL V0, T1, 16
9D004478  03E00008   JR RA
9D00447C  00821025   OR V0, A0, V0
9D0046B0  0B401107   J 0x9D00441C
9D003EE8  00491006   SRLV V0, T1, V0
9D00400C  00491006   SRLV V0, T1, V0
9D003EEC  03E00008   JR RA
9D003EF0  00001821   ADDU V1, ZERO, ZERO
9D004010  03E00008   JR RA
9D004014  00001821   ADDU V1, ZERO, ZERO
9D003EF4  00A7102B   SLTU V0, A1, A3
9D003EF8  14400047   BNE V0, ZERO, 0x9D004018
9D003EFC  70EA5020   CLZ T2, A3
9D004368  00A7102B   SLTU V0, A1, A3
9D00436C  14400044   BNE V0, ZERO, 0x9D004480
9D004370  70E84020   CLZ T0, A3
9D004480  00001821   ADDU V1, ZERO, ZERO
9D004484  03E00008   JR RA
9D004488  00001021   ADDU V0, ZERO, ZERO
9D004018  00801021   ADDU V0, A0, ZERO
9D00401C  03E00008   JR RA
9D004020  00A01821   ADDU V1, A1, ZERO
9D003F00  15400048   BNE T2, ZERO, 0x9D004024
9D003F04  240B0020   ADDIU T3, ZERO, 32
9D004374  55000045   BNEL T0, ZERO, 0x9D00448C
9D004378  24020020   ADDIU V0, ZERO, 32
9D003F08  00E5102B   SLTU V0, A3, A1
9D003F0C  14400005   BNE V0, ZERO, 0x9D003F24
9D003F10  00861023   SUBU V0, A0, A2
9D003F14  0086402B   SLTU T0, A0, A2
9D003F18  15000089   BNE T0, ZERO, 0x9D004140
9D003F1C  00801021   ADDU V0, A0, ZERO
9D00437C  00E5282B   SLTU A1, A3, A1
9D004380  14A000C8   BNE A1, ZERO, 0x9D0046A4
9D004384  0086302B   SLTU A2, A0, A2
9D004388  38C20001   XORI V0, A2, 1
9D00438C  03E00008   JR RA
9D004390  00001821   ADDU V1, ZERO, ZERO
9D0046A4  00001821   ADDU V1, ZERO, ZERO
9D003F20  00861023   SUBU V0, A0, A2
9D003F24  00A72823   SUBU A1, A1, A3
9D003F28  0082202B   SLTU A0, A0, V0
9D003F2C  03E00008   JR RA
9D003F30  00A41823   SUBU V1, A1, A0
9D004024  016A5823   SUBU T3, T3, T2
9D00448C  00481023   SUBU V0, V0, T0
9D004028  01473804   SLLV A3, A3, T2
9D00402C  01661006   SRLV V0, A2, T3
9D004030  00473825   OR A3, V0, A3
9D004490  01073804   SLLV A3, A3, T0
9D004494  00461806   SRLV V1, A2, V0
9D004498  00673825   OR A3, V1, A3
9D004060  01463004   SLLV A2, A2, T2
9D004034  01656806   SRLV T5, A1, T3
9D00449C  00455006   SRLV T2, A1, V0
9D004050  01452804   SLLV A1, A1, T2
9D004054  01641006   SRLV V0, A0, T3
9D004058  00451025   OR V0, V0, A1
9D0044B8  01052804   SLLV A1, A1, T0
9D0044BC  00441006   SRLV V0, A0, V0
9D0044C0  00452825   OR A1, V0, A1
9D004038  00074C02   SRL T1, A3, 16
9D00403C  01A9001B   DIVU T5, T1
9D004040  012001F4   TEQ T1, ZERO
9D004044  00006010   MFHI T4
9D004048  00001812   MFLO V1
9D00404C  30EEFFFF   ANDI T6, A3, -1
9D00405C  00022C02   SRL A1, V0, 16
9D004064  00004012   MFLO T0
9D004068  706E7802   MUL T7, V1, T6
9D00406C  000C6400   SLL T4, T4, 16
9D004070  01856025   OR T4, T4, A1
9D004074  018F282B   SLTU A1, T4, T7
9D004078  01A9001B   DIVU T5, T1
9D00407C  012001F4   TEQ T1, ZERO
9D004080  10A0000A   BEQ A1, ZERO, 0x9D0040AC
9D004084  01442004   SLLV A0, A0, T2
9D004088  01876021   ADDU T4, T4, A3
9D00408C  0187282B   SLTU A1, T4, A3
9D004090  14A00006   BNE A1, ZERO, 0x9D0040AC
9D004094  2468FFFF   ADDIU T0, V1, -1
9D004098  018F282B   SLTU A1, T4, T7
9D00409C  50A00004   BEQL A1, ZERO, 0x9D0040B0
9D0040A0  018F6023   SUBU T4, T4, T7
9D0040A4  2468FFFE   ADDIU T0, V1, -2
9D0040A8  01876021   ADDU T4, T4, A3
9D0040AC  018F6023   SUBU T4, T4, T7
9D0040B0  3042FFFF   ANDI V0, V0, -1
9D0040B4  0189001B   DIVU T4, T1
9D0040B8  012001F4   TEQ T1, ZERO
9D0040BC  00002810   MFHI A1
9D0040C0  00001812   MFLO V1
9D0040C4  00006812   MFLO T5
9D0040C8  706E7002   MUL T6, V1, T6
9D0040CC  00052C00   SLL A1, A1, 16
9D0040D0  00A21025   OR V0, A1, V0
9D0040D4  004E282B   SLTU A1, V0, T6
9D0040D8  0189001B   DIVU T4, T1
9D0040DC  012001F4   TEQ T1, ZERO
9D0040E0  50A00006   BEQL A1, ZERO, 0x9D0040FC
9D0040E4  00084400   SLL T0, T0, 16
9D0040E8  00471021   ADDU V0, V0, A3
9D0040EC  0047282B   SLTU A1, V0, A3
9D0040F0  10A0004C   BEQ A1, ZERO, .LBE25
9D0040F4  246DFFFF   ADDIU T5, V1, -1
9D0040F8  00084400   SLL T0, T0, 16
9D0040FC  01A84025   OR T0, T5, T0
9D004100  004E1023   SUBU V0, V0, T6
9D004224  004E282B   SLTU A1, V0, T6
9D004228  50A0FFB4   BEQL A1, ZERO, 0x9D0040FC
9D00422C  00084400   SLL T0, T0, 16
9D004230  246DFFFE   ADDIU T5, V1, -2
9D004234  0B40103E   J 0x9D0040F8
9D004238  00471021   ADDU V0, V0, A3
9D0044A0  00071C02   SRL V1, A3, 16
9D0044A4  0143001B   DIVU T2, V1
9D0044A8  006001F4   TEQ V1, ZERO
9D0044AC  00004810   MFHI T1
9D0044B0  00006812   MFLO T5
9D0044B4  30EBFFFF   ANDI T3, A3, -1
9D0044C4  00057402   SRL T6, A1, 16
9D0044C8  00001012   MFLO V0
9D0044CC  71AB6002   MUL T4, T5, T3
9D0044D0  00094C00   SLL T1, T1, 16
9D0044D4  012E4825   OR T1, T1, T6
9D0044D8  012C702B   SLTU T6, T1, T4
9D0044DC  0143001B   DIVU T2, V1
9D0044E0  006001F4   TEQ V1, ZERO
9D0044E4  11C0000A   BEQ T6, ZERO, 0x9D004510
9D0044E8  01063004   SLLV A2, A2, T0
9D0044EC  01274821   ADDU T1, T1, A3
9D0044F0  0127502B   SLTU T2, T1, A3
9D0044F4  15400006   BNE T2, ZERO, 0x9D004510
9D0044F8  25A2FFFF   ADDIU V0, T5, -1
9D0044FC  012C502B   SLTU T2, T1, T4
9D004500  51400004   BEQL T2, ZERO, 0x9D004514
9D004504  012C4823   SUBU T1, T1, T4
9D004508  25A2FFFE   ADDIU V0, T5, -2
9D00450C  01274821   ADDU T1, T1, A3
9D004510  012C4823   SUBU T1, T1, T4
9D004514  30A5FFFF   ANDI A1, A1, -1
9D004518  0123001B   DIVU T1, V1
9D00451C  006001F4   TEQ V1, ZERO
9D004520  00006810   MFHI T5
9D004524  00006012   MFLO T4
9D004528  00005012   MFLO T2
9D00452C  718B5802   MUL T3, T4, T3
9D004530  000D6C00   SLL T5, T5, 16
9D004534  01A52825   OR A1, T5, A1
9D004538  00AB682B   SLTU T5, A1, T3
9D00453C  0123001B   DIVU T1, V1
9D004540  006001F4   TEQ V1, ZERO
9D004544  51A0000B   BEQL T5, ZERO, 0x9D004574
9D004548  00021400   SLL V0, V0, 16
9D00454C  00A72821   ADDU A1, A1, A3
9D004550  00A7182B   SLTU V1, A1, A3
9D004554  14600006   BNE V1, ZERO, 0x9D004570
9D004558  258AFFFF   ADDIU T2, T4, -1
9D00455C  00AB182B   SLTU V1, A1, T3
9D004560  50600004   BEQL V1, ZERO, 0x9D004574
9D004564  00021400   SLL V0, V0, 16
9D004568  258AFFFE   ADDIU T2, T4, -2
9D00456C  00A72821   ADDU A1, A1, A3
9D004570  00021400   SLL V0, V0, 16
9D004574  01421025   OR V0, T2, V0
9D004578  00AB2823   SUBU A1, A1, T3
9D004104  01060019   MULTU 0, T0, A2
9D004108  00004810   MFHI T1
9D004120  00003012   MFLO A2
9D00457C  00460019   MULTU 0, V0, A2
9D004580  00003810   MFHI A3
9D00410C  0049182B   SLTU V1, V0, T1
9D004110  1460003E   BNE V1, ZERO, .LBB25
9D004114  00004012   MFLO T0
9D004118  1049004B   BEQ V0, T1, 0x9D004248
9D00411C  00491823   SUBU V1, V0, T1
9D004248  0088182B   SLTU V1, A0, T0
9D004584  00A7182B   SLTU V1, A1, A3
9D004588  14600044   BNE V1, ZERO, 0x9D00469C
9D00458C  00003012   MFLO A2
9D004590  10A7003F   BEQ A1, A3, 0x9D004690
9D004594  01042004   SLLV A0, A0, T0
9D004690  0086302B   SLTU A2, A0, A2
9D004694  10C0FFC0   BEQ A2, ZERO, 0x9D004598
9D004698  00000000   NOP
9D004598  03E00008   JR RA
9D00459C  00001821   ADDU V1, ZERO, ZERO
9D00469C  0B401166   J 0x9D004598
9D0046A0  2442FFFF   ADDIU V0, V0, -1
9D00420C  01063023   SUBU A2, T0, A2
9D004210  01271823   SUBU V1, T1, A3
9D004214  0106402B   SLTU T0, T0, A2
9D004218  00681823   SUBU V1, V1, T0
9D00421C  0B401049   J .LBB24
9D004220  00431823   SUBU V1, V0, V1
9D004124  00863023   SUBU A2, A0, A2
9D004128  0086202B   SLTU A0, A0, A2
9D00412C  00641823   SUBU V1, V1, A0
9D004130  01631004   SLLV V0, V1, T3
9D004134  01463006   SRLV A2, A2, T2
9D004138  00461025   OR V0, V0, A2
9D00413C  01431806   SRLV V1, V1, T2
9D004140  03E00008   JR RA
9D004144  00000000   NOP
9D0046A8  03E00008   JR RA
9D0046AC  24020001   ADDIU V0, ZERO, 1
